\chapter{Proper names, salience and accommodation}
\label{ch:propnames}
\setcounter{examplectr}{0}

\section{Montague's PTQ as a semantic benchmark}

In this chapter we will extend the linguistic coverage of the toy
grammar we presented in Chapter~\ref{ch:gram}.  We will take
Montague's PTQ \citep{Montague1973,Montague1974} as providing a benchmark of linguistic phenomena that
need to be covered, although we will add a few things which are
obviously closely related to Montague's original benchmark and which
have been treated subsequently in the literature.

For many of the phenomena we discuss we will first present a treatment
which is as close as possible to Montague's original treatment and
then present a treatment which exploits the advantages of the approach
we are proposing in this book as well as more recent developments
since Montague's original work.  Our aim is to show that we have
something to say about all these phenomena in an overall consistent
framework, that is, to show that we can cover the benchmark using the
tools we are proposing and in many cases say something new concerning
a dialogical approach to these phenomena.  In doing this within the
space of a single book we will not be able to cover all the aspects of
these phenomena which have been studied in the literature following
after Montague.  We hope, however, to show that it is a fruitful line
of research to add a type theoretic perspective and a dialogical
approach to current work in linguistic semantics.   
 



\section{Montague's treatment of proper names and a sign-based approach}

The treatment of proper names that we presented in
Chapter~\ref{ch:gram}, encapsulated in the definition of SemPropName
and Lex$_{\mathrm{PropName}}$
in Appendix~\ref{app:gramrules}, is an adaptation of Montague's
original treatment in that it has the content of a proper name utterance
as a quantifier generated from an individual.  The essence of
Montague's treatment was that if we have a proper name \textit{Sam}
whose denotation is based on an individual `sam', then the denotation
of \textit{Sam} is the characteristic function of the set of
properties possessed by the individual concept of `sam'.  Montague
modelled individual concepts as functions from possible worlds to
individuals.  Using more or less Montague's logical notation, the denotation of
\textit{Sam} would be represented by \nexteg{}.
\begin{ex} 
$\lambda P.P\{[\,\up\mathrm{sam}]\}$ 
\label{ex:MontagueSam}
\end{ex} 
Here $[\,\up\mathrm{sam}]$ represents the individual concept of `sam',
that is,
that function, $f$, on the set of possible worlds such that for any
world $w$, $f(w)=\mathrm{sam}$.  The reason that Montague used the
individual concept (and the associated special notion of application
involved in applying a property to an individual concept represented
by the `\{\}'-brackets) was to treat what is known as the Partee-puzzle
concerning temperature and price which we will discuss below.  Many
subsequent researchers came to the conclusion that Montague's treatment of
this puzzle was not the correct one and that the individual concept
was not necessary in the treatment of proper names.  Thus \preveg{}
could be simplified to \nexteg{}.
\begin{ex} 
$\lambda P.P(\mathrm{sam})$ 
\end{ex} 
The content that we assigned to an utterance of \textit{Sam} in
Chapter~\ref{ch:gram} is represented in \nexteg{}.
\begin{ex} 
$\lambda P$:\textit{Ppty}.$P$(\smallrecord{\field{x}{sam}}) 
\end{ex} 
The reason that we have chosen to characterize properties as having
records as their domain rather than individuals, has to do with our
treatment of the Partee puzzle as we will explain below.  Thus the
reason that we have the record \smallrecord{\field{x}{sam}} as the
argument to the property rather than an individual as in \nexteg{} is for the same reason as
Montague introduced an individual concept.
\begin{ex} 
$\lambda P$:\textit{Ppty}.$P$(sam) 
\end{ex} 
The treatment of proper names we presented in Chapter~\ref{ch:gram}
has an important advantage over
Montague's original.  For Montague, (\ref{ex:MontagueSam}) is the
result of applying an interpretation function to the linguistic
expression \textit{Sam} and a number of indices for the
interpretation, $\mathfrak{A}$, a possible world, $i$, a time, $j$,
and an assignment to variables, $g$.  This is represented in
\nexteg{}.
\begin{ex} 
\mng{Sam}$^{\mathfrak{A},i,j,g}$ = $\lambda P.P\{[\,\up\mathrm{sam}]\}$ 
\end{ex} 
This requires that the English expression \textit{Sam} is always
associated with the same individual `sam' with respect to
$\mathfrak{A},i,j,g$.  This seems to go against the obvious fact that
more than one individual can have the name \textit{Sam}.  It does not
work to say that a different individual can be associated with
\textit{Sam} when it is evaluated with respect to different
parameters.  $g$ is irrelevant since it is defined as an assignment to
variables and the English expression \textit{Sam} is not (associated
with) a variable --- it cannot be bound by a quantifier.  A strategy
which involves varying the
possible world and time to get a different individual associated with
\textit{Sam} would be defeated by the fact that there are many people
called Sam in the actual world right now as well as having the
unintuitive consequence that \textit{Sam might be Sam} would be true if it is true
that Sam might be somebody else called Sam and \textit{Sam will be
  Sam} could be true if somebody called Sam now is somebody else
called Sam at a future time.  We might try saying that associating a
different individual with Sam involves a different interpretation,
$\mathfrak{A}'$, of the language.  This has some intuitive appeal, but
it will come to grief when we need to talk about two people named Sam
in the same sentence unless we allow a switch in interpretation
mid-sentence.  While allowing interpretation to change mid-sentence
may be an attractive option for other reasons it is not an option that
is available on Montague's account of meaning.  The normal assumption
is that in cases where two individuals have the same name the language
contains two expressions which are pronounced the same, for example,
\textit{Sam}$_1$ and \textit{Sam}$_2$.  This would make the treatment
of proper names somewhat like Montague's treatment of pronouns in that
they have silent numerical subscripts attached to them.  How many
\textit{Sam}$_i$ should the language contain? One for each person
named Sam, now, in the past and future and who could be named Sam in
some non-actual world?  If we follow the strategy with variables we
would introduce countably many \textit{Sam}$_i$ so that we would
always have enough.  But with assignments to variables we can always
assign individuals to more that one variable without this causing a
problem.  But the consequence of doing this with proper names would be
to say that an individual can have many names that are pronounced the
same.  (Sam says, ``My name is Sam'', not ``My names are Sam''.) Similarly no two individuals would have the same name, although
they would be able to have distinct names which are pronounced the
same.  This would mean that the interpretation of \textit{have the
  same name} would have to mean ``have names which are pronounced the
same''.  This might cause difficulties distinguishing between a case
where we have two people named Sam and a case where people really do
have distinct names which are pronounced the same such as \textit{Ann}
and \textit{Anne} (unless you want to count this as a case of spelling
the same name differently).

In contrast the analysis of proper names we presented in
Chapter~\ref{ch:gram} is sign-based.  It allows several sign types to
share the same phonology but be associated with different contents.
Treating the language in terms of signs eliminates the need for
arbitrary indexing of proper names.  It also allows us to individuate
names in a sensible way.  One way to individuate names is by the
phonologies occurring in proper name sign types.  Thus if we have two
proper name sign types with the same phonology but contents associated
with different individuals, then we have two individuals with the same
name.  Note that this proposal would make \textit{Ann} and
\textit{Anne} different spellings of the same name since they are both
associated with the same phonological type.  How we individuate names
can be different in different contexts if we follow the kind of
proposal for counting discussed by \cite{Cooper2011}.  We could, for
example, introduce a field into lexical sign types for an
orthographical type and allow the individuation of names by either
phonology or orthography or a combination of both depending on what is
most useful to the purpose at hand.

Using signs in this way seems to give us a clear, if rather simple,
advantage over Montague's formal language approach, even though we
have so far essentiually just transplanted Montague's analysis of
proper names into our variant of a sign-based approach.  However,
there is a remaining question within sign-based approaches which is
a kind of correlate to the need on Montague's approach to create many
different names \textit{Sam}$_i$.  We are tempted to think of a
``language'' as being defined as a collection of sign types.  Thus a
person who knows English will know sign types which pair the
phonological type ``Sam'' with various individuals who are called
Sam.  The problem with this is that different speakers of English will
know different people named Sam and thus technically we would have to
say that they speak different languages.  This may well be a coherent
technical notion of language.  In the terminology of
Chapter~\ref{ch:gram} we would say that the two agents indeed have
different linguistic resources available to them.  But there is also a
resource which the two agents share, even if they do not have any
overlap in the people named Sam that they are aware of.  This is the
knowledge that \textit{Sam} is a proper name in English and can be
used to name individuals.  Arguably it is this knowledge which is
constitutive of English, rather than the knowledge of who is actually
called Sam, important though that might be for performing adequately
in linguistic situations.  In Chapter~\ref{ch:gram} we introduced sign
type contruction operations and in particular
`Lex$_{\mathrm{PropName}}$' which maps a phonological type and an
individual to an appropiate proper name sign type (see
Appendix~\ref{app:gramrules}).  We called this a universal resource
since it represents the general knowledge that utterances can be used
to name individuals.  In the English resources we defined there we
named sign types such as `Lex$_{\mathrm{PropName}}$(``Sam'', sam)',
where we specify both the phonological type and the individual
associated with it.  But, given the power of functional abstraction,
we can identify \nexteg{} as an English resource where the
phonological type is specified but not the particular individual.
\begin{ex} 
$\lambda x$:\textit{Ind} . Lex$_{\mathrm{PropName}}$(``Sam'', $x$)
\label{ex:lexpropnameSamResource} 
\end{ex} 
Saying that an agent has this function available as an English resource could
be argued to encode the fact that the agent has the knowledge that
\textit{Sam} is a proper name in English.  An agent who has this
resource has a recipe for constructing an appropriate sign type in
their resources whenever they meet somebody called Sam.  Knowing that
\textit{Sam} is a proper name in English is not a matter of knowing
who is called Sam but rather a matter of knowing what to do
linguistically when you encounter somebody called Sam.  Thus while we
have so far just taken over Montague's original analysis of proper
names we have given ourselves the opportunity to recast it in terms of
a theory which enables agents to update their linguistic resources as
they become aware of new facts about the world.

\section{Proper names and communication}

However, what we have done so far tells us little about the
communicative processes associated with utterances of proper names.
In \cite{Cooper2013b} we pointed out that this kind of analysis does not give us any way of placing the requirement
on the interlocutor's gameboard that there already be a person named
Sam available in order to integrate the new information onto the
gameboard.  As \cite{Ginzburg2012} points out, the successful use
of a proper name to refer to an individual $a$ requires that the name
be publically known as a name for $a$.  We will follow the analysis of
\cite{Cooper2013b} in parametrizing the content.  A
\textit{parametric content} is a function which maps a context to a
content.  As such it relates to Montague's technical notion of
  \textit{meaning} in his paper `Universal Grammar'
  \citep{Montague1970,Montague1974} where he regarded meaning as a
  function from possible worlds and contexts of use to denotations.
  This also corresponds to the notion of \textit{character} in
  \cite{Kaplan1978}.

We will take a context to be a situation
modelled as a record.  A simple proposal for a parametric content for
a proper name might be \nexteg{}.
\begin{ex} 
$\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . \\
\hspace*{1em}$\lambda P$:\textit{Ppty} . $P(r)$
\label{ex:paramcontpropname} 
\end{ex} 
This would allow any record with an individual labelled `x' to be
mapped to a proper name content.  Recall that the label `x' is picked
up by the notion of property that we defined in Chapter~\ref{ch:gram}
as being of type
(\smallrecord{\smalltfield{x}{\textit{Ind}}}$\rightarrow$\textit{RecType}),
an example being \nexteg{}. 
\begin{ex} 
$\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . \smallrecord{\smalltfield{e}{run($r$.x)}} 
\end{ex} 
Associating the phonological type ``Sam'' with
(\ref{ex:paramcontpropname}) would essentially be a way of
encapsulating in the interpretation of \textit{Sam} what is expressed
by (\ref{ex:lexpropnameSamResource}) --- namely, that potentially any
individual can be called Sam.  We want the parametric content of
\textit{Sam} to be
more restrictive than this.  It is going to be the tool that we use to
help us identify an appropriate referent when we are confronted with
an utterance of type ``Sam''.  The obvious constraint that we should
place is that the referent is indeed named Sam.  Thus we can restrict
(\ref{ex:paramcontpropname}) so that it is an appropriate parametric
content for \textit{Sam} rather than something that appears to be a
parametric content appropriate to proper names in general.  The
modification is given in \nexteg{}.
\begin{ex} 
$\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                         \smalltfield{e}{named(x, ``Sam'')}} . \\
\hspace*{5em}$\lambda P$:\textit{Ppty} . $P(r)$ 
\label{ex:parametricSam}
\end{ex} 
This is closely related to treatments of proper
names that were proposed earlier in situation semantics
\citep{GawronPeters1990,Cooper1991,BarwiseCooper1993}.   \preveg{}
maps a context in which there is an individual named Sam to a proper
name content based on that individual.  Care has to be taken with the
predicate `named' on this kind of analysis.  It is important that it
not be too restrictive, for example, requiring the legal registering
of the name.  It may be sufficient that someone at some point has
called the individual by the name.  The exact conditions under which a
situation may be of a type constructed with this predicate will vary
depending on the needs associated with the conversation at hand.  We
may, for example, take a stricter view of what it means to have a
certain name if we are talking in a court of law than if we are trying
to attract somebody's attention to avoid an accident on a
mountainside.  This flexibility of meaning ``in flux'' has been
discussed in \cite{CooperKempson2008,Cooper2012,Ludlow2014,GinzburgCooper2014,KrachtKlein2014} among many other
places and we will return to it several times in this chapter and
discuss it in more detail in Chapter~\ref{ch:coord}.

An alternative to the use of parametric contents is to use parametric
signs.  This could be formulated as in \nexteg{} where
Lex$_{\mathrm{PropName}}$ is the function for associating lexical
content with phonological types that was introduced in
Chapter~\ref{ch:gram} and summarized in Appendix~\ref{app:signtypeconstr}.
\begin{ex} 
$\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                         \smalltfield{e}{named(x, ``Sam'')}} . \\
\hspace*{5em}Lex$_{\mathrm{PropName}}$(``Sam'', $r$.x) 
\end{ex} 
Intuitively, \preveg{} says that given a situation in which there is
an individual named by the phonological type ``Sam'' we can construct
a sign type in which the phonological type ``Sam'' is associated with
that individual.  From the point of view of the formal semantics
tradition \preveg{} is a much more radical proposal than
(\ref{ex:parametricSam}).  The function (\ref{ex:parametricSam}) is a
close relative of Montague's \textit{meaning} and Kaplan's \textit{character}.
It is a function from contexts to contents, although our theory of
what contexts and contents are differs from both Montague's and
Kaplan's proposals.  The function in \preveg{}, however, is something
that creates a kind of linguistic resource on the basis of a context.
That is, given a context in which `sam' is named by ``Sam'' we derive
the information that linguistic signs can be used which associate
``Sam'' with `sam'.  If we did not know this before we are extending
the collection of linguistic resources we have available.  We suspect
that both parametric contents and parametric sign types could be of
importance for a theory of linguistic interpretation and learning.
For now, we will work with the less radical notion of parametric
content.

There are two main questions that need to be answered about parametric
contents.  One concerns how the compositional semantics works and the
other concerns the nature of contexts and how you compute with them.
We will take the compositionality issue first.  Let us assume that all
signs provide us with a parametric content rather than a content.  In
those cases where there is no constraint on what the context must be
we will use a trivial parametric content, that is, one that maps any
context (modelled as a record) to the same content.  Thus, for
example, if we wish to represent a theory in which the intransitive
verb \textit{leave} does not place any restrictions on the context, we
could represent its parametric content as \nexteg{}.
\begin{ex} 
$\lambda r_1$:\textit{Rec}.$\lambda r_2$:\smallrecord{\smalltfield{x}{\textit{Ind}}}.
\smallrecord{\smalltfield{e}{leave($r_2$.x)}}
\label{ex:parametricLeave}
\end{ex}
This will map any context $r_1$ to the function $\lambda r_2$:\smallrecord{\smalltfield{x}{\textit{Ind}}}.
\smallrecord{\smalltfield{e}{leave($r_2$.x)}} which does not depend in
any way on $r_1$.

A standard strategy for dealing with compositional semantics when
using parametric contents is to use a version of what is known in
combinatorial logic as the S-combinator.  In its $\lambda$-calculus
version this is \nexteg{}.
\begin{ex} 
$\lambda z. \alpha(z)(\beta(z))$ 
\end{ex} 
Our version of the S-combinator including different type requirements
on the context arising from the function and the argument will be
\nexteg{}.
\begin{ex} 
if $\alpha : (T_1 \rightarrow (T_2 \rightarrow T_3))$ and 
\hspace*{1em}$\beta
  : (T_4\rightarrow T_2)$ then the \textit{combination of $\alpha$ and
    $\beta$  based on functional application} is 
\begin{quote}
$\lambda r$:\smallrecord{\smalltfield{f}{$T_1$} \\
                         \smalltfield{a}{$T_4$}}. $\alpha(r.\textrm{f})(\beta(r.\textrm{a}))$
\end{quote} 
\end{ex} 
Note that in the context requirements for the result we have kept the
context types for the functor $\alpha$ and the argument $\beta$
separated in their own fields labelled `f' (``function'') and `a'
(``argument'').\footnote{While textually this statement of the combination
  will be correct, we need to take account of the fact that the
  abbreviatory notation for labels in argument positions to predicates
  now represent path-names in $T_1$ and $T_4$ to which the labels `f'
  and `a' have been prefixed respectively.  To be precise we could
  notate this is ${T_1}^{f.}$ and ${T_4}^{a.}$.}  This means that we avoid an unwanted clash of labels
if $T_1$ and $T_4$ should happen to share labels.  We could used
\preveg{} to combine the contents (\ref{ex:parametricSam}) and
(\ref{ex:parametricLeave}).  This is given in \nexteg{} where we can
show by successive applications of $\beta$-reduction that
\nexteg{a--d} all represent the same function.
\begin{ex} 
\begin{subex} 
 
\item $\lambda
  r_1$:\smallrecord{\smalltfield{f}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                               \smalltfield{e}{named(x,
                                                 ``Sam'')}}}\\
                  \smalltfield{a}{\textit{Rec}}} . \\
\hspace*{2em}($\lambda r_2$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                         \smalltfield{e}{named(x, ``Sam'')}} . $\lambda P$:\textit{Ppty} . $P(r_2)$)($r_1$.f)\\
\hspace*{4em}($\lambda r_3$:\textit{Rec}.$\lambda r_4$:\smallrecord{\smalltfield{x}{\textit{Ind}}}.
\smallrecord{\smalltfield{e}{leave($r_4$.x)}}($r_1$.a)) 
 
\item  $\lambda
  r_1$:\smallrecord{\smalltfield{f}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                               \smalltfield{e}{named(x,
                                                 ``Sam'')}}}\\
                  \smalltfield{a}{\textit{Rec}}} . \\
\hspace*{2em}$\lambda P$:\textit{Ppty} . $P$($r_1$.f)\\
\hspace*{4em}($\lambda r_4$:\smallrecord{\smalltfield{x}{\textit{Ind}}}.
\smallrecord{\smalltfield{e}{leave($r_4$.x)}}) 

\item $\lambda
  r_1$:\smallrecord{\smalltfield{f}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                               \smalltfield{e}{named(x,
                                                 ``Sam'')}}}\\
                  \smalltfield{a}{\textit{Rec}}} . \\
\hspace*{2em}$\lambda r_4$:\smallrecord{\smalltfield{x}{\textit{Ind}}}.
\smallrecord{\smalltfield{e}{leave($r_4$.x)}}($r_1$.f)

\item $\lambda
  r_1$:\smallrecord{\smalltfield{f}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                               \smalltfield{e}{named(x,
                                                 ``Sam'')}}}\\
                  \smalltfield{a}{\textit{Rec}}} . \\
\hspace*{2em}
\smallrecord{\smalltfield{e}{leave($r_1$.f.x)}}
 
 
\end{subex} 
\label{ex:paramcontSamLeft}   
\end{ex} 
\preveg{} represents the parametric content of \textit{Sam leaves}.
Given a situation containing an individual, $a$, named by ``Sam'' it
returns a type of situation in which $a$ leaves.  As usual this type
can play the role of a ``proposition''.  It  is, for example, ``true''
if there is a situation of the type and ``false'' if there is no
situation of the type.  

The domain type on the parametric content
is to be thought of as placing a constraint on the context.  The idea
is that you can only get to the non-parametric content if you have an
appropriate situation available.  The domain type of the parametric
content represents a kind of \textit{presupposition}.  We shall treat
presuppositions as constraints on the resources available to dialogue
participants.  In Chapter~\ref{ch:infex} we introduced the notion of a
dialogue gameboard as a type of dialogue information state.  The most
obvious place to look for the referent of an utterance of a proper
name is in the shared commitments represented on the gameboard
representing what has been committed to in the dialogue so far.  If an
individual named Sam has already been introduced in the dialogue, then
a subsequent utterance of \textit{Sam} in that dialogue is most likely
to refer to that individual unless there is an explicit indication to
the contrary.  The shared commitments on an agent's dialogue gameboard
represent information that is particularly \textit{salient} to the
agent.  The notion of salience in semantics was first introduced by
\cite{Lewis1979} in connection with the analysis of definite
descriptions.  As Lewis says, ``There are various ways for something
to gain salience. Some have to do with the course of conversation,
others do not.''  We wish to suggest that a way of gaining salience in
a conversation is by figuring in the shared commitments on the
gameboard.  (\cite{Ginzburg2012} argues that being on shared
commitments, or FACTS in his terminology, is not always sufficient to
indicate salience.)

A reasonable strategy, then, is to look at the shared
commitments on the dialogue gameboard first and then look elsewhere if
that fails.  We will first explore what we need to do to match the
domain type of a parametric content against the type which models the
shared commitments of the dialogue and then we will discuss what needs
to be done if there is not a successful match with the shared
commitments. In Chapter~\ref{ch:infex}  we treated the gameboard as a
record type.  In Chapter~\ref{ch:infex}, example 
(\ref{ex:gameboardDudamelBeethovenUchida}), for instance, the shared commitments
were represented as the type \nexteg{}.
\begin{ex} 
\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\textit{Rec}}
    \\
                                                                                                       \smalltfield{e}{conductor(dudamel)}}}
                                                                   \\
                                                                       \smalltfield{e}{composer(beethoven)}}}
                                   \\
                                       \smalltfield{e}{pianist(uchida)}} 
\end{ex} 
Recall that with each successive updating of the shared commitments
the record type representing the previous state of shared commitments
was embedded under the label `prev' (``previous'').  This prevented
label clash but also kept a record of the order in which information
was introduced.  As \cite{Lewis1979} observed, information introduced
later in the dialogue tends to be more salient than information
introduced earlier.  Thus keeping track of the order also gives us one
measure of relative salience.

In Chapter~\ref{ch:infex} we were using the Montague treatment of
proper names that did not introduce the naming predicate.  In this
chapter we will work towards shared commitments where the naming
associated with proper names is made explicit, as in \nexteg{}.
\begin{ex} 
\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\textit{Rec}}\\
                                                                             \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                                                           \smalltfield{e}{named(x, ``Dudamel'')}}}\\
                                                                              \smalltfield{e}{conductor(bg.x)}}}
                                                                   \\
                                              \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                            \smalltfield{e}{named(x, ``Beethoven'')}}}\\
                                              \smalltfield{e}{composer(bg.x)}}}
                                   \\
              \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                            \smalltfield{e}{named(x, ``Uchida'')}}}\\
              \smalltfield{e}{pianist(bg.x)}}
\label{ex:gameboardDudamelBeethovenUchidaBg}  
\end{ex} 
Here we are using the label `bg' to represent background information
in the manner suggested by \cite{Larsson2010}.  Note that in this
version of the shared commitments we have lost the connection with the
actual individuals `dudamel', `beethoven' and `uchida'.  This can be
seen as an advantage if we are representing the information state of
an agent in the kind of situation described in Chapter~\ref{ch:infex}.
If we simply inform an agent with no previous knowledge of Dudamel that Dudamel
is a conductor, then the information that this agent will get is that
there is somebody named Dudamel who is a conductor.  There will be no
connection to a particular individual of whom the agent is aware.  If
this is not the case, we can reinstate the connection to the
individuals by using manifest fields to anchor the information as in
\nexteg{}.
\begin{ex} 
\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\textit{Rec}}\\
                                                                             \smalltfield{bg}{\smallrecord{\smallmfield{x}{dudamel}{\textit{Ind}}\\
                                                                                                           \smalltfield{e}{named(x, ``Dudamel'')}}}\\
                                                                              \smalltfield{e}{conductor(bg.x)}}}
                                                                   \\
                                              \smalltfield{bg}{\smallrecord{\smallmfield{x}{beethoven}{\textit{Ind}}\\
                                                                            \smalltfield{e}{named(x, ``Beethoven'')}}}\\
                                              \smalltfield{e}{composer(bg.x)}}}
                                   \\
              \smalltfield{bg}{\smallrecord{\smallmfield{x}{uchida}{\textit{Ind}}\\
                                            \smalltfield{e}{named(x, ``Uchida'')}}}\\
              \smalltfield{e}{pianist(bg.x)}}   
\end{ex} 
The `bg'-fields in (\ref{ex:gameboardDudamelBeethovenUchidaBg}) might
be thought of as corresponding to the internal anchors of
\cite{Kamp1990,KampGenabithReyle2011}.  The use of manifest fields in
\preveg{} would then correspond to the association of what they call external anchors
with those internal anchors.

The task we have before us is to try to match the domain type of the function
in (\ref{ex:paramcontSamLeft}), that is \nexteg{}, against the types of shared commitments
in (\ref{ex:gameboardDudamelBeethovenUchidaBg}) or \preveg{}.
\begin{ex} 
\smallrecord{\smalltfield{f}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                               \smalltfield{e}{named(x,
                                                 ``Sam'')}}}\\
                  \smalltfield{a}{\textit{Rec}}}
\label{ex:namedSam} 
\end{ex} 
Intuitively, this attempt at matching should fail since there is no
commitment to an individual named Sam in the shared commitments.
Suppose now that we add to
(\ref{ex:gameboardDudamelBeethovenUchidaBg}) as in \nexteg{}.
\begin{ex} 
\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\textit{Rec}}\\
                                                                             \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                                                           \smalltfield{e}{named(x, ``Dudamel'')}}}\\
                                                                              \smalltfield{e}{conductor(bg.x)}}}
                                                                   \\
                                              \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                            \smalltfield{e}{named(x, ``Beethoven'')}}}\\
                                              \smalltfield{e}{composer(bg.x)}}}
                                   \\
              \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                            \smalltfield{e}{named(x, ``Uchida'')}}}\\
              \smalltfield{e}{pianist(bg.x)}}}\\
     \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                   \smalltfield{e}{named(x,
                                     ``Sam'')}}}\\
     \smalltfield{e}{singer(bg.x)}} 
\label{ex:sharedcommsnonexpanded}
\end{ex} 
Intuitively, this should enable a match since this does commit to an
individual named Sam.  However, there is not a direct formal
relationship between (\ref{ex:namedSam}) and \preveg{} corresponding
to this intuition. We will use flattening and relabelling of record
types in order to capture the relationship.  First recall that
\preveg{} is an abbreviated form of \nexteg{} where we have expanded
the paths of the labels which are used as arguments to predicates.  (We
use $\ell^n$ for $\ell.\ell.\ldots.\ell$ where the label $\ell$ occurs $n$ times.) 
\begin{ex} 
\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\textit{Rec}}\\
                                                                             \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                                                           \smalltfield{e}{named(prev$^3$.bg.x, ``Dudamel'')}}}\\
                                                                              \smalltfield{e}{conductor(prev$^3$.bg.x)}}}
                                                                   \\
                                              \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                            \smalltfield{e}{named(prev$^2$.bg.x, ``Beethoven'')}}}\\
                                              \smalltfield{e}{composer(prev$^2$.bg.x)}}}
                                   \\
              \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                            \smalltfield{e}{named(prev.bg.x, ``Uchida'')}}}\\
              \smalltfield{e}{pianist(prev.bg.x)}}}\\
     \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                   \smalltfield{e}{named(bg.x,
                                     ``Sam'')}}}\\
     \smalltfield{e}{singer(bg.x)}}
\label{ex:nonflatsharedcomms} 
\end{ex}
The result of flattening \preveg{} will be a new type \nexteg{} where each path
has been replaced by a single complex label consisting of the sequence
of labels on the path (which we represent using the normal
dot-notation for paths).
\begin{ex} 
\record{\tfield{prev$^4$}{\textit{Rec}} \\
        \tfield{prev$^3$.bg.x}{\textit{Ind}} \\
        \tfield{prev$^3$.bg.e}{named(prev$^3$.bg.x, ``Dudamel'')} \\
        \tfield{prev$^3$.e}{conductor(prev$^3$.bg.x)} \\
        \tfield{prev$^2$.bg.x}{\textit{Ind}} \\
        \tfield{prev$^2$.bg.e}{named(prev$^2$.bg.x, ``Beethoven'')} \\
        \tfield{prev$^2$.e}{composer(prev$^2$.bg.x)} \\
        \tfield{prev.bg.x}{\textit{Ind}} \\
        \tfield{prev.bg.e}{named(prev.bg.x, ``Uchida'')} \\
        \tfield{prev.e}{pianist(prev.bg.x)} \\
        \tfield{bg.x}{\textit{Ind}} \\
        \tfield{bg.e}{named(bg.x, ``Sam'')} \\
        \tfield{e}{singer(bg.x)}}
\label{ex:flatsharedcomms}
\end{ex} 
While (\ref{ex:nonflatsharedcomms}) and \preveg{} are distinct record types which do
not share any witnesses there is nevertheless a strong equivalence
between them in that for any record which is of the type
(\ref{ex:nonflatsharedcomms}) there is a multiset extensionally
equivalent record (see Appendix~\ref{app:rectypes}) of type \preveg{} and \textit{vice
  versa}.  There is a one-one mapping between the two types which
preserves multiset extension.  Intuitively, this means that the two
types represent the same basic commitments about the world, namely
Dudamel is a conducor, Beethoven is a composer, Uchida is a pianist
and Sam is a singer.  The difference between the two types involves
the structure they impose on this world.  In the case of \preveg{} we
have one big situation in which all of these facts hold and in
(\ref{ex:nonflatsharedcomms}) we have a situation which is made up of
several smaller situations for each of the individuals involved. Note,
however, that because we have used the complex labels representing the
paths we are able to recreate that structure from the flattened type
in \preveg{}.
Note also that we can still read off the relative salience of the
various individuals and facts by checking the number of occurrences
of `prev' in the label.

We can also flatten the type we are trying to match, that is
(\ref{ex:namedSam}).  The result is \nexteg{}.
\begin{ex} 
\record{\tfield{f.x}{\textit{Ind}} \\
        \tfield{f.e}{named(f.x, ``Sam'')} \\
        \tfield{a}{\textit{Rec}}}
\end{ex} 

In order to match \preveg{} against (\ref{ex:flatsharedcomms}) we look
for a relabelling of \preveg{} that would make
(\ref{ex:flatsharedcomms}) be a subtype of \preveg{}.  Such a
relabelling is given in \nexteg{}.
\begin{ex} 
\record{\tfield{bg.x}{\textit{Ind}} \\
        \tfield{bg.e}{named(bg.x, ``Sam'')} \\
        \tfield{prev$^4$}{\textit{Rec}}}
\end{ex}
This means, then, that any situation which is of the type required by
the shared commitments would, modulo the relabelling, be of the type
required for the domain of the parametric content
(\ref{ex:paramcontSamLeft}).  The domain of the parametric content is
being used as a presupposition which is being matched against the
hearer's current information state.

Given that we have now found a match, how can we go about updating the
shared commitments with the new information represented by the
parametric content?  The technique for doing this will involve the
notion of a \textit{fixed point type}.  Given a function, $f$, that returns
a type, we can always ask the question:  is there an object, $a$, such
that $a:f(a)$.  That is, $a$ is of the type which is the result of
applying $f$ to $a$ itself.  This means that $a$ is a \textit{fixed
  point} for $f$.  This raises a further question: can we characterize
a type $T$ such that any $a$ which is of type $T$ will be a fixed
point for $f$?  In this case $T$ will be called a \textit{fixed point
  type} for $f$.  Consider the example of the parametric content of
\textit{Sam left} in (\ref{ex:paramcontSamLeft}) repeated as
\nexteg{a}.  A fixed point type of this function is given in
\nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item $\lambda
  r_1$:\smallrecord{\smalltfield{f}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                               \smalltfield{e}{named(x,
                                                 ``Sam'')}}}\\
                  \smalltfield{a}{\textit{Rec}}} . 
%\hspace*{2em}
\smallrecord{\smalltfield{e}{leave($r_1$.f.x)}} 
 
\item \smallrecord{\smalltfield{f}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                               \smalltfield{e}{named(x,
                                                 ``Sam'')}}}\\
                  \smalltfield{a}{\textit{Rec}} \\
                  \smalltfield{e}{leave(f.x)}} 
 
\end{subex} 
\label{ex:parcontfixedpoint}   
\end{ex} 
Any record of type \preveg{b} will be a fixed point for
\preveg{a}. \preveg{b} can be obtained by applying the fixed point
type construction function, $\mathcal{F}$, to \preveg{a}.  This
function is defined explicitly in Appendix~\ref{app:merge},
p.~\pageref{pg:fixedpointtype}. 

If we are updating (\ref{ex:sharedcommsnonexpanded}) with the parametric
content \preveg{a} then the result should be \nexteg{} where
(\ref{ex:sharedcommsnonexpanded}) has been embedded under the label
`prev' and the new information provided by the parametric content has
been added at the top level of the new type, suitably relabelled so as
to pick out the individual named Sam which has been previously introduced.
\begin{ex}

\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\textit{Rec}}\\
                                                                             \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                                                           \smalltfield{e}{named(x, ``Dudamel'')}}}\\
                                                                              \smalltfield{e}{conductor(bg.x)}}}
                                                                   \\
                                              \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                            \smalltfield{e}{named(x, ``Beethoven'')}}}\\
                                              \smalltfield{e}{composer(bg.x)}}}
                                   \\
              \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                            \smalltfield{e}{named(x, ``Uchida'')}}}\\
              \smalltfield{e}{pianist(bg.x)}}}\\
     \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                   \smalltfield{e}{named(x,
                                     ``Sam'')}}}\\
     \smalltfield{e}{singer(bg.x)}}} \\
\smalltfield{e}{leave(prev.bg.x)}} 
\end{ex}
We can achieve this update by using the tools of flattening and
relabelling that we have just introduced.  Suppose that $T_{\mathrm{comm}}$ is the
type representing shared commitments that we wish to update with a
function $f:(T_{\mathrm{bg}}\rightarrow\textit{Type})$ corresponding
to a parametric content for some utterance.  The
first thing to do is embed  $T_{\mathrm{comm}}$ under the label `prev', obtaining
\smallrecord{\smalltfield{prev}{$T_{\mathrm{comm}}$}}.  We need to
consider the flattened version of this type, that is,
$\varphi$(\smallrecord{\smalltfield{prev}{$T_{\mathrm{comm}}$}}). We
need to find a relabelling, $\eta$, of the flattened version of
$T_{\mathrm{bg}}$ such that
$\varphi$(\smallrecord{\smalltfield{prev}{$T_{\mathrm{comm}}$}})
$\sqsubseteq$ $[\varphi(T_{\mathrm{bg}})]_\eta$, that is, the
flattened version of
\smallrecord{\smalltfield{prev}{$T_{\mathrm{comm}}$}} is a subtype of
result of relabelling the flattened version of $T_{\mathrm{bg}}$ with
$\eta$.  Having found such an $\eta$ we use it to relabel the fixed
point type, $\mathcal{F}(f)$.  $\eta$ in general will not be defined
on all the labels of $\mathcal{F}(f)$ since its set of labels will be
a superset of the set of labels of $T_{\mathrm{bg}}$.  What we need is
a relabelling of $\mathcal{F}(f)$, $\eta'$ which is an extension of
$\eta$, that is, the domain of $\eta$ is a subset of the domain of
$\eta'$ and  for any label, $\ell$, in the domain of $\eta$,
$\eta'(\ell)=\eta(\ell)$.\label{pg:etaprime}  We can now compute the merge of the two
flattened types we have obtained, that is,
$\varphi$(\smallrecord{\smalltfield{prev}{$T_{\mathrm{comm}}$}})\d{$\wedge$}$[\varphi(\mathcal{F}(f))]_{\eta'}$.
Finally, we can unflatten the resulting merge, obtaining the final
result of the update,
$\varphi^-$($\varphi$(\smallrecord{\smalltfield{prev}{$T_{\mathrm{comm}}$}})\d{$\wedge$}$[\varphi(\mathcal{F}(f))]_{\eta'}$).

\section{Proper names and accommodation}

What we have presented so far enables us to find a match for
presuppositions introduced by a parametric content when such a match
is present in shared commitments.  Suppose there is more than one such
match.  In that case there will be a choice of relabellings $\eta$.
In this case we may wish to choose the relabelling that corresponds to
a match with the most salient match in terms of recency of
introduction into the shared commitments.  Technically, this means
that we choose the relabelling which introduces labels with the least
number of occurrences of `prev'.  This would be an oversimplified
notion of saliency in terms of recency since it is based on the first
introduction of the referent into the discourse.  Obviously any
subsequent mention of the referent will raise its salience in terms of
recency.  Also there may be other factors than recency which
contribute to salience.

What happens when there is no match for \textit{Sam} in the shared
commitments?  Here we need some kind of accommodation in order to use
the parametric content to update the gameboard.  There are two kinds
of accommodation we will consider.  The first is where the agent knows
of a person named Sam independently of the current conversation.  That
is, a match for \textit{Sam} can be found in the agent's resources
corresponding to long term memory.  We will not attempt a detailed
account of the stucture of long term memory.  We assume that it is
complex and constantly in flux not only in terms of new information
being added but also in terms of what is salient in the old
information, depending on which part of the memory is being focussed
on at any particular time.  Here we will content ourselves with a
simple model of long term memory as a record type of a similar kind to
that we have proposed for shared commitments.  This means that the
techniques we need for matching will be the same as those discussed
above.  In reality the notion of salience with respect to long term
memory will be a good deal more complicated than salience with respect
to the shared commitments on the dialogue gameboard.  You have to take
into account not only recency but also likelihood based on other
knowledge that it is this particular Sam that is being referred to.
For example, if you believe that your interlocutor could not possibly
know of the Sam in your memory who is otherwise the most likely
candidate you should not choose that Sam as a match.  Choosing an
appropriate match involves a great deal of world knowledge and common
sense.  We will ignore these matters and concentrate our attention on
what needs to be done if we find a suitable match.  The idea is that
if you have failed to find a match in shared commitments on the
gameboard but you do find a match in long term memory, then you need
to load the item from long term memory into the shared commitments on
your gameboard.  This is what will constitute accommodation in this
case.

We will introduce the notion of a \textit{total information state}
which includes a record type corresponding to long term memory,
represented by the `ltm'-field in \nexteg{} and a dialogue gameboard,
represented by the `gb'-field in \nexteg{}.  Up until now we have
thought of the gameboard as a record type.  Now, however, we want to
be able to make links from the gameboard to long term memory and we
will achieve this by making the gameboard be a dependent type which
maps records (situations) of the type representing long term memory to
the record type representing the gameboard.  Thus a total information state
will be of the type \nexteg{}.
\begin{ex} 
\record{\tfield{ltm}{\textit{RecType}} \\
        \tfield{gb}{(ltm$\rightarrow$\textit{GameBoard})}} 
\end{ex} 
Here we use \textit{GameBoard} as the type of types which are a
subtype of \textit{InfoState} (as defined in Appendix~\ref{app:infostate}), that is, a gameboard is a type of
information states.  Formally, this is expressed as in \nexteg{}.
\begin{ex} 
$T$ : \textit{GameBoard} iff $T\sqsubseteq$ \textit{InfoState}
\label{ex:GameBoard}
\end{ex} 

  
An example of a type corresponding to long term memory is given in
\nexteg{}.
\begin{ex} 
\smallrecord{\smalltfield{id$_0$}{\textit{Rec}}\\
             \smalltfield{id$_1$}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                               \smalltfield{e}{named(x,
                                                 ``Dudamel'')}}}\\ 
             \smalltfield{id$_2$}{\smallrecord{\smalltfield{e}{conductor(id$_1$.x)}}}\\
             \smalltfield{id$_3$}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                               \smalltfield{e}{named(x,
                                                 ``Beethoven'')}}}\\
             \smalltfield{id$_4$}{\smallrecord{\smalltfield{e}{composer(id$_3$.x)}}}\\
             \smalltfield{id$_5$}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                               \smalltfield{e}{named(x,
                                                 ``Uchida'')}}}\\
             \smalltfield{id$_6$}{\smallrecord{\smalltfield{x}{pianist(id$_5$.x)}}}\\
             \smalltfield{id$_7$}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                               \smalltfield{e}{named(x,
                                                 ``Sam'')}}}\\
             \smalltfield{id$_8$}{\smallrecord{\smalltfield{e}{singer(id$_7$.x)}}}}
\label{ex:ltm} 
\end{ex} 
\preveg{} is one way of putting the information in shared commitments represented by
(\ref{ex:nonflatsharedcomms}) into a type corresponding to long term
memory.  We are assuming that in long term memory information is
indexed by unique identifiers modelled here by the labels `id$_n$' (of
which we assume there is a countably infinite stock, one for each
natural number, $n$).  It is important that in long term memory paths
are persistent under updating, that is, the old paths do not change
when we add information to long term memory.  This is in contrast to
the kind of updating we proposed for the gameboard, adding the label
`prev' to the path for the old gameboard.  This meant that all labels
within the old gameboard were adjusted.  When we link from the
gameboard to long term memory we want to make sure that the link uses
a persistent path which will still be correct if the long term memory
should get updated.  When long term memory is updated we prefix the
path to the new information with 
the identifier `id$_{i+1}$', where $i$ is the highest index on an
`id'-label in the long term memory type we are updating.  (This is the
same technique we used for `e'-labels in our treatment of chart parsing
in Chapter~\ref{ch:gram}.) The way of achieving the link is
illustrated schematically in \nexteg{} where we use $M$ to represent
the long term memory \preveg{} and leave out all irrelevant details of
the gameboard.
\begin{ex} 
\smallrecord{\smallmfield{ltm}{$M$}{\textit{RecType}}\\
        \smallmfield{gb}{$\lambda r$:ltm . \smallrecord{\ldots\\
                                              \smalltfield{shared}{\smallrecord{\smallmfield{commitments}{\smallrecord{\ldots\\
                                                                                                   \smalltfield{e}{leave($r$.id$_7$.x)}\\
                                                                                                   \ldots}}{\textit{RecType}}}}\\
                                              \ldots}}{(ltm$\rightarrow$\textit{RecType})}}
\label{ex:tisSamLeaves}
\end{ex} 
The intuition expressed in \preveg{} is as follows:  given a
situation, $r$,
of the type represented by our long term memory, that is one in which
a particular individual is labelled by `id$_7$.x', the gameboard will
be a type of information state where the shared commitments require that
$r$.id$_7$.x leaves.  Two agents are aligned in their shared
commitments to the extent that we can find an equivalence between the
two types which represent their respective view of the shared
commitments obtained by applying their respective functions labelled `gb' to a
situation of their respective memory types. 

The link represented by the dependence on the long term memory type corresponds
to what \cite{Kamp1990,KampGenabithReyle2011} call an internal
anchor.  We are representing here how individual roles in an agent's
view of shared commitments can be anchored in that agent's long term
memory.  In a more complete treatment we could in addition make the
gameboard depend on a type for the current visual scene and also types
for other sensory input.  Our use of dependent types and Kamp
\textit{et al.}'s use of internal anchors allow us to link different
components of cognitive structure.  Cognitive structure can also be
linked to objects in the external world, giving rise to what Kamp
\textit{et al.} call external anchors.  Our manifest fields can be
used to correspond to their external anchors.  Suppose, for example,
that we have an individual `sam' who is named Sam.  We can use a
manifest field to restrict the long term memory type (\ref{ex:ltm}) so that any record
(``situation'') of that type has `sam' in the `id$_7$.x'-field.  This
is represented in \nexteg{} where for convenience we have omitted all but the
`id$_7$'-field in (\ref{ex:ltm}).
\begin{ex} 
\smallrecord{\ldots\\
             \smallmfield{id$_7$}{sam}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                               \smalltfield{e}{named(x,
                                                 ``Sam'')}}}\\
             \ldots}
\end{ex} 
If $M$ in (\ref{ex:tisSamLeaves}) is the type \preveg{} then for any
$r:M$, it will be the case that $r$.id$_7$.x will be `sam'.  Thus the
shared commitment is that `sam' leaves.  Given that manifest fields
can occur in any record type, this kind of external anchoring is not
restricted to long term memory but could also be directly in the
gameboard if that is desired. 

Let us now consider how the update of a gameboard dependent on long
term memory can be carried out when there is a match between the
parametric content used for updating and an item in long term memory.
Suppose that the current total information state, $\iota_{\mathrm{curr}}$, is of the type in \nexteg{}
\begin{ex} 
\record{\tfield{ltm}{\textit{RecType}}\\
        \mfield{gb}{$\lambda r$:ltm . $T_{\mathrm{gb}}(r)$}{(ltm$\rightarrow$\textit{RecType})}}
\end{ex} 
and that we wish to update this with the function, a
parametric content, $f$, given in \nexteg{} (where
$T_{\mathrm{bg}}\sqsubseteq$ \smallrecord{\smalltfield{x}{\textit{Ind}}}).
\begin{ex} 
$\lambda r$:$T_{\mathrm{bg}}$ . $T_{\mathrm{upd}}(r)$ 
\end{ex} 
In order to find a match between $T_{\mathrm{bg}}$ and $\iota_{\mathrm{curr}}$.ltm
(that is, to ascertain that the presupposition associated with the
parametric content is met by the long term memory of the current total
information state) we need to find a relabelling, $\eta$, of the flattened
version of $T_{\mathrm{bg}}$, $\varphi(T_{\mathrm{bg}})$, such that
\nexteg{} holds.
\begin{ex} 
$\varphi$($\iota_{\mathrm{curr}}$.ltm) $\sqsubseteq$ $[\varphi(T_{\mathrm{bg}})]_\eta$ 
\end{ex} 
Then we can derive \nexteg{} as a type of the updated total
information state.
\begin{ex} 
\smallrecord{\smalltfield{ltm}{\textit{RecType}}\\
        \smallmfield{gb}{$\lambda r$:ltm
          . ($T_{\mathrm{gb}}(r)$\fbox{\d{$\wedge$}}\\\hspace*{5em}\smallrecord{\smalltfield{shared}{\smallrecord{\smallmfield{commitments}{\smallrecord{\smalltfield{prev}{$\iota_{\mathrm{curr}}$.gb.shared.commitments}\\
                                                                                                                           \smalltfield{bg}{$T_{\mathrm{bg}}$\d{$\wedge$}\smallrecord{\smallmfield{x}{$\iota_{\mathrm{curr}}$.ltm.$\eta$(x)}{\textit{Ind}}}}\\
                                                                                                                           \smalltfield{e}{$f$(bg)}}}{\textit{RecType}}}}})\\\hspace*{25em}}{(ltm$\rightarrow$\textit{RecType})}}

 
\end{ex} 
We can now put all this together as the update function in \nexteg{},
which we call \textbf{AccLTM}($\eta$) (``accommodate match with long term memory'').
\begin{ex}
\textbf{AccLTM}($\eta$) =\\ 
$\lambda r$:\record{\tfield{ltm}{\textit{RecType}}\\
        \tfield{gb}{(ltm$\rightarrow$\textit{GameBoard})}}\\
\hspace*{1em}$\lambda
f$:$\displaystyle{\bigvee_{T\sqsubseteq [\mathrm{x}:\mathit{Ind}]}}(T\rightarrow \mathit{RecType})$ . \\
\hspace*{2em} \smallrecord{\smalltfield{ltm}{\textit{RecType}}\\
        \smallmfield{gb}{$\lambda r_1$:ltm
          . (($r$.gb)($r_1$)\fbox{\d{$\wedge$}}\\\hspace*{5em}\smallrecord{\smalltfield{shared}{\smallrecord{\smallmfield{commitments}{\smallrecord{\smalltfield{prev}{($r$.gb)($\Uparrow^3$ltm).shared.commitments}}\d{$\wedge$}$\mathcal{B}(f)$\d{$\wedge$}\\
\hspace{10em}\smallrecord{\smalltfield{bg}{\smallrecord{\smallmfield{x}{$r$.ltm.$\eta$(x)}{\textit{Ind}}}}}}{\textit{RecType}}}}})\\\hspace*{25em}}{(ltm$\rightarrow$\textit{GameBoard})}}
\end{ex} 
Here \textit{GameBoard} is as defined in (\ref{ex:GameBoard}).
     
We have used accommodation from long term memory to represent the kind
of accommodation where the agent has a resource which provides a
match.  In a more complete treatment we could use this technique for
accommodation from other available resources such as the visual scene.
We now turn our attention to accommodation where there is no
appropriate match
with other resources.  This corresponds to the case where the hearer
does not know any appropriate person named Sam but merely adds that
there is a person named Sam to the shared dialogue commitments.

The first step in this update is to create a type from the parametric
content under consideration so that we can merge it with
\smallrecord{\smalltfield{prev}{$T$}}, where $T$ is the type
representing the current shared commitments.  The type we create is
one where the domain type of the function which is the parametric
content is embedded under the label `bg' (for ``background'') and the
result is merged with the type which the function returns,
appropriately relabelled.  In \nexteg{a} we repeat the parametric
content given in (\ref{ex:parcontfixedpoint}) and in \nexteg{b} we
give the corresponding backgrounding type. 
\begin{ex} 
\begin{subex} 
 
\item $\lambda
  r_1$:\smallrecord{\smalltfield{f}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                               \smalltfield{e}{named(x,
                                                 ``Sam'')}}}\\
                  \smalltfield{a}{\textit{Rec}}} . 
%\hspace*{2em}
\smallrecord{\smalltfield{e}{leave($r_1$.f.x)}} 
 
\item \smallrecord{\smalltfield{bg}{\smallrecord{\smalltfield{f}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                               \smalltfield{e}{named(x,
                                                 ``Sam'')}}}\\
                                                 \smalltfield{a}{\textit{Rec}}}} \\
                  \smalltfield{e}{leave(bg.f.x)}} 
 
\end{subex} 
   
\end{ex}
An explicit definition of how to obtain the backgrounding type, $\mathcal{B}(f)$, from
a function, $f$, is given in Appendix~\ref{app:comptypes},
p.~\pageref{pg:backgroundingtype}. Suppose now that the current shared
commitments are given by the type in \nexteg{}.
\begin{ex} 
\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\textit{Rec}}\\
                                                                             \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                                                           \smalltfield{e}{named(x, ``Dudamel'')}}}\\
                                                                              \smalltfield{e}{conductor(bg.x)}}}
                                                                   \\
                                              \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                            \smalltfield{e}{named(x, ``Beethoven'')}}}\\
                                              \smalltfield{e}{composer(bg.x)}}}
                                   \\
              \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                            \smalltfield{e}{named(x, ``Uchida'')}}}\\
              \smalltfield{e}{pianist(bg.x)}}
       
\end{ex} 
Then the new shared commitments will be \nexteg{a} which is
\nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item  \smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\textit{Rec}}\\
                                                                             \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                                                           \smalltfield{e}{named(x, ``Dudamel'')}}}\\
                                                                              \smalltfield{e}{conductor(bg.x)}}}
                                                                   \\
                                              \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                            \smalltfield{e}{named(x, ``Beethoven'')}}}\\
                                              \smalltfield{e}{composer(bg.x)}}}
                                   \\
              \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                            \smalltfield{e}{named(x, ``Uchida'')}}}\\
              \smalltfield{e}{pianist(bg.x)}}}} \d{$\wedge$} \smallrecord{\smalltfield{bg}{\smallrecord{\smalltfield{f}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                               \smalltfield{e}{named(x,
                                                 ``Sam'')}}}\\
                                                 \smalltfield{a}{\textit{Rec}}}} \\
                  \smalltfield{e}{leave(bg.f.x)}}
 
\item \smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\smallrecord{\smalltfield{prev}{\textit{Rec}}\\
                                                                             \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                                                           \smalltfield{e}{named(x, ``Dudamel'')}}}\\
                                                                              \smalltfield{e}{conductor(bg.x)}}}
                                                                   \\
                                              \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                            \smalltfield{e}{named(x, ``Beethoven'')}}}\\
                                              \smalltfield{e}{composer(bg.x)}}}
                                   \\
              \smalltfield{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                            \smalltfield{e}{named(x, ``Uchida'')}}}\\
              \smalltfield{e}{pianist(bg.x)}}}\\
\smalltfield{bg}{\smallrecord{\smalltfield{f}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                               \smalltfield{e}{named(x,
                                                 ``Sam'')}}}\\
                                                 \smalltfield{a}{\textit{Rec}}}} \\
                  \smalltfield{e}{leave(bg.f.x)}} 
 
\end{subex} 
   
\end{ex} 
We can now put this together as the update function in \nexteg{},
which we call \textbf{AccNM} (``accommodate no match'').
\begin{ex}
\textbf{AccNM} =\\ 
$\lambda r$:\record{\tfield{ltm}{\textit{RecType}}\\
                    \tfield{gb}{(ltm$\rightarrow$\textit{GameBoard})}}\\
\hspace*{1em}$\lambda
f$:$\displaystyle{\bigvee_{T\sqsubseteq [\mathrm{x}:\mathit{Ind}]}}(T\rightarrow \mathit{RecType})$ . \\
\hspace*{2em} \smallrecord{\smallmfield{ltm}{$r$.ltm}{\textit{RecType}}\\
                           \smallmfield{gb}{$\lambda r_1$:ltm
          . (($r$.gb)($r_1$)\fbox{\d{$\wedge$}}\\\hspace*{5em}\smallrecord{\smalltfield{shared}{\smallrecord{\smallmfield{commitments}{\smallrecord{\smalltfield{prev}{($r$.gb)($\Uparrow^3$ltm).shared.commitments}}\d{$\wedge$}$\mathcal{B}(f)$}{\textit{RecType}}}}})\\\hspace*{25em}}{(ltm$\rightarrow$\textit{GameBoard})}}
\end{ex}

We can now accommodate the first case we discussed where there was a
match on the gameboard into the general format of update functions for
total information states.  Assuming that we have relabellings $\eta$ and $\eta'$
as defined on p.~\pageref{pg:etaprime} we can formulate the update
function in \nexteg{}, which we call \textbf{AccGB}($\eta'$)
(``accommodate match on gameboard'').

\scalebox{.9}
{\begin{ex}
\textbf{AccGB}($\eta'$) =\\ 
\hspace*{-1em}$\lambda r$:\record{\tfield{ltm}{\textit{RecType}}\\
                    \tfield{gb}{(ltm$\rightarrow$\textit{GameBoard})}}\\
\hspace*{-.7em}$\lambda
f$:$\displaystyle{\bigvee_{T\sqsubseteq [\mathrm{x}:\mathit{Ind}]}}(T\rightarrow \mathit{RecType})$ . \\
\hspace*{-.6em} \smallrecord{\smallmfield{ltm}{$r$.ltm}{\textit{RecType}}\\
                           \smallmfield{gb}{$\lambda r_1$:ltm
          . (($r$.gb)($r_1$)\fbox{\d{$\wedge$}}\\\hspace*{5em}\smallrecord{\smalltfield{shared}{\smallrecord{\smallmfield{commitments}{$\varphi^-$($\varphi$(\smallrecord{\smalltfield{prev}{($r$.gb)($\Uparrow^3$ltm).shared.commitments}})\d{$\wedge$}$[\varphi(\mathcal{F}(f))]_{\eta'}$)\\\hspace*{25em}}{\textit{RecType}}}}})\\\hspace*{25em}}{(ltm$\rightarrow$\textit{GameBoard})}}

\end{ex}}

The three update functions for accommodation that we have defined are
governed by the single licensing condition given in \nexteg{}.
\begin{ex} 
If $A$ is an agent, $s_i$ is $A$'s current information state, $f$ is a
parametric content of type $(T_1\rightarrow T_2)$ and
$s_i:_A T_i$ for some $T_i$ such that 
\begin{quote}
$T_i$ $\sqsubseteq$ \smallrecord{\smalltfield{ltm}{\textit{RecType}}\\
                                 \smalltfield{gb}{\smallrecord{\smalltfield{shared}{\smallrecord{\smalltfield{commitments}{\textit{RecType}}\\
                                                                                                 \smalltfield{latest-move}{\smallrecord{\smallmfield{cont}{$f$}{$(T_1\rightarrow T_2)$}}}}}}}}
\end{quote}
then \\
\begin{quote}
if there is some $\eta$ which is a labelling for $T_1$ such that 
\begin{quote}
$[T_1]_\eta$ $\sqsubseteq$ $s_i$.gb.shared.commitments
\end{quote}
and there is some $\eta'$ which is a labelling of $\mathcal{F}(f)$ such that $\eta'$ is an extension of
$\eta$,\\[.25\baselineskip]  
then $s_{i+1} :_A
T_i$\fbox{\d{$\wedge$}}\textbf{AccGB}($\eta'$)($s_i$)($f$) is
licensed\\[\baselineskip]
else if there is some $\eta$ which is a labelling for $T_1$, $[T_1]_\eta$
$\sqsubseteq$ $s_i$.ltm\\[.25\baselineskip]
then $s_{i+1} :_A
T_i$\fbox{\d{$\wedge$}}\textbf{AccLTM}($\eta$)($s_i$)($f$) is
licensed\\[\baselineskip] 
else $s_{i+1} :_A
T_i$\fbox{\d{$\wedge$}}\textbf{AccNM}($s_i$)($f$) is
licensed
\end{quote} 
\end{ex} 
     

  @@ [Split into parts.  Paderewski]

\subsection{Common nouns and frames}

\subsection{Definite descriptions}

\subsection{Indefinite descriptions}

\subsection{Generalized quantifiers}

\subsection{Conjunctions and disjunctions}

\subsection{Plurality}

\newpage

\section{Verbal constructions}

\subsection{Intransitive verbs}

\subsection{Transitive verbs}

\subsection{Intensional verbs}

\subsection{Verbs expressing propositional attitudes}

\subsection{Verbs expressing attitudes to properties}

\subsection{Conjunction and disjunction}

\subsection{Negation}

\subsection{Tense and aspect}

\section{Adverbial constructions}

\subsection{Verb phrase adverbs}

\subsection{Intensional adverbs}

\subsection{Modal adverbs}

\subsection{Prepositional phrases}

\newpage

\section{Long distance dependencies}

\subsection{Relative clauses}

\subsection{\textit{wh}-questions}

\subsection{Quantifier scope ambiguities}

\section{Sentential phenomena}

\subsection{Conjunction and disjunction}

\subsection{Polar Questions}

\subsection{Imperatives}

\section{Anaphora}

\subsection{Intrasentential anaphora}

\subsection{Intersentential anaphora}

\subsection{Anaphora in dialogue}

\section*{Scrap}

In this section we will recreate part of Montague's PTQ fragment using the
kind of type system we used for the interpretation of intensional
logic.  We will concentrate our attention on the semantics of
verbs.\footnote{For more general discussion of the application of TTR to
  semantics see, for example, \cite{Cooper2005a,Fernandez2006,Ginzburgforthcoming}.}  In order to
do this we will introduce a basic type \textit{Str} (for strings of
English words which we will use as an imprecise representation of
phonology) and a basic type \textit{Cat} to which will belong the
syntactic categories that Montague uses.  Montague's categories
are defined as follows:
\begin{quote}
e:\textit{Cat} \\
t:\textit{Cat} \\
if $A$:\textit{Cat} and $B$:\textit{Cat} then $A/B$:\textit{Cat} and
$A//B$:\textit{Cat}

Like Montague, we use the following abbreviations for categories:\\
IV, ``intransitive verb phrases'' is to be t/e \\
T, ``term (or noun) phrases'' is to be t/IV \\
TV, ``transitive verb phrases'' is to be IV/T \\
% IAV, ``IV-modifying adverbs'' is to be IV/IV \\
CN, ``common noun phrases'' is to be t//e
\end{quote}
We will present our grammar in terms of signs (in a similar sense to
HPSG, see, for example, \cite{Sag:Wasow:ea:03}).  Our signs will be
records of a type
\begin{display}
\record{\tfield{s-event}{\textit{SEvent}}
                               \\
        \tfield{synsem}{\record{\tfield{cat}{\textit{Cat}}\\
                                \tfield{cnt}{\textit{Seq}$_{\mathit{Ind}}\rightarrow
                                  T$}}}}
\end{display}
where \textit{SEvent} is the type 
\begin{quote}
\record{\tfield{phon}{\textit{Str}}\\
                                 \tfield{s-time}{\record{\tfield{start}{\textit{Time}}
                                     \\
                                                         \tfield{end}{\textit{Time}}}}\\
                                 \tfield{utt$_\mathrm{at}$}{$\langle
                                   \lambda v_1:$\textit{Str}$(\lambda
                                   v_2:$\textit{Time}($\lambda
                                   v_3:$\textit{Time}(uttered\_at($v_1$,$v_2$,$v_3$)))), \\
                                   & &
                                   \hspace*{2em}$\langle$s-event.phon,
                                   s-event.s-time.start,
                                   s-event.s-time.end$\rangle\rangle$}}
\end{quote}
and \textit{Seq}$_{\mathit{Ind}}$ is an abbreviation for the type
\textit{Nat}$\rightarrow$\textit{Ind}, that is the type of sequences
of individuals, and $T$ is \smallrecord{\smalltfield{x}{\textit{Ind}}},
\textit{RecType} or a function type constructed from these. 
A sign 
has two main components, one corresponding to the physical nature of
the speech event (`s-event') and the other to its interpretation
(syntax and semantics, `synsem', using the label which is
well-established in HPSG).   In the s-event component the
phon-field represents the phonology of an expression, here represented
as a string of words although in a complete treatment of spoken
language we would need phonological and phonetic attributes.  The
s-time (``speech time'') field represents the starting and ending time
for the utterance.  We assume the existence of a predicate
`uttered\_at' with arity
$\langle\mathit{Str},\mathit{Time},\mathit{Time}\rangle$.  An object of type
`uttered\_at($a$,$t_1$,$t_2$)' could be an event where $a$ is uttered
beginning at $t_1$ and ending at $t_2$ or a corresponding hypothesis
produced by a speech recognizer with time-stamps, depending on the application of the
theory.  In a more complete treatment we would need additional
information about the physical nature of the speech event, such as the
identity of the speaker and where it took place.  

In the synsem component
the cat-field introduces Montague's category for the phrase.  This
could, and probably should, be replaced by categories more familiar to
linguists as has been done in many applications of Montague's
semantics.  But nothing is at stake in this matter for the purposes of
this paper and there are a number of alternatives in the linguistic
literature to choose from.
The cnt-field represents the content or interpretation of the
utterance.  It could be represented in terms of intensional logic with a
similar interpretation to that we presented above.  However, it is
more perspicuous to represent the content directly in terms of TTR.
Since the content types become rather long we will introduce
abbreviations to make them readable:
\begin{quote}
\textit{Prop}, ``property'' is to be
\smallrecord{\smalltfield{x}{\textit{Ind}}}$\rightarrow$\textit{RecType}
  \\
\textit{Quant}, ``quantifier'' is to be
\textit{Prop}$\rightarrow$\textit{RecType} \\
if $T$ is a type then $^\sigma T$ is to be
\textit{Seq}$_{\mathit{Ind}}\rightarrow T$ 
\end{quote}
We only use a small finite number of function types for content
types and thus we are able to define a type \textit{CntType} which is
\begin{quote}
\ignore{\smallrecord{\smalltfield{x}{\textit{Ind}}} $\vee$\\(}$^\sigma$\textit{RecType}
$\vee$\\($^\sigma$\textit{Prop} $\vee$\\($^\sigma$\textit{Quant}
%$\vee$\\($^\sigma$(\textit{Prop}$\rightarrow$\textit{Prop})
$\vee$\\($^\sigma$(\textit{Quant}$\rightarrow$\textit{Prop})
$\vee$\\($^\sigma$(\textit{RecType}$\rightarrow$\textit{Prop})
$\vee$\\($^\sigma$(\textit{Prop}$\rightarrow$\textit{Quant}) 
%$\vee$\\$^\sigma$(\textit{Quant}$\rightarrow$(\textit{Prop}$\rightarrow$\textit{Prop}))
)))))\ignore{))}
\end{quote}
This means that we can define \textit{Sign}, the type of signs, to be
\begin{display}
\record{\tfield{s-event}{\record{\tfield{phon}{\textit{Str}}\\
                                 \tfield{s-time}{\record{\tfield{start}{\textit{Time}}
                                     \\
                                                         \tfield{end}{\textit{Time}}}}\\
                                 \tfield{utt$_\mathrm{at}$}{$\langle
                                   \lambda v_1:$\textit{Str}$(\lambda
                                   v_2:$\textit{Time}($\lambda
                                   v_3:$\textit{Time}(uttered\_at($v_1$,$v_2$,$v_3$)))), \\
                                   & &
                                   \hspace*{2em}$\langle$s-event.phon,
                                   s-event.s-time.start, s-event.s-time.end$\rangle\rangle$}}}
                               \\
        \tfield{synsem}{\record{\tfield{cat}{\textit{Cat}}\\
                                \tfield{cnt}{\textit{CntType}}}}}

\end{display}

We will present first the lexicon and then rules for
combining phrases.  We shall use the following notations:
\begin{quote}
If $s$ is a string, then c$_s$ is a distinguished label associated
with $s$, such that if $s\not=s'$ then c$_s$$\not=$c$_s'$.

If $s$ is a string then $s'_{\mathit{Arity}}$ is a predicate of arity
$\mathit{Arity}$.  When $\mathit{Arity}$ is clear from the context we
suppress it.

If $s$ is a string then $s'_T$ is an object of type $T$.  When it is
clear from the context we often suppress $T$.

% necessarily$'_{\langle\mathit{RecType}\rangle}$ is to be the predicate
% `nec'.

\end{quote}


\subsection{Lexicon}
\ignore{Let $\sigma$ be a function from TTR-types, $T$, such that $\sigma_T$
(the result of applying $\sigma$ to $T$) is a countably infinite
sequence of objects of type $T$.  We will call $\sigma$ a
\textit{family of typed sequences}.}  We will use sequences of
individuals as an
apparatus to treat pronouns and binding in the interpretations given
in content fields.  In the lexicon all contents except for pronoun
contents are constant functions defined on these sequences.  We will present a series of lexical functions which map strings and
occasionally additional arguments record types for signs.  

We will use a number of auxiliary types in the definition of our
lexical classes:
\begin{enumerate}

\renewcommand{\labelenumi}{LTy\arabic{enumi}.} 
 
\item the gender type, \textit{Gen}, such that $a$:\textit{Gen}
  iff $a$ is m, f or n (masculine, feminine or neuter). 
 
\item the number type, \textit{Num}, such that $a$:\textit{Num} iff
  $a$ is sg or pl (singular or plural).

\item the person type, \textit{Pers}, such that $a$:\textit{Pers} iff
  $a$ is 1st, 2nd or 3rd (first, second or third person)

\item we use \textit{Agr} to represent the type
\begin{display}
\record{\tfield{gen}{\textit{Gen}} \\
        \tfield{num}{\textit{Num}} \\
        \tfield{pers}{\textit{Pers}}}
\end{display}

\item we use \textit{MascSg3rd} to represent the type
\begin{display}
\record{\tfield{synsem}{\record{\tfield{agr}{\record{\mfield{gen}{m}{\textit{Gen}} \\
                                             \mfield{num}{sg}{\textit{Num}} \\
                                             \mfield{pers}{3rd}{\textit{Pers}}}}}}}
\end{display}

\item we use \textit{FemSg3rd} to represent the type
\begin{display}
\record{\tfield{synsem}{\record{\tfield{agr}{\record{\mfield{gen}{f}{\textit{Gen}} \\
                                             \mfield{num}{sg}{\textit{Num}} \\
                                             \mfield{pers}{3rd}{\textit{Pers}}}}}}}
\end{display}

\item we use \textit{NeutSg3rd} to represent the type
\begin{display}
\record{\tfield{synsem}{\record{\tfield{agr}{\record{\mfield{gen}{n}{\textit{Gen}} \\
                                             \mfield{num}{sg}{\textit{Num}} \\
                                             \mfield{pers}{3rd}{\textit{Pers}}}}}}}
\end{display}

\item we use \textit{Sg3rd} to represent the type
\begin{display}
\record{\tfield{synsem}{\record{\tfield{agr}{\record{\tfield{gen}{\textit{Gen}} \\
                                             \mfield{num}{sg}{\textit{Num}} \\
                                             \mfield{pers}{3rd}{\textit{Pers}}}}}}}
\end{display}

 
\end{enumerate} 
  

\subsubsection{Intransitive verbs}\label{pg:lexicon-iv}
We define a function lex$_\mathrm{IV}$ for intransitive verbs like
\textit{run} which predicate directly of individuals such that
lex$_\mathrm{IV}$($s$) is
\begin{quote}
\hspace*{-2em}\textit{Sign} \d{$\wedge$} \\
\hspace*{-2em}\record{\tfield{s-event}{\record{\mfield{phon}{$s$}{\textit{Str}}}} \\
        \tfield{synsem}{\record{\mfield{cat}{IV}{\textit{Cat}} \\
                                \mfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}($\lambda
                                  r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
                                  (\smallrecord{\smalltfield{e-time}{\textit{Time}}
                                    \\
                                           \smalltfield{c$_s$}{$\langle\lambda
                                             v$:\textit{Time}($s'$($r$.x,$v$)), $\langle$e-time$\rangle\rangle$}}))}{$^\sigma$\textit{Prop}}}}}

\end{quote}
We define a function lex$_{\mathrm{IV}\textrm{-}\mathrm{fr}}$ for intransitive verbs like
\textit{rise} which correspond to predicates of frames such that
lex$_{\mathrm{IV}\textrm{-}\mathrm{fr}}$($s$) is
\begin{quote}
\hspace*{-2em}\textit{Sign} \d{$\wedge$} \\
\hspace*{-2em}\record{\tfield{s-event}{\record{\mfield{phon}{$s$}{\textit{Str}}}} \\
        \tfield{synsem}{\record{\mfield{cat}{IV}{\textit{Cat}} \\
                                \mfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}($\lambda
                                  r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
                                  (\smallrecord{\smalltfield{e-time}{\textit{Time}}
                                    \\
                                           \smalltfield{c$_s$}{$\langle\lambda
                                             v$:\textit{Time}($s'$($r$,$v$)), $\langle$e-time$\rangle\rangle$}}))}{$^\sigma$\textit{Prop}}}}}

\end{quote}

We define the set of lexical types of category IV,
B$_{\mathrm{IV}}$, to be
\begin{quote}
\begin{tabbing}
\{\=lex$_{\mathrm{IV}}$(``run''), \\
  \>lex$_{\mathrm{IV}}$(``walk''), \\
  \>lex$_{\mathrm{IV}}$(``talk''), \\
  \>lex$_{\mathrm{IV}\textrm{-}\mathrm{fr}}$(``rise''), \\
  \>lex$_{\mathrm{IV}\textrm{-}\mathrm{fr}}$(``change'')\}
\end{tabbing}
\end{quote}

\subsubsection{Basic terms (proper names and pronouns)}
We define a function lex$_{\mathrm{T}\textrm{-}\mathrm{PN}}$ for
proper names like
\textit{John} such that
lex$_{\mathrm{T}\textrm{-}\mathrm{PN}}$($s$) is
\begin{quote}
\textit{Sign} \d{$\wedge$} \\
\record{\tfield{s-event}{\record{\mfield{phon}{$s$}{\textit{Str}}}} \\
        \tfield{synsem}{\record{\mfield{cat}{T}{\textit{Cat}} \\
                                \mfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}($\lambda
                                  v$:\textit{Prop}($v$(\smallrecord{\field{x}{$s'_{\mathit{Ind}}$}})))}{$^\sigma$\textit{Quant}}}}}
\end{quote}
We define a function lex$_{\mathrm{T}\textrm{-}\mathrm{Pron}}$ for
pronouns like
\textit{he} such that
lex$_{\mathrm{T}\textrm{-}\mathrm{Pron}}$($s,n$) is
\begin{quote}
\textit{Sign} \d{$\wedge$} \\
\record{\tfield{s-event}{\record{\mfield{phon}{$s$}{\textit{Str}}}} \\
        \tfield{synsem}{\record{\mfield{cat}{T}{\textit{Cat}} \\
                                \mfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}($\lambda
                                  v$:\textit{Prop}($v$(\smallrecord{\field{x}{$\sigma_n$}})))}{\textit{$^\sigma$Quant}}}}}
\end{quote}

We define the set of lexical types of category T,
B$_{\mathrm{T}}$, to be
\begin{quote}
\begin{tabbing}
\{\=lex$_{\mathrm{T}\textrm{-}\mathrm{PN}}$(``John'')\d{$\wedge$}MascSg3rd, \\
  \>lex$_{\mathrm{T}\textrm{-}\mathrm{PN}}$(``Mary'')\d{$\wedge$}FemSg3rd, \\
  \>lex$_{\mathrm{T}\textrm{-}\mathrm{PN}}$(``Bill'')\d{$\wedge$}MascSg3rd, \\
  \>lex$_{\mathrm{T}\textrm{-}\mathrm{PN}}$(``ninety'')\d{$\wedge$}NeutSg3rd\} \\
$\cup$
\{lex$_{\mathrm{T}\textrm{-}\mathrm{Pron}}$(``he'', $3n+2$)\d{$\wedge$}MascSg3rd $\mid$ $n \in
\mathit{Nat}$\} \\
$\cup$
\{lex$_{\mathrm{T}\textrm{-}\mathrm{Pron}}$(``she'', $3n+3$)\d{$\wedge$}FemSg3rd $\mid$ $n \in
\mathit{Nat}$\} \\
$\cup$
\{lex$_{\mathrm{T}\textrm{-}\mathrm{Pron}}$(``it'', $3n+4$)\d{$\wedge$}NeutSg3rd\} $\mid$ $n \in
\mathit{Nat}$\}
\end{tabbing}
\end{quote}

\subsubsection{Transitive verbs}
We define a function lex$_\mathrm{TV}$ for extensional transitive verbs like
\textit{find} and \textit{be} such that
lex$_\mathrm{TV}$($s$) is
\begin{quote}
\hspace*{-3em}\textit{Sign} \d{$\wedge$} \\
\hspace*{-3em}\record{\tfield{s-event}{\record{\mfield{phon}{$s$}{\textit{Str}}}} \\
        \tfield{synsem}{\smallrecord{\smallmfield{cat}{TV}{\textit{Cat}} \\
                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}(
$\lambda v_1$:\textit{Quant} \\
\hspace*{4em}($\lambda v_2$:\smallrecord{\smalltfield{x}{\textit{Ind}}} \\
\hspace*{5em}($v_1$($\lambda v_3$:\smallrecord{\smalltfield{x}{\textit{Ind}}} \\
 \hspace*{7em}                                 (\smallrecord{\smalltfield{e-time}{\textit{Time}}
                                    \\
                                           \smalltfield{c$_s$}{$\langle\lambda
                                             v$:\textit{Time}($s'$($v_2$.x,$v_3$.x,$v$)),
                                             $\langle$e-time$\rangle\rangle$}})))))
}{$^\sigma$(\textit{Quant}$\rightarrow$\textit{Prop})}}}}

\end{quote}

We define a function lex$_{\mathrm{TV}\textrm{-}\mathrm{int}}$ for intensional transitive verbs like
\textit{conceive}\footnote{which at least on Montague's analysis is
  intensional and does not have a decompositional interpretation -- we
  do not take up the issue here of whether Montague's analysis was correct} such that
lex$_{\mathrm{TV}\textrm{-}\mathrm{int}}$($s$) is
\begin{quote}
\hspace*{-4em}\textit{Sign} \d{$\wedge$} \\
\hspace*{-4em}\record{\tfield{s-event}{\record{\mfield{phon}{$s$}{\textit{Str}}}} \\
        \tfield{synsem}{\smallrecord{\smallmfield{cat}{TV}{\textit{Cat}} \\
                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}(
$\lambda v_1$:\textit{Quant} \\
\hspace*{4em}($\lambda v_2$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
\\
\hspace*{5em}(\smallrecord{\smalltfield{e-time}{\textit{Time}} \\
\smalltfield{c$_s$}{$\langle\lambda v$:\textit{Time}\\
\hspace*{3em}($s'$($v_2$.x,$v_1$($\lambda
  v_3$:\smallrecord{\smalltfield{x}{\textit{Ind}}}(\record{})), $v$)),
  $\langle$e-time$\rangle\rangle$}})))}
{$^\sigma$(\textit{Quant}$\rightarrow$\textit{Prop})}}}}

\end{quote} 

We define a function lex$_{\mathrm{TV}\textrm{-}\mathrm{int}\textrm{-}\mathrm{decomp}}$ for intensional transitive verbs like
\textit{seek} such that
lex$_{\mathrm{TV}\textrm{-}\mathrm{int}\textrm{-}\mathrm{decomp}}$($s_1,s_2$) is
\begin{quote}
\hspace*{-12em}\textit{Sign} \d{$\wedge$} \\
\hspace*{-12em}\smallrecord{\smalltfield{s-event}{\record{\mfield{phon}{$s_1$}{\textit{Str}}}} \\
        \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{TV}{\textit{Cat}} \\
                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}(
$\lambda v_1$:\textit{Quant} \\
\hspace*{4em}($\lambda v_2$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
\\
\hspace*{5em}(\smallrecord{\smalltfield{e-time}{\textit{Time}} \\
\smalltfield{c$_{s_1}$}{$\langle\lambda v$:\textit{Time}\\
\hspace*{4em}(${s_1}'$($v_2$.x,$v_1$($\lambda
  v_3$:\smallrecord{\smalltfield{x}{\textit{Ind}}} \\
\hspace*{10em}(\smallrecord{
\smalltfield{e-time}{\textit{Time}} \\
\smalltfield{c$_{s_2}$}{$\langle\lambda
  v:$\textit{Time}(${s_2}'$($v_2$.x,$v_3$.x,$v$)),
  $\langle$e-time$\rangle\rangle$}}), \\ 
\hspace*{6em}$v$)),
  $\langle$e-time$\rangle\rangle$}}))))}
{$^\sigma$(\textit{Quant}$\rightarrow$\textit{Prop})}}}}

\end{quote} 

We define the set of lexical types of category TV,
B$_{\mathrm{TV}}$, to be
\begin{quote}
\begin{tabbing}
\{\=lex$_{\mathrm{TV}}$(``find''), \\
  \>lex$_{\mathrm{TV}}$(``lose''), \\
  \>lex$_{\mathrm{TV}}$(``eat''), \\
  \>lex$_{\mathrm{TV}}$(``love''), \\
  \>lex$_{\mathrm{TV}}$(``date''), \\
  \>lex$_{\mathrm{TV}}$(``be''), \\
  \>lex$_{\mathrm{TV}\textrm{-}\mathrm{int}\textrm{-}\mathrm{decomp}}$(``seek'',
  ``find''), \\
  \>lex$_{\mathrm{TV}\textrm{-}\mathrm{int}}$(``conceive'')\}
\end{tabbing}
\end{quote}

\ignore{
\subsubsection{IV adverbs}
We define a function lex$_{\mathrm{IAV}}$ for IV (verb phrase) adverbs like
\textit{slowly} such that
lex$_{\mathrm{IAV}}$($s$) is
\begin{quote}
\textit{Sign} \d{$\wedge$} \\
\record{\tfield{s-event}{\record{\mfield{phon}{$s$}{\textit{Str}}}} \\
        \tfield{synsem}{\smallrecord{\smallmfield{cat}{IAV}{\textit{Cat}} \\
                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}(
$\lambda v_1$:\textit{Prop} \\
\hspace*{4em}($\lambda v_2$:\smallrecord{\smalltfield{x}{\textit{Ind}}} \\
\hspace*{5em}(\smallrecord{\smalltfield{c$_s$}{$s'$($v_2$.x,$v_1$)}})))}{$^\sigma$(\textit{Prop}$\rightarrow$\textit{Prop})}}}}

\end{quote}

We define the set of lexical types of category IAV,
B$_{\mathrm{IAV}}$, to be\footnote{Montague incorrectly
    classified \textit{allegedly} as a verb-phrase adverb rather than
    a sentence adverb and we do not correct this here.}
\begin{quote}
\begin{tabbing}
\{\=lex$_{\mathrm{IAV}}$(``rapidly''), \\
  \>lex$_{\mathrm{IAV}}$(``slowly''), \\
  \>lex$_{\mathrm{IAV}}$(``voluntarily''), \\
  \>lex$_{\mathrm{IAV}}$(``allegedly'')\}
\end{tabbing}
\end{quote}
}
\subsubsection{Common nouns}
We define a function lex$_{\mathrm{CN}}$ for common nouns like
\textit{fish} \label{pg:lexicon-cn} such that
lex$_{\mathrm{CN}}$($s$) is
\begin{quote}
\textit{Sign} \d{$\wedge$} \\
\record{\tfield{s-event}{\record{\mfield{phon}{$s$}{\textit{Str}}}} \\
        \tfield{synsem}{\smallrecord{\smallmfield{cat}{CN}{\textit{Cat}} \\
                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}($\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}} \\
\hspace*{4em}(\smallrecord{\smalltfield{c$_s$}{$s'$($v$.x)}}))}{$^\sigma$\textit{Prop}}}}}

\end{quote}

We define a function lex$_{\mathrm{CN}\textrm{-}\mathrm{fr}}$ for common nouns like
\textit{temperature} such that
lex$_{\mathrm{CN}\textrm{-}\mathrm{fr}}$($s$) is
\begin{quote}
\textit{Sign} \d{$\wedge$} \\
\record{\tfield{s-event}{\record{\mfield{phon}{$s$}{\textit{Str}}}} \\
        \tfield{synsem}{\smallrecord{\smallmfield{cat}{CN}{\textit{Cat}} \\
                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}($\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}} \\
\hspace*{4em}(\smallrecord{\smalltfield{c$_s$}{$s'$($v$)}}))}{$^\sigma$\textit{Prop}}}}}

\end{quote}

We define the set of lexical types of category CN,
B$_{\mathrm{CN}}$, to be
\begin{quote}
\begin{tabbing}
\{\=lex$_{\mathrm{CN}}$(``man'')\d{$\wedge$}\textit{MascSg3rd}, \\
  \>lex$_{\mathrm{CN}}$(``woman'')\d{$\wedge$}\textit{FemSg3rd}, \\
  \>lex$_{\mathrm{CN}}$(``park'')\d{$\wedge$}\textit{NeutSg3rd}, \\
  \>lex$_{\mathrm{CN}}$(``fish'')\d{$\wedge$}\textit{Sg3rd}, \\
  \>lex$_{\mathrm{CN}}$(``pen'')\d{$\wedge$}\textit{NeutSg3rd}, \\
  \>lex$_{\mathrm{CN}}$(``unicorn'')\d{$\wedge$}\textit{Sg3rd}, \\
  \>lex$_{\mathrm{CN}\textrm{-}\mathrm{fr}}$(``price'')\d{$\wedge$}\textit{NeutSg3rd}, \\
  \>lex$_{\mathrm{CN}\textrm{-}\mathrm{fr}}$(``temperature'')\d{$\wedge$}\textit{NeutSg3rd}\}
\end{tabbing}
\end{quote}

\ignore{
\subsubsection{Sentence adverbs}
We define a function lex$_{\mathrm{t/t}}$ for sentence adverbs like
\textit{necessarily} such that
lex$_{\mathrm{t/t}}$($s$) is
\begin{quote}
\textit{Sign} \d{$\wedge$} \\
\record{\tfield{s-event}{\record{\mfield{phon}{$s$}{\textit{Str}}}} \\
        \tfield{synsem}{\smallrecord{\smallmfield{cat}{t/t}{\textit{Cat}} \\
                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}($\lambda v$:\textit{RecType} \\
\hspace*{4em}(\smallrecord{\smalltfield{c$_s$}{$s'$($v$)}}))}{$^\sigma$(\textit{RecType}$\rightarrow$\textit{RecType})}}}}

\end{quote}


We define the set of lexical types of category t/t,
B$_{\mathrm{t/t}}$, to be
\begin{quote}
\begin{tabbing}
\{\=lex$_{\mathrm{t/t}}$(``necessarily'')\}
\end{tabbing}
\end{quote}

\subsubsection{Prepositions}
We define a function lex$_{\mathrm{IAV/T}}$ for prepositions like
\textit{in} such that
lex$_{\mathrm{IAV/T}}$($s$) is
\begin{quote}
\textit{Sign} \d{$\wedge$} \\
\record{\tfield{s-event}{\record{\mfield{phon}{$s$}{\textit{Str}}}} \\
        \tfield{synsem}{\smallrecord{\smallmfield{cat}{IAV/T}{\textit{Cat}} \\
                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}($\lambda v_1$:\textit{Quant} \\
\hspace*{4em}($\lambda v_2$:\textit{Prop} \\
\hspace*{5em}($\lambda v_3$:\smallrecord{\smalltfield{x}{\textit{Ind}}} \\
\hspace*{6em}($v_1$($\lambda v_4$:\smallrecord{\smalltfield{x}{\textit{Ind}}}\\
\hspace*{7em}(\smallrecord{\smalltfield{c$_s$}{$s'$($v_2(v_3),v_4.\mathrm{x}$)}}))))))}{$^\sigma$(\textit{Quant}$\rightarrow$(\textit{Prop}$\rightarrow$\textit{Prop}))}}}}

\end{quote}


We define the set of lexical types of category IAV/T,
B$_{\mathrm{IAV/T}}$, to be
\begin{quote}
\begin{tabbing}
\{\=lex$_{\mathrm{IAV/T}}$(``in''), \\
  \>lex$_{\mathrm{IAV/T}\textrm{-}\mathrm{Int}}$(``about'')\}
\end{tabbing}
\end{quote}
}

\ignore{
\subsubsection{Verbs with \emph{that}-complements}

We define a function lex$_{\mathrm{IV/t}}$ for verbs which take
\textit{that}-complements like
\textit{believe}  such that
lex$_{\mathrm{IV/t}}$($s$) is
\begin{quote}
\textit{Sign} \d{$\wedge$} \\
\record{\tfield{s-event}{\record{\mfield{phon}{$s$}{\textit{Str}}}} \\
        \tfield{synsem}{\smallrecord{\smallmfield{cat}{IV/t}{\textit{Cat}} \\
                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}($\lambda v_1$:\textit{RecType} \\
\hspace*{4em}($\lambda v_2$:\smallrecord{\smalltfield{x}{\textit{Ind}}} \\
\hspace*{5em}(\smallrecord{\smalltfield{e-time}{\textit{Time}} \\
                           \smalltfield{c$_s$}{$\langle\lambda v$:\textit{Time}($s'$($v_2$.x,$v_1$,$v$)),
                                             $\langle$e-time$\rangle\rangle$}})))
}{$^\sigma$(\textit{RecType}$\rightarrow$\textit{Prop})}}}}

\end{quote}

We define the set of lexical types of category IV/t,
B$_{\mathrm{IV/t}}$, to be
\begin{quote}
\begin{tabbing}
\{\=lex$_{\mathrm{IV/t}}$(``believe''), \\
  \>lex$_{\mathrm{IAV/T}\textrm{-}\mathrm{Int}}$(``assert'')\}
\end{tabbing}
\end{quote}

\subsubsection{Verbs with infinitival complements}

We define a function lex$_{\mathrm{IV//IV}}$ for verbs which take
infinitival complements like
\textit{try}  such that
lex$_{\mathrm{IV//IV}}$($s$) is
\begin{quote}
\textit{Sign} \d{$\wedge$} \\
\record{\tfield{s-event}{\record{\mfield{phon}{$s$}{\textit{Str}}}} \\
        \tfield{synsem}{\smallrecord{\smallmfield{cat}{IV//IV}{\textit{Cat}} \\
                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}($\lambda v_1$:\textit{Prop} \\
\hspace*{4em}($\lambda v_2$:\smallrecord{\smalltfield{x}{\textit{Ind}}} \\
\hspace*{5em}(\smallrecord{\smalltfield{e-time}{\textit{Time}} \\
                           \smalltfield{c$_s$}{$\langle\lambda v$:\textit{Time}($s'$($v_2$.x,$v_1$,$v$)),
                                             $\langle$e-time$\rangle\rangle$}})))
}{$^\sigma$(\textit{Prop}$\rightarrow$\textit{Prop})}}}}

\end{quote}

We define the set of lexical types of category IV//IV,
B$_{\mathrm{IV//IV}}$, to be
\begin{quote}
\begin{tabbing}
\{\=lex$_{\mathrm{IV//IV}}$(``try''), \\
  \>lex$_{\mathrm{IV//IV}}$(``wish'')\}
\end{tabbing}
\end{quote}
}

\subsubsection{Determiners}

We define a function lex$_{\mathrm{T/CN}\textrm{-}\mathrm{ex}}$ for
the indefinite article
\label{pg:lexicon-indefart}
\textit{a}  such that
lex$_{\mathrm{T/CN}\textrm{-}\mathrm{ex}}$($s$) is
\begin{quote}
\textit{Sign} \d{$\wedge$} \\
\record{\tfield{s-event}{\record{\mfield{phon}{$s$}{\textit{Str}}}} \\
        \tfield{synsem}{\smallrecord{\smallmfield{cat}{T/CN}{\textit{Cat}} \\
                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}($\lambda v_1$:\textit{Prop} \\
\hspace*{4em}($\lambda v_2$:\textit{Prop} \\
\hspace*{5em}(\record{\tfield{par}{\smallrecord{\smalltfield{x}{\textit{Ind}}}}
  \\
                      \tfield{restr}{$\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}}($v_1(v)$),
                        $\langle\mathrm{par}\rangle\rangle$} \\
                      \tfield{scope}{$\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}}($v_2(v)$), $\langle\mathrm{par}\rangle\rangle$}})))
}{$^\sigma$(\textit{Prop}$\rightarrow$\textit{Quant})}}}}

\end{quote}


We define a function lex$_{\mathrm{T/CN}\textrm{-}\mathrm{uni}}$ for
the universal determiner
\textit{every}  such that
lex$_{\mathrm{T/CN}\textrm{-}\mathrm{uni}}$($s$) is
\begin{quote}
\hspace*{-4em}\textit{Sign} \d{$\wedge$} \\
\hspace*{-4em}\record{\tfield{s-event}{\record{\mfield{phon}{$s$}{\textit{Str}}}} \\
        \tfield{synsem}{\smallrecord{\smallmfield{cat}{T/CN}{\textit{Cat}} \\
                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}($\lambda v_1$:\textit{Prop} \\
\hspace*{4em}($\lambda v_2$:\textit{Prop} \\
\hspace*{5em}(\smallrecord{\smalltfield{f}{($r$:\smallrecord{\smalltfield{par}{\smallrecord{\smalltfield{x}{\textit{Ind}}}}
  \\
                                              \smalltfield{restr}{$\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}}($v_1(v)$),
                                              $\langle\mathrm{par}\rangle\rangle$}})$\rightarrow
                                          v_2(r.\mathrm{par})$}})))}{$^\sigma$(\textit{Prop}$\rightarrow$\textit{Quant})}}}}

\end{quote}

We define a function lex$_{\mathrm{T/CN}\textrm{-}\mathrm{def}}$ for
the definite article
\textit{the}  such that
lex$_{\mathrm{T/CN}\textrm{-}\mathrm{def}}$($s$) is
\begin{quote}
\hspace*{-12em}\textit{Sign} \d{$\wedge$} \\
\hspace*{-12em}\record{\tfield{s-event}{\record{\mfield{phon}{$s$}{\textit{Str}}}} \\
        \tfield{synsem}{\smallrecord{\smallmfield{cat}{T/CN}{\textit{Cat}} \\
                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}($\lambda v_1$:\textit{Prop} \\
\hspace*{4em}($\lambda v_2$:\textit{Prop} \\
\hspace*{5em}(\smallrecord{\smalltfield{par}{\smallrecord{\smalltfield{x}{\textit{Ind}}}}
  \\
                      \smalltfield{restr}{$\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}}($v_1(v)$\d{$\wedge$}\smallrecord{\smalltfield{f}{($r$:\smallrecord{\smalltfield{par}{\smallrecord{\smalltfield{x}{\textit{Ind}}}}
  \\             \smalltfield{restr}{$\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}}($v_1(v)$),
                                              $\langle\mathrm{par}\rangle\rangle$}})
                                           \\ \hspace*{2em}$\rightarrow$
                                          \smallrecord{\tfield{scope}{eq($v$,$r.\mathrm{par}$)}}}},
                        \\ \hspace*{3em}$\langle\mathrm{par}\rangle\rangle$)} \\
                      \smalltfield{scope}{$\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}}($v_2(v)$), $\langle\mathrm{par}\rangle\rangle$}})))}{$^\sigma$(\textit{Prop}$\rightarrow$\textit{Quant})}}}}

\end{quote}

We define the set of lexical types of category T/CN,
B$_{\mathrm{T/CN}}$, to be
\begin{quote}
\begin{tabbing}
\{\=lex$_{\mathrm{T/CN}\textrm{-}\mathrm{ex}}$(``a''), \\
  \>lex$_{\mathrm{T/CN}\textrm{-}\mathrm{uni}}$(``every''), \\
  \>lex$_{\mathrm{T/CN}\textrm{-}\mathrm{def}}$(``the'')\}
\end{tabbing}
\end{quote}



\subsection{Constraints on lexical predicates}
We restrict our attention to a collection of stratified models,
$\mathfrak{M}$, in which for any $\mathscr{M}\in\mathfrak{M}$ and
order $n$, the following
hold true.

\subsubsection{Frame constraints}
\label{pg:frameconstraints}
\begin{enumerate} 
 
\item If ``price''$'$($a$) is a non-empty type according to
  $\mathbf{TYPE}_{\mathit{IMC}_{\mathscr{M}_n}}$ then
\begin{quote}
$a:_{\mathbf{TYPE}_{\mathit{IMC}_{\mathscr{M}_n}}}$\record{\tfield{x}{\textit{Ind}} \\
            \tfield{e-time}{\textit{Time}} \\
            \tfield{commodity}{\textit{Ind}} \\
            \tfield{c$_{\mathrm{money}}$}{$\langle\lambda
              v$:\textit{Ind}(money($v$)), $\langle$x$\rangle\rangle$}
            \\
            \tfield{c$_{\mathrm{price\_of\_at}}$}{$\langle\lambda
              v_1$:\textit{Ind} \\
& & \hspace*{1em}($\lambda v_2$:\textit{Ind} \\
& & \hspace*{2em}($\lambda v_3$:\textit{Time} \\
& & \hspace*{3em}(price\_of\_at($v_1,v_2,v_3$)))), \\
& & \hspace*{1ex}$\langle$x,
commodity, e-time$\rangle\rangle$}}

\end{quote}

We call this type \textit{PriceFrame}
 
\item If ``temperature''$'$($a$) is a non-empty type according to
  $\mathbf{TYPE}_{\mathit{IMC}_{\mathscr{M}_n}}$ then
\begin{quote}
$a:_{\mathbf{TYPE}_{\mathit{IMC}_{\mathscr{M}_n}}}$\record{\tfield{x}{\textit{Ind}} \\
        \tfield{e-time}{\textit{Time}} \\
        \tfield{e-location}{\textit{Loc}} \\
        \tfield{c$_{\mathrm{temp\_at\_in}}$}{$\langle\lambda
              v_1$:\textit{Ind} \\
& & \hspace*{1em}($\lambda v_2$:\textit{Ind} \\
& & \hspace*{2em}($\lambda v_3$:\textit{Time} \\
& & \hspace*{3em}(temp\_at\_in($v_1,v_2,v_3$)))), \\
& & \hspace*{1ex}$\langle$x, e-location, e-time$\rangle\rangle$}} 
\end{quote}

We call this type \textit{AmbTempFrame}, ``ambient temperature frame''. 
\end{enumerate} 

\subsubsection{General predicate constraints}
\label{pg:predconstraints}
\begin{enumerate} 
 
\item $a:_{\mathbf{TYPE}_{\mathit{IMC}_{\mathscr{M}_n}}}\textrm{``}\mathrm{be}\textrm{"}'(b,c,t)$ iff $a:_{\mathbf{TYPE}_{\mathit{IMC}_{\mathscr{M}_n}}}\mathrm{eq}(b,c)$ 
 
\item if $r:_{\mathbf{TYPE}_{\mathit{IMC}_{\mathscr{M}_n}}}$\textit{AmbTempFrame}, then
  $a:_{\mathbf{TYPE}_{\mathit{IMC}_{\mathscr{M}_n}}}\textrm{``}\mathrm{rise}\textrm{"}'(r)$
  iff $a=\langle r,r'\rangle$ where
\begin{enumerate} 
 
\item $r':_{\mathbf{TYPE}_{\mathit{IMC}_{\mathscr{M}_n}}}$\textit{AmbTempFrame}
 
\item $r$.x$<$$r'$.x

\item $r$.e-time$<$$r'$.e-time

\item $r$.e-location=$r'$.e-location
 
\end{enumerate} 


\item if $r:_{\mathbf{TYPE}_{\mathit{IMC}_{\mathscr{M}_n}}}$\textit{PriceFrame}, then
  $a:_{\mathbf{TYPE}_{\mathit{IMC}_{\mathscr{M}_n}}}\textrm{``}\mathrm{rise}\textrm{"}'(r)$
  iff $a=\langle r,r'\rangle$ where
\begin{enumerate} 
 
\item $r':_{\mathbf{TYPE}_{\mathit{IMC}_{\mathscr{M}_n}}}$\textit{PriceFrame}
 
\item $r$.x$<$$r'$.x

\item $r$.e-time$<$$r'$.e-time

\item $r$.commodity=$r'$.commodity
 
\end{enumerate} 
 
\end{enumerate}

\subsection{Syntactic rules with compositional semantics}

Our syntactic rules define types of phrases (phrasal types) on the basis of lexical
items (objects of lexical types) and phrases (objects of phrasal
types) which are used to construct these phrases.  The
rules we use will be either unary (employing a function of the form $\lambda
r$:$T_1(T_2)$ where $T_2$ can depend on $r$)
or binary (employing a function of the form $\lambda r_1$:$T_1$($\lambda r_2$:$T_2(T_3))$ where
$T_3$ can depend on $r_1$ and $r_2$)
although there is no reason why rules should not take
greater numbers of arguments.  The general idea is that if $T$ is a
phrasal type and $r:T$ then $r.$s-event.phon is a phrase of the
language of category $r$.synsem.cat with interpretation $r$.synsem.cnt.

We use a number of auxiliary types in the definition of our rules.
These are:
\begin{enumerate}

\renewcommand{\labelenumi}{Ty\arabic{enumi}.}

\item
  \record{\tfield{synsem}{\record{\mfield{finite}{1}{\textit{Bool}}}}}

This is the type used for finite verbs and verb-phrases which we will
designate by \textit{Finite}.

\item \record{\tfield{quant}{$^\sigma$\textit{Quant}} \\
              \tfield{index}{\textit{Nat}}}

This is the type of binding operators used in the quantifier store
(``qstore'') used in the treatment of quantifier scope ambiguities.
We will use \textit{BO} to represent this type.
 
\item
  \record{\tfield{local}{\{\textit{Nat}\}} \\
          \tfield{non-local}{\{\textit{Nat}\}} \\
         % \tfield{slash}{\textit{Bool}} \\
          \tfield{qstore}{\{\textit{BO}\}}}

This is a type which performs record-keeping functions for anaphora.
It keeps track of local and non-local indices on pronouns\ignore{, slash
categories corresponding to gaps which are to be bound by
\textit{wh}-phrases} and a quantifier store (``qstore'') used to give
wide scope interpretations to quantifiers.  We will use \textit{Anaph}
to denote this type.
 
\item  \record{\mfield{local}{$\emptyset$}{\{\textit{Nat}\}} \\
          \mfield{non-local}{$\emptyset$}{\{\textit{Nat}\}} \\
          %\mfield{slash}{0}{\textit{Bool}} \\
          \mfield{qstore}{$\emptyset$}{\{\textit{BO}\}}}

This type corresponds to a situation where no pronouns\ignore{, gaps} or
wide-scope interpretations of quantifiers have been introduced.  We
refer to it as \textit{AnaphEmpty}.

\ignore{\item \record{\mfield{slash}{0}{\textit{Bool}}}

We will refer to this type by \textit{SlashEmpty}.

\item \record{\mfield{slash}{1}{\textit{Bool}}}

We will refer to this type by \textit{SlashFull}.}

\item \record{\mfield{qstore}{$\emptyset$}{\{\textit{BO}\}}}

We will refer to this type as \textit{QStoreEmpty}.
 
\end{enumerate} 
  

We use a number of auxiliary operations in the definition of our
rules.  These are:
\begin{enumerate}

\renewcommand{\labelenumi}{Op\arabic{enumi}.} 
 
\item if $a$:\textit{Str} and $b$:\textit{Str} then $a^\frown
  b$:\textit{Str} where $a^\frown b$ is the concatenation of $a$ and
  $b$. Note that concatenation is an associative operation, that is
  $a^\frown(b^\frown c) = (a^\frown b)^\frown c$, and we will usually
  write $a^\frown b^\frown c$.  This is our standard operation for the
  combination of phonological strings.



\item if $r_1$:\textit{SEvent} and $r_2$:\textit{SEvent} then
  \flconcat{$r_1$}{$r_2$} is to be the type:
\begin{quote}
\textit{SEvent}\d{$\wedge$}\smallrecord{\smallmfield{phon}{$r_1$.phon$^\frown
    r_2$.phon}{\textit{Str}} \\
                                   \smalltfield{s-time}{\smallrecord{\smallmfield{start}{$r_1$.s-time.start}{\textit{Time}}
                                       \\
                                                           \smallmfield{end}{$r_2$.s-time.end}{\textit{Time}}}}}
\end{quote}

\item if $r_1$:\textit{SEvent}, $w$ is a word and $r_2$:\textit{SEvent} then
  \flconcat{$r_1$}{\flconcat{$w$}{$r_2$}} is to be the type:
\begin{quote}
\textit{SEvent}\d{$\wedge$}\smallrecord{\smallmfield{phon}{$r_1$.phon$^\frown w^\frown
    r_2$.phon}{\textit{Str}} \\
                                   \smalltfield{s-time}{\smallrecord{\smallmfield{start}{$r_1$.s-time.start}{\textit{Time}}
                                       \\
                                                           \smallmfield{end}{$r_2$.s-time.end}{\textit{Time}}}}}
\end{quote}

\item if $a$ : $^\sigma(T_1\rightarrow T_2)$ and $b$ : $^\sigma T_1$ then
  $a@b$ is
  $\lambda\sigma$:\textit{Seq$_{\mathit{Ind}}$}($a(\sigma)(b(\sigma))$),
  which is of type $^\sigma T_2$. The operation represented by `@'
  (related to the S-combinator of combinatory logic) is our standard
  operation for ``functional application'' in the construction of
  contents for complex phrases.

\item if $\sigma$:\textit{Seq}$_{\mathit{Ind}}$, $a$:\textit{Ind} and $n$:\textit{Nat},
  then $\sigma[a/n]$ is that function like $\sigma$ except for the
  possible difference that $\sigma[a/n](n)=a$.

\item If $n$:\textit{Nat} and $a$:\textit{Gen}, then the gender offset
  of $n$ with respect to $a$, genoff($n,a$), is
\begin{enumerate} 
 
\item $3n+2$, if $a$ is m 
 
\item $3n+3$, if $a$ is f

\item $3n+4$, if $a$ is n
 
\end{enumerate} 
  

\item if $p$ : $^\sigma$\textit{Prop} $\vee$
   $^\sigma$(\textit{Quant}$\rightarrow$\textit{Prop})\ignore{$\vee$ $^\sigma$(\textit{Prop}$\rightarrow$\textit{Prop})}, then
\begin{enumerate} 
 
\item if $p$ : $^\sigma$\textit{Prop}, then Pres($p$) is 
\begin{quote}
$\lambda t$:\textit{Time} \\
\hspace*{1em}($\lambda\sigma$:\textit{Seq}$_{\mathit{Ind}}$ \\
\hspace*{2em}($\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
\\
\hspace*{3em}($p(\sigma)(r)$\d{$\wedge$}\smallrecord{\smalltfield{e-time}{\textit{Time}}
  \\
                                                     \smalltfield{tns}{$\langle\lambda
                                                       v$:\textit{Time}(eq($v$,$t$)), $\langle$e-time$\rangle\rangle$}}))) 
 \end{quote}
\item if $p$ : $^\sigma$(\textit{Quant}$\rightarrow$\textit{Prop}), then Pres($p$) is 
\begin{quote}
$\lambda t$:\textit{Time} \\
\hspace*{1em}($\lambda\sigma$:\textit{Seq}$_{\mathit{Ind}}$ \\
\hspace*{2em}($\lambda q$:\textit{Quant} \\
\hspace*{3em}($\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
\\
\hspace*{4em}($p(\sigma)(q)(r)$\d{$\wedge$}\smallrecord{\smalltfield{e-time}{\textit{Time}}
  \\
                                                     \smalltfield{tns}{$\langle\lambda
                                                       v$:\textit{Time}(eq($v$,$t$)), $\langle$e-time$\rangle\rangle$}})))) 
 \end{quote}
\ignore{\item if $p$ : $^\sigma$(\textit{Prop}$\rightarrow$\textit{Prop}), then Pres($p$) is 
\begin{quote}
$\lambda t$:\textit{Time} \\
\hspace*{1em}($\lambda\sigma$:\textit{Seq}$_{\mathit{Ind}}$ \\
\hspace*{2em}($\lambda a$:\textit{Prop} \\
\hspace*{3em}($\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
\\
\hspace*{4em}($p(\sigma)(a)(r)$\d{$\wedge$}\smallrecord{\smalltfield{e-time}{\textit{Time}}
  \\
                                                     \smalltfield{tns}{$\langle\lambda
                                                       v$:\textit{Time}(eq($v$,$t$)), $\langle$e-time$\rangle\rangle$}})))) 
 \end{quote}
}
\end{enumerate} 
  

\item If $r$:\textit{Anaph} then lnl($r$) (``move local to
  non-local'') is like $r$
  except that lnl($r$).local = $\emptyset$ and
  lnl($r$).non-local = $r$.non-local $\cup$ $r$.local. 

\item If $r_1$:\textit{Anaph} and $r_2$:\textit{Anaph}, then
  $r_1\sqcup r_2$ is
\begin{display}
\record{\field{local}{$r_1$.local$\cup r_2$.local} \\
          \field{non-local}{$r_1$.non-local$\cup r_2$.non-local} \\
          %\field{slash}{max($r_1$.slash, $r_2$.slash)} \\
          \field{qstore}{$r_1$.qstore$\cup r_2$.qstore}}
\end{display}

 
\item if $a$ is the indefinite article string ``a'' and $b$ is a string
  beginning with a vowel, then
  morph$_{\mathrm{det}}$($a$,$b$)=``an''. Otherwise for any strings
  $a$ and $b$, morph$_{\mathrm{det}}$($a$,$b$)=$a$.

\item if $w$ is a word then addS($w$) is 
\begin{enumerate} 
 
\item $w'$+``s'' if $w$ ends in ``y'' and $w'$ is the result of
  replacing the final ``y'' with ``ie''
 
\item $w$+``es'' if $w$ ends in ``sh''

\item $w$+``s'' otherwise
 
\end{enumerate} 

\item if $w$ is a word then Acc($w$) (the accusative form of $w$) is
\begin{enumerate} 
 
\item ``him'', if $w$ is ``he'' 
 
\item ``her'', if $w$ is ``she'' 

\item  $w$ otherwise

\end{enumerate} 
  
  
 
\end{enumerate} 
  
We now define our rules corresponding to a small subset of the rules in Montague's PTQ.

\begin{enumerate}

\renewcommand{\labelenumi}{R\arabic{enumi}.}
 
\item (corresponding to S1 and T1 in PTQ) \label{rule:lexphrases}

\begin{enumerate} 
 
\item if for some category $A$, $l\in B_A$ (that is, $l$ is a lexical
  type of category $A$) and
  $l\not=$lex$_{\mathrm{T}\textrm{-}\mathrm{Pron}}$($s,n$) for any
  string $s$ or natural number $n$, then 
\begin{display}
$l$\d{$\wedge$}\smallrecord{\smalltfield{synsem}{\smallrecord{\smallmfield{finite}{0}{\textit{Bool}} \\
                                                              \smalltfield{anaph}{\textit{AnaphEmpty}}}}}
\end{display}
is a member of $P_A$ (that is, it is a phrasal
  type of category $A$). 
 
\item  $l=$lex$_{\mathrm{T}\textrm{-}\mathrm{Pron}}$($s,n$) for some
  string $s$ and natural number $n$, then 
\begin{display}
$l$\d{$\wedge$}\smallrecord{\smalltfield{synsem}{\smallrecord{\smallmfield{finite}{0}{\textit{Bool}} \\
                                                              \smalltfield{anaph}{\record{\mfield{local}{\{$n$\}}{\{\textit{Nat}\}} \\
                                                                                          \mfield{non-local}{$\emptyset$}{\{\textit{Nat}\}}
                                                                       \\
                                                                                          %\mfield{slash}{0}{\textit{Bool}}
                                                                     %  \\
                                                                                          \mfield{qstore}{$\emptyset$}{\{\textit{BO}\}}}}}}}
\end{display}
is a member of $P_T$ (that is, it is a phrasal
  type of category $T$).

\item if $l\in B_{\mathit{IV}}$, and $r:l$, then 
\begin{quote}
\hspace*{-10em}\textit{Sign}\d{$\wedge$}\\
\hspace*{-10em}\record{\tfield{s-event}{\record{\mfield{phon}{addS($r$.s-event.phon)}{\textit{Str}} \\
                                  \tfield{s-time}{\record{\tfield{start}{\textit{Time}}}}}}
  \\
        \tfield{synsem}{\record{\mfield{cat}{$r$.synsem.cat}{\textit{Cat}}
            \\
                                \tfield{agr}{\record{\tfield{gen}{\textit{Gen}}
                                    \\
                                                     \mfield{num}{sg}{\textit{Num}}
                                                     \\
                                                     \mfield{pers}{3rd}{\textit{Pers}}}}
                                                 \\
                                \mfield{finite}{1}{\textit{Bool}} \\
                                \tfield{anaph}{\textit{AnaphEmpty}} \\
                                \tfield{cnt}{$\langle\lambda
                                  v$:\textit{Time}(($^\sigma$\textit{Prop})$_{\mathrm{Pres}(r.\mathrm{synsem}.\mathrm{cnt})(v)}$),
                                $\langle$s-event.s-time.start$\rangle\rangle$}}}} 

\end{quote}
$\in P_{\mathit{IV}}$

\item if $l\in B_{\mathit{TV}}$, and $r:l$, then 
\begin{quote}
\hspace*{-10em}\textit{Sign}\d{$\wedge$}\\
\hspace*{-10em}\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{addS($r$.s-event.phon)}{\textit{Str}} \\
                                  \smalltfield{s-time}{\smallrecord{\smalltfield{start}{\textit{Time}}}}}}
  \\
        \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{$r$.synsem.cat}{\textit{Cat}}
            \\
                                         \smalltfield{agr}{\smallrecord{\smalltfield{gen}{\textit{Gen}}
                                    \\
                                                                        \smallmfield{num}{sg}{\textit{Num}}
                                                     \\
                                                                        \smallmfield{pers}{3rd}{\textit{Pers}}}}
                                                 \\
                                         \smallmfield{finite}{1}{\textit{Bool}} \\
                                         \smalltfield{anaph}{\textit{AnaphEmpty}} \\
                                 \smalltfield{cnt}{$\langle\lambda
                                  v$:\textit{Time}(($^\sigma$(\textit{Quant}$\rightarrow$\textit{Prop}))$_{\mathrm{Pres}(r.\mathrm{synsem}.\mathrm{cnt})(v)}$),
                                $\langle$s-event.s-time.start$\rangle\rangle$}}}}  

\end{quote}
$\in P_{\mathit{TV}}$

\ignore{\item if $l\in B_{\mathit{IV//IV}}$, and $r:l$, then 
\begin{quote}
\hspace*{-10em}\textit{Sign}\d{$\wedge$}\\
\hspace*{-10em}\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{addS($r$.s-event.phon)}{\textit{Str}} \\
                                  \smalltfield{s-time}{\smallrecord{\smalltfield{start}{\textit{Time}}}}}}
  \\
        \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{$r$.synsem.cat}{\textit{Cat}}
            \\
                                         \smalltfield{agr}{\smallrecord{\smalltfield{gen}{\textit{Gen}}
                                    \\
                                                                        \smallmfield{num}{sg}{\textit{Num}}
                                                     \\
                                                                        \smallmfield{pers}{3rd}{\textit{Pers}}}}
                                                 \\
                                         \smallmfield{finite}{1}{\textit{Bool}} \\
                                         \smalltfield{anaph}{\textit{AnaphEmpty}} \\
                                 \smalltfield{cnt}{$\langle\lambda
                                  v$:\textit{Time}(($^\sigma$(\textit{Prop}$\rightarrow$\textit{Prop}))$_{\mathrm{Pres}(r.\mathrm{synsem}.\mathrm{cnt})(v)}$),
                                $\langle$s-event.s-time.start$\rangle\rangle$}}}}  

\end{quote}
$\in P_{\mathit{IV//IV}}$
} 

\item if $l\in$ \textit{B}$_{\mathit{T}}$, $n$:\textit{Nat} and $r:l$,
  then \\
$\lambda r$:\smallrecord{\smalltfield{s-event}{\textit{SEvent}} \\
                         \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{T}{\textit{Cat}}
                           \\
                                                           \smalltfield{agr}{\textit{Agr}}
                                                           \\
                                                           \smalltfield{cnt}{$^\sigma$\textit{Quant}}}}}
                                                     \\
\hspace*{1em}(\smallrecord{\smallmfield{s-event}{$r$.s-event}{\textit{SEvent}}
  \\
                           \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{$r$.synsem.cat}{\textit{Cat}}
                               \\
                                                             \smallmfield{agr}{$r$.synsem.agr}{\textit{Agr}}
                                                             \\
                                                             \smallmfield{finite}{0}{\textit{Bool}}
                                                             \\
                                                             \smalltfield{anaph}{\smallrecord{\smallmfield{local}{$\emptyset$}{\{\textit{Nat}\}} \\
                                                                                              \smallmfield{non-local}{$\emptyset$}{\{\textit{Nat}\}}
                                                                       \\
                                                                                              %\smallmfield{slash}{0}{\textit{Bool}}
                                                                   %     \\
                                                                                              \smallmfield{qstore}{\{\smallrecord{\smallmfield{quant}{$r$.synsem.cnt}{$^\sigma$\textit{Quant}}\\
                                                                                                                                  \smallmfield{index}{genoff($n$,
                                                                                                                                  $r$.synsem.agr.gen)}{\textit{Nat}}}\}}{\{\textit{BO}\}}}}
                                                                                                                          \\
                                                           \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}($\lambda
                                  v$:\textit{Prop}($v$(\smallrecord{\field{x}{$\sigma_{\mathrm{genoff}n,r.\mathrm{synsem.agr.gen}}$}})))}{\textit{$^\sigma$Quant}}}}})($l$)
                          \\
$\in P_T$
                                                                                                                          
                      
\end{enumerate} 
  
 
\item  \label{rule:detcn}(corresponding to S2 and T2 in PTQ) \\
If $T_1\in P_{\mathrm{T/CN}}$ and $T_2\in P_{\mathrm{CN}}$,
  $a:T_1$ and \\$b:T_2\wedge$\smallrecord{
                    \smalltfield{synsem}{\smallrecord{
                                                       \smalltfield{anaph}{\ignore{\textit{SlashEmpty}\d{$\wedge$}}\textit{QStoreEmpty}}}}},
                                                \\ then \\ \hspace*{-4em}$\lambda
  r_1$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
    \\
                    \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{T/CN}{\textit{Cat}}
                          \\
                                                      \smalltfield{cnt}{$^\sigma$(\textit{Prop}$\rightarrow$\textit{Quant})}}}}
                                              \\
\hspace*{-3em}$\lambda r_2$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
    \\
                    \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{CN}{\textit{Cat}}
                          \\
                                                      \smalltfield{agr}{\textit{Agr}}
                                                      \\
                                                      \smalltfield{anaph}{\textit{Anaph}\ignore{\d{$\wedge$}\textit{SlashEmpty}}\d{$\wedge$}\textit{QStoreEmpty}} \\
                                                      \smalltfield{cnt}{$^\sigma$\textit{Prop}}}}}
                                              \\
\hspace*{-2em}(\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{morph$_{\mathrm{det}}$($r_1$.s-event.phon,$r_2$.s-event.phon)$^\frown
        r_2$.s-event.phon}{\textit{Str}} \\ 
                                                              \smalltfield{s-time}{\smallrecord{\smallmfield{start}{$r_1$.s-event.s-time.start}{\textit{Time}}
                                                                \\
                                                                                                \smallmfield{end}{$r_2$.s-event.s-time.end}{\textit{Time}}}}}\d{$\wedge$}\textit{SEvent}}
                                                                     \\
                           \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{T}{\textit{Cat}}
                               \\
                                                             \smallmfield{agr}{$r_2$.agr}{\textit{Agr}}
                                                             \\
                                                             \smallmfield{finite}{0}{\textit{Bool}} \\
                                                             \smallmfield{anaph}{lnl($r_2$.anaph)}{\textit{Anaph}} \\
                                                             \smallmfield{cnt}{$r_1$.synsem.cnt@$r_2$.synsem.cnt}{$^\sigma$\textit{Quant}}}}})($a$)($b$)
                                                       $\in$
                                                       $P_{\mathrm{T}}$.

%\item \textit{omitted}
\ignore{\begin{enumerate} 
 
\item If $T_1\in P_{\mathrm{CN}}$ and $T_2\in P_{\mathrm{t}}$, $a:T_1$
  and
  $b:T_2\wedge$\smallrecord{\smalltfield{synsem}{\smallrecord{\smalltfield{anaph}{\textit{SlashFull}}}}},
  \\
then \\
\hspace*{-9em}$\lambda
  r_1$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
    \\
                    \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{CN}{\textit{Cat}}
                          \\
                                                      \smalltfield{agr}{\textit{Agr}} \\
                                                      \smalltfield{cnt}{$^\sigma$\textit{Prop}}}}}
                                              \\
\hspace*{-8em}$\lambda r_2$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
    \\
                    \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{t}{\textit{Cat}}
                          \\
                                                      \smalltfield{anaph}{\textit{Anaph}\d{$\wedge$}\textit{SlashFull}} \\
                                                      \smalltfield{cnt}{$^\sigma$\textit{RecType}}}}}
                                              \\
\hspace*{-7em}(\smallrecord{\smalltfield{s-event}{\flconcat{$r_1$.s-event}{\flconcat{``that''}{$r_2$.s-event}}} \\
                           \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{CN}{\textit{Cat}}
                               \\
                                                             \smallmfield{agr}{$r_1$.agr}{\textit{Agr}}
                                                             \\
                                                             \smallmfield{finite}{0}{\textit{Bool}} \\
                                                             \smalltfield{anaph}{\smallrecord{\smallmfield{local}{$r_1$.synsem.anaph.local}{\{\textit{Nat}\}}
                                                                 \\
                                                                                              \smallmfield{non-local}{$r_1$.synsem.anaph.non-local$\cup$lnl($r_2$.synsem.anaph).non-local}{\{\textit{Nat}\}}
                                                                                            \\
                                                                                              \smallmfield{slash}{0}{\textit{Bool}}\\
                                                                                              \smallmfield{qstore}{$r_1$.synsem.anaph.qstore$\cup
                                                                                                r_2$.synsem.anaph.qstore}{\{\textit{BO}\}}}}
                                                                     \\
                                                             \smallmfield{cnt}{$\lambda\sigma$:\textit{Seq$_{\mathit{Ind}}$}\\
\hspace*{4em}($\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}\\
\hspace*{5em}(\smallrecord{\smalltfield{c}{\smallrecord{\smalltfield{pred}{$r_1$.cnt($\sigma$)($r$)} \\
                            \smalltfield{mod}{$r_2$.cnt($\sigma$[$r$.x/1])($r$)}}}}))}{$^\sigma$\textit{Prop}}}}})($a$)($b$)
                                                       $\in$ $P_{\mathrm{CN}}$.
\item If $T_1\in P_{\mathrm{CN}}$ and $T_2\in P_{\mathrm{IV}}$, $a:T_1$
  and \\
  $b:T_2\wedge$\smallrecord{\smalltfield{synsem}{\smallrecord{\smalltfield{anaph}{\textit{SlashEmpty}}}}},
then \\
\hspace*{-9em}$\lambda
  r_1$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
    \\
                    \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{CN}{\textit{Cat}}
                          \\
                                                      \smalltfield{agr}{\textit{Agr}} \\
                                                      \smalltfield{cnt}{$^\sigma$\textit{Prop}}}}}
                                              \\
\hspace*{-8em}$\lambda r_2$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
    \\
                    \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV}{\textit{Cat}}
                          \\
                                                      \smalltfield{anaph}{\textit{Anaph}\d{$\wedge$}\textit{SlashEmpty}} \\
                                                      \smalltfield{cnt}{$^\sigma$\textit{RecType}}}}}
                                              \\
\hspace*{-7em}(\smallrecord{\smalltfield{s-event}{\flconcat{$r_1$.s-event}{\flconcat{``that''}{$r_2$.s-event}}} \\
                           \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{CN}{\textit{Cat}}
                               \\
                                                             \smallmfield{agr}{$r_1$.agr}{\textit{Agr}}
                                                             \\
                                                             \smallmfield{finite}{0}{\textit{Bool}} \\
                                                             \smalltfield{anaph}{\smallrecord{\smallmfield{local}{$r_1$.synsem.anaph.local}{\{\textit{Nat}\}}
                                                                 \\
                                                                                              \smallmfield{non-local}{$r_1$.synsem.anaph.non-local$\cup$lnl($r_2$.synsem.anaph).non-local}{\{\textit{Nat}\}}
                                                                                            \\
                                                                                              \smallmfield{slash}{0}{\textit{Bool}}\\
                                                                                              \smallmfield{qstore}{$r_1$.synsem.anaph.qstore$\cup
                                                                                                r_2$.synsem.anaph.qstore}{\{\textit{BO}\}}}}
                                                                     \\
                                                             \smallmfield{cnt}{$\lambda\sigma$:\textit{Seq$_{\mathit{Ind}}$}\\
\hspace*{4em}($\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}\\
\hspace*{5em}(\smallrecord{\smalltfield{c}{\smallrecord{\smalltfield{pred}{$r_1$.synsem.cnt($\sigma$)($r$)} \\
                            \smalltfield{mod}{$r_2$.synsem.cnt($\sigma$)($r$)}}}}))}{$^\sigma$\textit{Prop}}}}})($a$)($b$)
                                                       $\in$ $P_{\mathrm{CN}}$. 
 
\end{enumerate} 
}

\item \label{rule:tiv}(corresponding to S4 and T4 in PTQ) \\ 
If $T_1\in P_{\mathrm{T}}$ and $T_2\in P_{\mathrm{IV}}$, $a:T_1$
  and $b:T_2$\d{$\wedge$}\textit{Sg3rd}\d{$\wedge$}\textit{Finite}, then \\
$\lambda
r_1$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{T}{\textit{Cat}}
                      \\
                                                    \smalltfield{anaph}{\textit{Anaph}} \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{Quant}}}}}
                                              \\
\hspace*{1em}$\lambda
r_2$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV}{\textit{Cat}}
                      \\
                                                    \smalltfield{anaph}{\textit{Anaph}}
                                                    \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{Prop}}}}}
                                              \\
\hspace*{2em}(\smallrecord{\smalltfield{s-event}{\flconcat{$r_1$.s-event}{$r_2$.s-event}} \\

              \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{t}{\textit{Cat}}
                  \\
                                                \smallmfield{finite}{1}{\textit{Bool}} \\
                                                \smallmfield{anaph}{$r_1$.synsem.anaph$\sqcup
                                                  r_2$.synsem.anaph}{\textit{Anaph}}
                                                \\
                                                \smallmfield{cnt}{$r_1$.synsem.cnt@$r_2$.synsem.cnt}{$^\sigma$\textit{RecType}}}}})($a$)($b$)
                                          \\
$\in P_{\mathrm{t}}$

\item (corresponding to S5 and T5 in PTQ) \\
\ignore{\begin{enumerate}
\item} If $T_1\in P_{\mathrm{TV}}$ and $T_2\in P_{\mathrm{T}}$, $a:T_1$
  and $b:T_2$, then \\
$\lambda
r_1$:\smallrecord{\smalltfield{s-event}{\textit{SEvent}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{TV}{\textit{Cat}}
                      \\
                                                    \smalltfield{agr}{\textit{Agr}}
                                                    \\
                                                    \smalltfield{finite}{\textit{Bool}} \\
                                                    \smalltfield{anaph}{\textit{Anaph}} \\
                                                    \smalltfield{cnt}{$^\sigma$(\textit{Quant}$\rightarrow$\textit{Prop})}}}}
                                              \\
\hspace*{1em}$\lambda
r_2$:\smallrecord{\smalltfield{s-event}{\textit{SEvent}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{T}{\textit{Cat}}
                      \\
                                                    \smalltfield{anaph}{\textit{Anaph}}
                                                    \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{Quant}}}}}
                                              \\
\hspace*{2em}(\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{$r_1$.s-event.phon$^\frown$Acc($r_2$.s-event.phon)}{\textit{Str}}
    \\
                                                              \smalltfield{s-time}{\smallrecord{\smallmfield{start}{$r_1$.s-event.s-time.start}{\textit{Time}}
                                                                \\
                                                                                                \smallmfield{end}{$r_2$.s-event.s-time.end}{\textit{Time}}}}}\d{$\wedge$}\textit{SEvent}} \\

              \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV}{\textit{Cat}}
                  \\
                                                \smallmfield{agr}{$r_1$.synsem.agr}{\textit{Agr}} \\
                                                \smallmfield{finite}{$r_1$.synsem.finite}{\textit{Bool}} \\
                                                \smallmfield{anaph}{$r_1$.synsem.anaph$\sqcup
                                                  r_2$.synsem.anaph}{\textit{Anaph}}
                                                \\
                                                \smallmfield{cnt}{$r_1$.synsem.cnt@$r_2$.synsem.cnt}{$^\sigma$\textit{Prop}}}}})($a$)($b$)
                                          \\
$\in P_{\mathrm{IV}}$

\ignore{\item If $T_1\in P_{\mathrm{TV}}$ and $a:T_1$\d{$\wedge$}\textit{SlashEmpty}, then \\
$\lambda
r_1$:\smallrecord{\smalltfield{s-event}{\textit{SEvent}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{TV}{\textit{Cat}}
                      \\
                                                    \smalltfield{agr}{\textit{Agr}}
                                                    \\
                                                    \smalltfield{finite}{\textit{Bool}} \\
                                                    \smalltfield{anaph}{\textit{Anaph}} \\
                                                    \smalltfield{cnt}{$^\sigma$(\textit{Quant}$\rightarrow$\textit{Prop})}}}}
                                              \\

\hspace*{1em}(\smallrecord{\smallmfield{s-event}{$r_1$.s-event}{\textit{SEvent}} \\
                           \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV}{\textit{Cat}}
                  \\
                                                \smallmfield{agr}{$r_1$.synsem.agr}{\textit{Agr}} \\
                                                \smallmfield{finite}{$r_1$.synsem.finite}{\textit{Bool}} \\
                                                \smalltfield{anaph}{\smallrecord{\smallmfield{local}{$r_1$.synsem.anaph.local}{\{\textit{Nat}\}} \\
                                                                                 \smallmfield{non-local}{$r_1$.synsem.anaph.non-local}{\{\textit{Nat}\}}
                                                                       \\
                                                                                 \smallmfield{slash}{1}{\textit{Bool}}
                                                                        \\
                                                                                 \smallmfield{qstore}{$r_1$.synsem.anaph.qstore}{\{\textit{BO}\}}}}
                                                \\
                                                \smallmfield{cnt}{$r_1$.synsem.cnt@$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  ($\lambda
                                  v$:\textit{Prop}($v$(\smallrecord{\field{x}{$\sigma_1$}})))}{$^\sigma$\textit{Prop}}}}})($a$)
                                          \\
$\in P_{\mathrm{IV}}$

\end{enumerate}
}

\ignore{\item \textit{omitted}}
\ignore{
\begin{enumerate} 
 
\item If $T_1\in P_{\mathrm{IAV/T}}$ and $T_2\in P_{\mathrm{T}}$, $a:T_1$
  and $b:T_2$, then \\
$\lambda
r_1$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IAV/T}{\textit{Cat}}
                      \\
                                                    \smalltfield{agr}{\textit{Agr}}
                                                    \\
                                                    \smalltfield{finite}{\textit{Bool}} \\
                                                    \smalltfield{anaph}{\textit{Anaph}} \\
                                                    \smalltfield{cnt}{$^\sigma$(\textit{Quant}$\rightarrow$(\textit{Prop}$\rightarrow$\textit{Prop}))}}}}
                                              \\
\hspace*{1em}$\lambda
r_2$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{T}{\textit{Cat}}
                      \\
                                                    \smalltfield{anaph}{\textit{Anaph}}
                                                    \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{Quant}}}}}
                                              \\
\hspace*{2em}(\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{$r_1$.s-event.phon$^\frown$Acc($r_2$.s-event.phon)}{\textit{Str}}}} \\

              \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IAV}{\textit{Cat}}
                  \\
                                                \smallmfield{agr}{$r_1$.synsem.agr}{\textit{Agr}} \\
                                                \smallmfield{finite}{$r_1$.synsem.finite}{\textit{Bool}} \\
                                                \smallmfield{anaph}{$r_1$.synsem.anaph$\sqcup
                                                  r_2$.synsem.anaph}{\textit{Anaph}}
                                                \\
                                                \smallmfield{cnt}{$r_1$.synsem.cnt@$r_2$.synsem.cnt}{$^\sigma$(\textit{Prop}$\rightarrow$\textit{Prop})}}}})($a$)($b$)
                                          \\
$\in P_{\mathrm{IAV}}$ 
 
\item If $T_1\in P_{\mathrm{IAV/T}}$ and  $a:T_1$\d{$\wedge$}\textit{SlashEmpty}, then \\
$\lambda
r_1$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IAV/T}{\textit{Cat}}
                      \\
                                                    \smalltfield{agr}{\textit{Agr}}
                                                    \\
                                                    \smalltfield{finite}{\textit{Bool}} \\
                                                    \smalltfield{anaph}{\textit{Anaph}} \\
                                                    \smalltfield{cnt}{$^\sigma$(\textit{Quant}$\rightarrow$(\textit{Prop}$\rightarrow$\textit{Prop}))}}}}
                                              \\
\hspace*{1em}(\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{$r_1$.s-event.phon$^\frown$Acc($r_2$.s-event.phon)}{\textit{Str}}}} \\

              \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IAV}{\textit{Cat}}
                  \\
                                                \smallmfield{agr}{$r_1$.synsem.agr}{\textit{Agr}} \\
                                                \smallmfield{finite}{$r_1$.synsem.finite}{\textit{Bool}} \\
                                                \smalltfield{anaph}{\smallrecord{\smallmfield{local}{$r_1$.synsem.anaph.local}{\{\textit{Nat}\}} \\
                                                                                 \smallmfield{non-local}{$r_1$.synsem.anaph.non-local}{\{\textit{Nat}\}}
                                                                       \\
                                                                                 \smallmfield{slash}{1}{\textit{Bool}}
                                                                        \\
                                                                                 \smallmfield{qstore}{$r_1$.synsem.anaph.qstore}{\{\textit{BO}\}}}}
                                                \\
                                                \smallmfield{cnt}{$r_1$.synsem.cnt@$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  ($\lambda
                                  v$:\textit{Prop}($v$(\smallrecord{\field{x}{$\sigma_1$}})))}{$^\sigma$(\textit{Prop}$\rightarrow$\textit{Prop})}}}})($a$)
                                          \\
$\in P_{\mathrm{IAV}}$ 
 
\end{enumerate} 
}  

\ignore{\item \textit{omitted}} \ignore{If $T_1\in P_{\mathrm{IV/t}}$ and $T_2\in P_{\mathrm{T}}$, $a:T_1$
  and $b:T_2$, then \\
$\lambda
r_1$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV/t}{\textit{Cat}}
                      \\
                                                    \smalltfield{agr}{\textit{Agr}}
                                                    \\
                                                    \smalltfield{finite}{\textit{Bool}} \\
                                                    \smalltfield{anaph}{\textit{Anaph}} \\
                                                    \smalltfield{cnt}{$^\sigma$(\textit{RecType}$\rightarrow$\textit{Prop})}}}}
                                              \\
\hspace*{1em}$\lambda
r_2$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{T}{\textit{Cat}}
                      \\
                                                    \smalltfield{anaph}{\textit{Anaph}}
                                                    \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{RecType}}}}}
                                              \\
\hspace*{2em}(\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{$r_1$.s-event.phon$^\frown$``that''$^\frown
        r_2$.s-event.phon}{\textit{Str}}}} \\

              \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV}{\textit{Cat}}
                  \\
                                                \smallmfield{agr}{$r_1$.synsem.agr}{\textit{Agr}} \\
                                                \smallmfield{finite}{$r_1$.synsem.finite}{\textit{Bool}} \\
                                                \smallmfield{anaph}{$r_1$.synsem.anaph$\sqcup
                                                  r_2$.synsem.anaph}{\textit{Anaph}}
                                                \\
                                                \smallmfield{cnt}{$r_1$.synsem.cnt@$r_2$.synsem.cnt}{$^\sigma$\textit{Prop}}}}})($a$)($b$)
                                          \\
$\in P_{\mathrm{IV}}$
}

\ignore{\item \textit{omitted}}\ignore{If $T_1\in P_{\mathrm{IV//IV}}$ and $T_2\in P_{\mathrm{IV}}$,
  $a:T_1$, $b:T_2$ and $a$.synsem.anaph.slash + $b$.synsem.anaph.slash : \textit{Bool}, then \\
$\lambda
r_1$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV//IV}{\textit{Cat}}
                      \\
                                                    \smalltfield{agr}{\textit{Agr}}
                                                    \\
                                                    \smalltfield{finite}{\textit{Bool}} \\
                                                    \smalltfield{anaph}{\textit{Anaph}} \\
                                                    \smalltfield{cnt}{$^\sigma$(\textit{Prop}$\rightarrow$\textit{Prop})}}}}
                                              \\
\hspace*{1em}$\lambda
r_2$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV}{\textit{Cat}}
                      \\
                                                    \smalltfield{anaph}{\textit{Anaph}}
                                                    \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{Prop}}}}}
                                              \\
\hspace*{2em}(\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{$r_1$.s-event.phon$^\frown$``to''$^\frown
        r_2$.s-event.phon}{\textit{Str}}}} \\

              \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV}{\textit{Cat}}
                  \\
                                                \smallmfield{agr}{$r_1$.synsem.agr}{\textit{Agr}} \\
                                                \smallmfield{finite}{$r_1$.synsem.finite}{\textit{Bool}} \\
                                                \smallmfield{anaph}{$r_1$.synsem.anaph$\sqcup
                                                  r_2$.synsem.anaph}{\textit{Anaph}}
                                                \\
                                                \smallmfield{cnt}{$r_1$.synsem.cnt@$r_2$.synsem.cnt}{$^\sigma$\textit{Prop}}}}})($a$)($b$)
                                          \\
$\in P_{\mathrm{IV}}$ 
}

\ignore{\item \textit{omitted}}\ignore{If $T_1\in P_{\mathrm{t/t}}$ and $T_2\in P_{\mathrm{t}}$, $a:T_1$
  and $b:T_2$ (and $a$.synsem.anaph.slash + $b$.synsem.anaph.slash : \textit{Bool}), then \\
$\lambda
r_1$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{t/t}{\textit{Cat}}
                      \\
                                                    \smalltfield{agr}{\textit{Agr}}
                                                    \\
                                                    \smalltfield{finite}{\textit{Bool}} \\
                                                    \smalltfield{anaph}{\textit{Anaph}} \\
                                                    \smalltfield{cnt}{$^\sigma$(\textit{RecType}$\rightarrow$\textit{RecType})}}}}
                                              \\
\hspace*{1em}$\lambda
r_2$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{t}{\textit{Cat}}
                      \\
                                                    \smalltfield{anaph}{\textit{Anaph}}
                                                    \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{RecType}}}}}
                                              \\
\hspace*{2em}(\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{$r_1$.s-event.phon$^\frown
        r_2$.s-event.phon}{\textit{Str}}}} \\

              \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{t}{\textit{Cat}}
                  \\
                                                \smallmfield{agr}{$r_1$.synsem.agr}{\textit{Agr}} \\
                                                \smallmfield{finite}{$r_1$.synsem.finite}{\textit{Bool}} \\
                                                \smallmfield{anaph}{$r_1$.synsem.anaph$\sqcup
                                                  r_2$.synsem.anaph}{\textit{Anaph}}
                                                \\
                                                \smallmfield{cnt}{$r_1$.synsem.cnt@$r_2$.synsem.cnt}{$^\sigma$\textit{RecType}}}}})($a$)($b$)
                                          \\
$\in P_{\mathrm{t}}$
}

\ignore{\item \textit{omitted}} \ignore{If $T_1\in P_{\mathrm{IV/IV}}$ and $T_2\in P_{\mathrm{IV}}$, $a:T_1$,
 $b:T_2$ and $a$.synsem.anaph.slash + $b$.synsem.anaph.slash : \textit{Bool}, then \\
$\lambda
r_1$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV/IV}{\textit{Cat}}
                      \\
                                                    \smalltfield{agr}{\textit{Agr}}
                                                    \\
                                                    \smalltfield{finite}{\textit{Bool}} \\
                                                    \smalltfield{anaph}{\textit{Anaph}} \\
                                                    \smalltfield{cnt}{$^\sigma$(\textit{Prop}$\rightarrow$\textit{Prop})}}}}
                                              \\
\hspace*{1em}$\lambda
r_2$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV}{\textit{Cat}}
                      \\
                                                    \smalltfield{anaph}{\textit{Anaph}}
                                                    \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{Prop}}}}}
                                              \\
\hspace*{2em}(\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{$r_2$.s-event.phon$^\frown
        r_1$.s-event.phon}{\textit{Str}}}} \\

              \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV}{\textit{Cat}}
                  \\
                                                \smallmfield{agr}{$r_1$.synsem.agr}{\textit{Agr}} \\
                                                \smallmfield{finite}{$r_1$.synsem.finite}{\textit{Bool}} \\
                                                \smallmfield{anaph}{$r_1$.synsem.anaph$\sqcup
                                                  r_2$.synsem.anaph}{\textit{Anaph}}
                                                \\
                                                \smallmfield{cnt}{$r_1$.synsem.cnt@$r_2$.synsem.cnt}{$^\sigma$\textit{Prop}}}}})($a$)($b$)
                                          \\
$\in P_{\mathrm{IV}}$ 
}

\ignore{
\item 
\begin{enumerate} 
 
\item  If $T_1,T_2\in P_{\mathrm{t}}$, $a:T_1$,
  $b:T_2$ and $a$.synsem.anaph.slash = $b$.synsem.anaph.slash, then \\
$\lambda
r_1$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{t}{\textit{Cat}}
                      \\
                                                    \smalltfield{finite}{\textit{Bool}} \\
                                                    \smalltfield{anaph}{\textit{Anaph}} \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{RecType}}}}}
                                              \\
\hspace*{1em}$\lambda
r_2$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{t}{\textit{Cat}}
                      \\
                                                    \smalltfield{anaph}{\textit{Anaph}}
                                                    \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{RecType}}}}}
                                              \\
\hspace*{2em}(\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{$r_1$.s-event.phon$^\frown$``and''$^\frown
        r_2$.s-event.phon}{\textit{Str}}}} \\

              \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{t}{\textit{Cat}}
                  \\
                                                \smallmfield{finite}{$r_1$.synsem.finite}{\textit{Bool}} \\
                                                \smallmfield{anaph}{$r_1$.synsem.anaph$\sqcup
                                                  r_2$.synsem.anaph}{\textit{Anaph}}
                                                \\
                                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$(\smallrecord{\smalltfield{c$_1$}{$r_1$.synsem.cnt($\sigma$)}
                                      \\
                                                                                   \smalltfield{c$_2$}{$r_2$.synsem.cnt($\sigma$)}})}{$^\sigma$\textit{RecType}}}}})($a$)($b$)
                                          \\
$\in P_{\mathrm{t}}$ 

 
\item If $T_1,T_2\in P_{\mathrm{t}}$, $a:T_1$, $b:T_2$ and $a$.synsem.anaph.slash = $b$.synsem.anaph.slash, then \\
$\lambda
r_1$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{t}{\textit{Cat}}
                      \\
                                                    \smalltfield{finite}{\textit{Bool}} \\
                                                    \smalltfield{anaph}{\textit{Anaph}} \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{RecType}}}}}
                                              \\
\hspace*{1em}$\lambda
r_2$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{t}{\textit{Cat}}
                      \\
                                                    \smalltfield{anaph}{\textit{Anaph}}
                                                    \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{RecType}}}}}
                                              \\
\hspace*{2em}(\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{$r_1$.s-event.phon$^\frown$``or''$^\frown
        r_2$.s-event.phon}{\textit{Str}}}} \\

              \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{t}{\textit{Cat}}
                  \\
                                                \smallmfield{finite}{$r_1$.synsem.finite}{\textit{Bool}} \\
                                                \smallmfield{anaph}{$r_1$.synsem.anaph$\sqcup
                                                  r_2$.synsem.anaph}{\textit{Anaph}}
                                                \\
                                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$(\smallrecord{\smalltfield{c}{$r_1$.synsem.cnt($\sigma$)$\vee
                                   r_2$.synsem.cnt($\sigma$)}})}{$^\sigma$\textit{RecType}}}}})($a$)($b$)
                                          \\
$\in P_{\mathrm{t}}$  
 
\end{enumerate} 

\item 
\begin{enumerate} 
 
\item  If $T_1,T_2\in P_{\mathrm{IV}}$, $a:T_1$,
  $b:T_2$ and $a$.synsem.anaph.slash = $b$.synsem.anaph.slash, then \\
$\lambda
r_1$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV}{\textit{Cat}}
                      \\
                                                    \smalltfield{finite}{\textit{Bool}} \\
                                                    \smalltfield{anaph}{\textit{Anaph}} \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{Prop}}}}}
                                              \\
\hspace*{1em}$\lambda
r_2$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV}{\textit{Cat}}
                      \\
                                                    \smalltfield{anaph}{\textit{Anaph}}
                                                    \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{Prop}}}}}
                                              \\
\hspace*{2em}(\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{$r_1$.s-event.phon$^\frown$``and''$^\frown
        r_2$.s-event.phon}{\textit{Str}}}} \\

              \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV}{\textit{Cat}}
                  \\
                                                \smallmfield{finite}{$r_1$.synsem.finite}{\textit{Bool}} \\
                                                \smallmfield{anaph}{$r_1$.synsem.anaph$\sqcup
                                                  r_2$.synsem.anaph}{\textit{Anaph}}
                                                \\
                                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$($\lambda
                                  r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}(\smallrecord{\smalltfield{c$_1$}{$r_1$.synsem.cnt($\sigma$)($r$)}
                                      \\
                                                                                   \smalltfield{c$_2$}{$r_2$.synsem.cnt($\sigma$)($r$)}}))}{$^\sigma$\textit{Prop}}}}}))($a$)($b$)
                                          \\
$\in P_{\mathrm{IV}}$ 

 
\item If $T_1,T_2\in P_{\mathrm{IV}}$, $a:T_1$, $b:T_2$ and $a$.synsem.anaph.slash = $b$.synsem.anaph.slash, then \\
\hspace*{-8em}$\lambda
r_1$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV}{\textit{Cat}}
                      \\
                                                    \smalltfield{finite}{\textit{Bool}} \\
                                                    \smalltfield{anaph}{\textit{Anaph}} \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{Prop}}}}}
                                              \\
\hspace*{-7em}$\lambda
r_2$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV}{\textit{Cat}}
                      \\
                                                    \smalltfield{anaph}{\textit{Anaph}}
                                                    \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{Prop}}}}}
                                              \\
\hspace*{-6em}(\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{$r_1$.s-event.phon$^\frown$``or''$^\frown
        r_2$.s-event.phon}{\textit{Str}}}} \\

              \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV}{\textit{Cat}}
                  \\
                                                \smallmfield{finite}{$r_1$.synsem.finite}{\textit{Bool}} \\
                                                \smallmfield{anaph}{$r_1$.synsem.anaph$\sqcup
                                                  r_2$.synsem.anaph}{\textit{Anaph}}
                                                \\
                                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$($\lambda
                                  r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}(\smallrecord{\smalltfield{c}{$r_1$.synsem.cnt($\sigma$)($r$)$\vee
                                   r_2$.synsem.cnt($\sigma$)($r$)}}))}{$^\sigma$\textit{Prop}}}}})($a$)($b$)
                                          \\
$\in P_{\mathrm{IV}}$  
 
\end{enumerate}

\item If $T_1,T_2\in P_{\mathrm{T}}$,
  $a:T_1$\d{$\wedge$}\textit{SlashEmpty} and $b:T_2$\d{$\wedge$}\textit{SlashEmpty}, then \\
\hspace*{-5em}$\lambda
r_1$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{T}{\textit{Cat}}
                      \\
                                                    \smalltfield{finite}{\textit{Bool}} \\
                                                    \smalltfield{anaph}{\textit{Anaph}} \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{Quant}}}}}
                                              \\
\hspace*{-4em}$\lambda
r_2$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Str}}}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{T}{\textit{Cat}}
                      \\
                                                    \smalltfield{anaph}{\textit{Anaph}}
                                                    \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{Quant}}}}}
                                              \\
\hspace*{-3em}(\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{$r_1$.s-event.phon$^\frown$``or''$^\frown
        r_2$.s-event.phon}{\textit{Str}}}} \\

              \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{T}{\textit{Cat}}
                  \\
                                                \smallmfield{finite}{$r_1$.synsem.finite}{\textit{Bool}} \\
                                                \smallmfield{anaph}{$r_1$.synsem.anaph$\sqcup
                                                  r_2$.synsem.anaph}{\textit{Anaph}}
                                                \\
                                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$($\lambda
                                  p$:\textit{Prop}(\smallrecord{\smalltfield{c}{$r_1$.synsem.cnt($\sigma$)($p$)$\vee
                                   r_2$.synsem.cnt($\sigma$)($p$)}}))}{$^\sigma$\textit{Quant}}}}})($a$)($b$)
                                          \\
$\in P_{\mathrm{T}}$  
}

\item (corresponding to S14 and T14 in PTQ) \\
If $T\in P_{\mathrm{t}}$,
  $a:T$ and \smallrecord{\field{quant}{$q$} \\
                         \field{index}{$i$}}$\in
                       a$.synsem.anaph.qstore, then \\
$\lambda
r$:\smallrecord{\smalltfield{s-event}{\textit{SEvent}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{t}{\textit{Cat}}
                      \\
                                                    \smalltfield{finite}{\textit{Bool}} \\
                                                    \smalltfield{anaph}{\smallrecord{\smalltfield{local}{\{\textit{Nat}\}} \\
                                                                                     \smalltfield{non-local}{\{\textit{Nat}\}}
                                                                       \\
                                                                                     \smalltfield{qstore}{\{\textit{BO}\}}}}
                                                                    \\
                                                    \smalltfield{cnt}{$^\sigma$\textit{RecType}}}}}
                                              \\
\hspace*{2em}(\smallrecord{\smallmfield{s-event}{$r$.s-event}{\textit{SEvent}}
  \\
                  \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{t}{\textit{Cat}}
                      \\
                                                    \smallmfield{finite}{$r$.synsem.finite}{\textit{Bool}} \\
                                                    \smalltfield{anaph}{\smallrecord{\smallmfield{local}{$r$.synsem.anaph.local}{\{\textit{Nat}\}} \\
                                                                                     \smallmfield{non-local}{$r$.synsem.anaph.non-local}{\{\textit{Nat}\}}
                                                                       \\
                                                                                     \smallmfield{qstore}{$r$.synsem.anaph.qstore$-$\{\smallrecord{\field{quant}{$q$} \\
                         \field{index}{$i$}}\}}{\{\textit{BO}\}}}}
                                                                    \\
                                                    \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$(q($\lambda
                                r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}($r$.synsem.cnt($\sigma[r.\mathrm{x}/i]$))))}{$^\sigma$\textit{RecType}}}}})($a$)\\
$\in P_{\mathrm{t}}$
 
\end{enumerate} 

\subsubsection{Examples of phrasal types}
\label{pg:phrasaltypes}
In order to illustrate how to derive phrasal types using this
apparatus we will show a detailed derivation of a phrasal type
corresponding to the phonological string \textit{a woman runs}.  We
will compare this with a similar phrasal type derived for \textit{a
  price rises}.

Corresponding to the indefinite article \textit{a}, we have the
following type provided by the lexicon 
(p. \pageref{pg:lexicon-indefart}) and case (a) of rule
R\ref{rule:lexphrases} (p. \pageref{rule:lexphrases})
\begin{quote}
\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{``a''}{\textit{Str}}\\
                                   \smalltfield{s-time}{\smallrecord{\smalltfield{start}{\textit{Time}}
                                     \\
                                                                     \smalltfield{end}{\textit{Time}}}}\\
                                   \smalltfield{utt$_\mathrm{at}$}{$\langle
                                   \lambda v_1:$\textit{Str}$(\lambda
                                   v_2:$\textit{Time}($\lambda
                                   v_3:$\textit{Time}(uttered\_at($v_1$,$v_2$,$v_3$)))), \\
                                   \hspace*{4em}$\langle$s-event.phon,
                                   s-event.s-time.start, s-event.s-time.end$\rangle\rangle$}}}
                               \\
              \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{T/CN}{\textit{Cat}}\\
                                                \smallmfield{finite}{0}{\textit{Bool}} \\
                                                \smalltfield{anaph}{\textit{AnaphEmpty}} \\
                                                \smallmfield{cnt}{$\lambda
                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                  \\ \hspace*{3em}($\lambda v_1$:\textit{Prop} \\
\hspace*{4em}($\lambda v_2$:\textit{Prop} \\
\hspace*{5em}(\record{\tfield{par}{\smallrecord{\smalltfield{x}{\textit{Ind}}}}
  \\
                      \tfield{restr}{$\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}}($v_1(v)$),
                        $\langle\mathrm{par}\rangle\rangle$} \\
                      \tfield{scope}{$\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}}($v_2(v)$), $\langle\mathrm{par}\rangle\rangle$}})))
}{$^\sigma$(\textit{Prop}$\rightarrow$\textit{Quant})}}}}

\end{quote}

Corresponding to the common noun \textit{woman} we have the following
type provided by the lexicon (p. \pageref{pg:lexicon-cn}) and case (a) of rule
R\ref{rule:lexphrases}
\begin{quote}
\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{``woman''}{\textit{Str}}\\
                                                \smalltfield{s-time}{\smallrecord{\smalltfield{start}{\textit{Time}}
                                     \\
                                                                                  \smalltfield{end}{\textit{Time}}}}\\
                                                                                  \smalltfield{utt$_\mathrm{at}$}{$\langle
                                                                                               \lambda
                                                                                               v_1:$\textit{Str}$(\lambda
                                                                                               v_2:$\textit{Time}($\lambda
                                                                                               v_3:$\textit{Time}(uttered\_at($v_1$,$v_2$,$v_3$)))),
                                                                       \\
                                                                                               \hspace*{4em}$\langle$s-event.phon,
                                                                                               s-event.s-time.start,
                                                                                               s-event.s-time.end$\rangle\rangle$}}}
                               \\
            \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{CN}{\textit{Cat}}\\
                                              \smalltfield{agr}{\textit{FemSg3rd}}
                                 \\
                                             \smallmfield{finite}{0}{\textit{Bool}} \\
                                                              \smalltfield{anaph}{\textit{AnaphEmpty}} \\
                                              \smallmfield{cnt}{$\lambda
                                                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$
                                                                  \\ \hspace*{3em}($\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}} \\
                                                                   \hspace*{4em}(\smallrecord{\smalltfield{c$_{\textrm{``}\mathrm{woman}\textrm{"}}$}{$\textrm{``woman"}'$($v$.x)}}))}{$^\sigma$\textit{Prop}}}}}

\end{quote}

Suppose we have two objects \textbf{\textit{a}} and
\textbf{\textit{woman}} which are respectively of these types. Then by
rule R\ref{rule:detcn} on p. \pageref{rule:detcn} we can conclude that
the following is a phrasal type:
\begin{quote}
\hspace*{-2em}\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{``a
      woman''}{\textit{Str}} \\ 
                                                              \smalltfield{s-time}{\smallrecord{\smallmfield{start}{\textbf{\textit{a}}.s-event.s-time.start}{\textit{Time}}
                                                                \\
                                                                                                \smallmfield{end}{\textbf{\textit{woman}}.s-event.s-time.end}{\textit{Time}}}}
                                                                                          \\
\smalltfield{utt$_\mathrm{at}$}{$\langle
                                                                                               \lambda
                                                                                               v_1:$\textit{Str}$(\lambda
                                                                                               v_2:$\textit{Time}($\lambda
                                                                                               v_3:$\textit{Time}(uttered\_at($v_1$,$v_2$,$v_3$)))),
                                                                       \\
                                                                                               \hspace*{4em}$\langle$s-event.phon,
                                                                                               s-event.s-time.start,
                                                                                               s-event.s-time.end$\rangle\rangle$}}}
                                                                     \\
                           \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{T}{\textit{Cat}}
                               \\
                                                             \smalltfield{agr}{\textit{FemSg3rd}}
                                                             \\
                                                             \smallmfield{finite}{0}{\textit{Bool}} \\
                                                             \smalltfield{anaph}{\textit{AnaphEmpty}} \\
                                                             \smallmfield{cnt}{$\lambda
                                                                  \sigma$:\textit{Seq}$_{\mathit{Ind}}$ \\
\hspace*{4em}($\lambda v_2$:\textit{Prop} \\
\hspace*{5em}(\record{\tfield{par}{\smallrecord{\smalltfield{x}{\textit{Ind}}}}
  \\
                      \tfield{restr}{$\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}}(\smallrecord{\smalltfield{c$_{\textrm{``}\mathrm{woman}\textrm{"}}$}{$\textrm{``woman"}'$($v$.x)}}),
                        $\langle\mathrm{par}\rangle\rangle$} \\
                      \tfield{scope}{$\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}}($v_2(v)$), $\langle\mathrm{par}\rangle\rangle$}}))}{$^\sigma$\textit{Quant}}}}}
\end{quote}

The idea is that an agent can infer the existence of a such a type on
the basis of observing two speech events with phonology ``a'' and
``woman'' respectively which are sufficiently adjacent in time.  If
the utterance of ``a'' starts at $t_1$ and the utterance of ``woman''
ends at $t_2$ then we can conclude that there is a speech event (an
utterance of ``a woman'') starting at $t_1$ and ending at $t_2$ and
that this speech event represents a linguistic object of this type.
Thus parsing can be construed as the perception of events as being of
certain linguistic types and cognitive processing which leads us from
types of simple objects to types of complex objects.

Corresponding to the verb \textit{runs} we have the following
type provided by the lexicon (p. \pageref{pg:lexicon-iv}) and case (c) of rule
R\ref{rule:lexphrases}
\begin{quote}
\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{``runs''}{\textit{Str}}\\
                                                \smalltfield{s-time}{\smallrecord{\smalltfield{start}{\textit{Time}}
                                     \\
                                                                                  \smalltfield{end}{\textit{Time}}}}\\
                                                                                  \smalltfield{utt$_\mathrm{at}$}{$\langle
                                                                                               \lambda
                                                                                               v_1:$\textit{Str}$(\lambda
                                                                                               v_2:$\textit{Time}($\lambda
                                                                                               v_3:$\textit{Time}(uttered\_at($v_1$,$v_2$,$v_3$)))),
                                                                       \\
                                                                                               \hspace*{4em}$\langle$s-event.phon,
                                                                                               s-event.s-time.start,
                                                                                               s-event.s-time.end$\rangle\rangle$}}}
                               \\
            \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{IV}{\textit{Cat}}\\
                                              \smalltfield{agr}{\textit{Sg3rd}}
                                 \\
                                             \smallmfield{finite}{1}{\textit{Bool}} \\
                                                              \smalltfield{anaph}{\textit{AnaphEmpty}} \\
                                              \smallmfield{cnt}{$\langle\lambda
                                                t$:\textit{Time}\textbf{\{}
                                                \\ \hspace*{4em}$\lambda\sigma$:\textit{Seq}$_{\textit{Ind}}$ \\
\hspace*{5em}($\lambda
r$:\smallrecord{\smalltfield{x}{\textit{Ind}}} \\ 
\hspace*{6em} (\smallrecord{\smalltfield{e-time}{\textit{Time}}
                                                                     \\
                            \smalltfield{tns}{$\langle\lambda
                              v$:\textit{Time} 
(eq($v$,$t$)),$\langle$e-time$\rangle\rangle$} \\
                            \smalltfield{c$_{\textrm{``}\mathrm{run}\textrm{"}}$}{$\langle\lambda
  v$:\textit{Time}(``run"$'$($r$.x,$v$)),
  $\langle$e-time$\rangle\rangle$}})) \\
\hspace*{4em}\textbf{\}}, \\
\hspace*{6em}$\langle$s-event.s-time.start$\rangle\rangle$)}{$^\sigma$\textit{Prop}}}}}

\end{quote}


The treatment of the English simple present tense here, which requires
that the event-time is identical to the start of the speech time is,
like Montague's original analysis, woefully inadequate.  We are not
concerned here with getting an accurate rendition of English tenses.
The event time should at least be treated as an interval with a start
and end time in the same
manner as the speech time.  This would, for example, enable us to
capture the sports-reporter use of the simple present by requiring that
the event interval be included in the speech interval.

Suppose we have two objects \textbf{\textit{a woman}} and
\textbf{\textit{runs}} which are respectively of the type we derived
corresponding to ``a woman'' and this type. Then by
rule R\ref{rule:tiv} on p. \pageref{rule:tiv} we can conclude that
the following is a phrasal type:
\begin{quote}
\hspace*{-4em}\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{``a
      woman runs''}{\textit{Str}} \\ 
                                                              \smalltfield{s-time}{\smallrecord{\smallmfield{start}{\textbf{\textit{a
                                                                      woman}}.s-event.s-time.start}{\textit{Time}}
                                                                \\
                                                                                                \smallmfield{end}{\textbf{\textit{runs}}.s-event.s-time.end}{\textit{Time}}}}
                                                                                          \\
\smalltfield{utt$_\mathrm{at}$}{$\langle
                                                                                               \lambda
                                                                                               v_1:$\textit{Str}$(\lambda
                                                                                               v_2:$\textit{Time}($\lambda
                                                                                               v_3:$\textit{Time}(uttered\_at($v_1$,$v_2$,$v_3$)))),
                                                                       \\
                                                                                               \hspace*{4em}$\langle$s-event.phon,
                                                                                               s-event.s-time.start,
                                                                                               s-event.s-time.end$\rangle\rangle$}}}
                                                                     \\
                           \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{t}{\textit{Cat}}
                               \\
                                                             \smallmfield{finite}{1}{\textit{Bool}} \\
                                                             \smalltfield{anaph}{\textit{AnaphEmpty}} \\
                                                             \smallmfield{cnt}{$\langle\lambda
                                                t$:\textit{Time}\textbf{\{}
                                                \\ \hspace*{4em}$\lambda\sigma$:\textit{Seq}$_{\textit{Ind}}$ \\
\hspace*{5em} (\record{\tfield{par}{\smallrecord{\smalltfield{x}{\textit{Ind}}}}
  \\
        \tfield{restr}{$\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}}(\smallrecord{\smalltfield{c$_{\textrm{``}\mathrm{woman}\textrm{"}}$}{$\textrm{``woman"}'$($v$.x)}}),
                        $\langle\mathrm{par}\rangle\rangle$} \\
                      \tfield{scope}{$\langle\lambda v_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}(\smallrecord{\smalltfield{e-time}{\textit{Time}}
                                                                     \\
                            \smalltfield{tns}{$\langle\lambda
                              v$:\textit{Time} 
(eq($v$,$t$)),$\langle$e-time$\rangle\rangle$} \\
                            \smalltfield{c$_{\textrm{``}\mathrm{run}\textrm{"}}$}{$\langle\lambda
  v$:\textit{Time}(``run"$'$($v_1$.x,$v$)),
  $\langle$e-time$\rangle\rangle$}}), \\ & &
\hspace*{8em}$\langle$par$\rangle\rangle$}}) \\
\hspace*{5em}\textbf{\}}, \\ \hspace*{8em}$\langle$s-event.s-time.start$\rangle\rangle$}{$^\sigma$\textit{RecType}}}}}

\end{quote}


A similar derivation leads to the following phrasal type corresponding
to ``a price rises''.
\begin{quote}
\hspace*{-9em}\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{``a
     price rises''}{\textit{Str}} \\ 
                                                              \smalltfield{s-time}{\smallrecord{\smallmfield{start}{\textbf{\textit{a
                                                                      price}}.s-event.s-time.start}{\textit{Time}}
                                                                \\
                                                                                                \smallmfield{end}{\textbf{\textit{rises}}.s-event.s-time.end}{\textit{Time}}}}
                                                                                          \\
\smalltfield{utt$_\mathrm{at}$}{$\langle
                                                                                               \lambda
                                                                                               v_1:$\textit{Str}$(\lambda
                                                                                               v_2:$\textit{Time}($\lambda
                                                                                               v_3:$\textit{Time}(uttered\_at($v_1$,$v_2$,$v_3$)))),
                                                                       \\
                                                                                               \hspace*{4em}$\langle$s-event.phon,
                                                                                               s-event.s-time.start,
                                                                                               s-event.s-time.end$\rangle\rangle$}}}
                                                                     \\
                           \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{t}{\textit{Cat}}
                               \\
                                                             \smallmfield{finite}{1}{\textit{Bool}} \\
                                                             \smalltfield{anaph}{\textit{AnaphEmpty}}
                                                             \\
\smallmfield{cnt}{$\langle\lambda
                                                t$:\textit{Time}\textbf{\{}
                                                \\ \hspace*{4em}$\lambda\sigma$:\textit{Seq}$_{\textit{Ind}}$ \\
\hspace*{5em} (\record{\tfield{par}{\smallrecord{\smalltfield{x}{\textit{Ind}}}}
  \\
        \tfield{restr}{$\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}}(\smallrecord{\smalltfield{c$_{\textrm{``}\mathrm{price}\textrm{"}}$}{$\textrm{``price"}'$($v$)}}),
                        $\langle\mathrm{par}\rangle\rangle$} \\
                      \tfield{scope}{$\langle\lambda v_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}(\smallrecord{\smalltfield{e-time}{\textit{Time}}
                                                                     \\
                            \smalltfield{tns}{$\langle\lambda
                              v$:\textit{Time} 
(eq($v$,$t$)),$\langle$e-time$\rangle\rangle$} \\
                            \smalltfield{c$_{\textrm{``}\mathrm{rise}\textrm{"}}$}{$\langle\lambda
  v$:\textit{Time}(``rise"$'$($v_1$,$v$)),
  $\langle$e-time$\rangle\rangle$}}), \\ & &
\hspace*{8em}$\langle$par$\rangle\rangle$}}) \\
\hspace*{5em}\textbf{\}}, \\ \hspace*{8em}$\langle$s-event.s-time.start$\rangle\rangle$}{$^\sigma$\textit{RecType}}
                                                             }}}
\end{quote}


In this type the predicates corresponding to ``price'' and ``rises''
have a frame as an argument where those corresponding to ``woman'' and
``runs'' have an individual thus preventing the offending inference
concerning price discussed on p. \pageref{pg:temppuzzle}.

\subsubsection{Type-theoretic inferences related to frames}  
Suppose that \textbf{\textit{apr}} is an object of the above type
corresponding to ``a price rises''.  Then \textbf{\textit{apr}}.cnt is
a vacuous function from sequences of individuals to a record type --
vacuous because the utterance does not contain any free occurrences of
pronouns.  If $\sigma$ is an arbitrary sequence of individuals then
\textbf{\textit{apr}}.cnt($\sigma$) is the record type
\begin{quote}
\record{\tfield{par}{\smallrecord{\smalltfield{x}{\textit{Ind}}}}
  \\
        \tfield{restr}{$\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}}(\smallrecord{\smalltfield{c$_{\textrm{``}\mathrm{price}\textrm{"}}$}{$\textrm{``price"}'$($v$)}}),
                        $\langle\mathrm{par}\rangle\rangle$} \\
                      \tfield{scope}{$\langle\lambda v_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}(\smallrecord{\smalltfield{e-time}{\textit{Time}}
                                                                     \\
                            \smalltfield{tns}{$\langle\lambda
                              v$:\textit{Time} 
(eq($v$,$t$)),$\langle$e-time$\rangle\rangle$} \\
                            \smalltfield{c$_{\textrm{``}\mathrm{rise}\textrm{"}}$}{$\langle\lambda
  v$:\textit{Time}(``rise"$'$($v_1$,$v$)),
  $\langle$e-time$\rangle\rangle$}}), \\ & &
\hspace*{8em}$\langle$par$\rangle\rangle$}}
\end{quote} 
where $t$ is the start-time of the utterance.  This type represents
the ``proposition expressed by the utterance \textbf{\textit{apr}}''.
What it would mean for the utterance to be true is that this type is
non-empty.  An object of this type is a record containing a frame, in the sense we
introduce on p. \pageref{pg:frame}ff, in its par field. This follows
because of the constraint in the restr field which requires that there
be a proof that the predicate ``price''$'$ hold of the object in the
par field.  By the frame constraint on ``price''$'$ introduced on
p. \pageref{pg:frameconstraints} we know that this frame not only
contains an object in its x field but also contains an event-time and
a commodity.  The object in the x field is constrained to be money and
also to be the price of the commodity at the event-time.  The scope
field of \textbf{\textit{apr}}.cnt($\sigma$) requires that this frame
fall under the ``rise''$'$ predicate at the start time of the
utterance.  By the general predicate constraints introduced on
p. \pageref{pg:predconstraints} we know that a proof of this would be
a pair of frames consisting of the original frame and a frame with the
same commodity but a later time and a higher price.

While the lexical analysis represented by this is rudimentary to say
the least (one feels, for example, that the event time for rising
should be an interval and that rising perhaps involves something more
sophisticated than just the comparison of price at just two time
points), the inclusion of frames does show a potential for including
the kind of account of lexical meaning that many people thought was
missing from classical work on model-theoretic semantics for natural
language.  


\section{Scrap?}

We will define lexical functions which tell us how to construct a type
for a lexical item on the basis of a phonological type and either an
object or a type corresponding to an observation of the world.  The
idea is that an agent which is constructing a grammar for use in a
particular communicative situation will construct lexical types on the
basis of a coordinated pair of observations: an observation of a
speech event and an observation of an object or event with which the
speech event is associated.  This is related to the idea from
situation semantics that meaning
is a relation between an utterance situation and a described situation \cite{BarwisePerry1983}.
The use of types here relates to the idea
of type judgements as being involved in perception as discussed in
section~\ref{sec:basic}.  

We shall use the following notation:
\begin{quote}
If $W$ is a phonological type, then c$_W$ is a distinguished label associated
with $W$, such that if $W_1\not=W_2$ then c$_{W_1}$$\not=$c$_{W_2}$.

% If $W$ is a phonological type then $W'_{\mathit{Arity}}$ is a predicate of arity
% $\mathit{Arity}$.  When $\mathit{Arity}$ is clear from the context we
% suppress it.

% If $W$ is a phonological type then $W'_T$ is an object of type $T$.  When it is
% clear from the context we often suppress $T$.

% necessarily$'_{\langle\mathit{RecType}\rangle}$ is to be the predicate
% `nec'.

\end{quote}

We shall also make use of singleton types.  \textbf{TYPE}$_C$ = $\langle${\bf Type}, {\bf BType},
$\langle$\textbf{PType}, {\bf Pred}, \textbf{ArgIndices}, {\it
  Arity\/}$\rangle$, $\langle A,F\rangle$$\rangle$ \textit{has singleton types} if
\begin{enumerate} 
 
\item for any $T \in \mathbf{Type}$ and $b:_{\mathbf{TYPE_C}}T$, $T_b \in \mathbf{Type}$ 
 
\item for any $T \in \mathbf{Type}$, 
$a:_{\mathbf{TYPE_C}}T_b$ iff
  $a:_{\mathbf{TYPE_C}}T$ and $a=b$
   
 
\end{enumerate}
\noindent In the case of a singleton type $T_x$ we allow a variant
notation in records (corresponding to the manifest fields of Coquand
et al., 2004) using
\begin{display}
\record{\mfield{$\ell$}{$x$}{$T$}}
\end{display}
\noindent for
\begin{display}
\record{\tfield{$\ell$}{$T_x$}}
\end{display}  

When we have a field
\begin{quote}
\record{\tfield{$\ell$}{$\langle\lambda v_1:T_1\ldots\lambda
    v_n:T_n(T_x), \langle\pi_1\ldots\pi_n\rangle\rangle$}}
\end{quote}
we allow for convenience notations such as
\begin{quote}
\record{\mfield{$\ell$}{$\langle\lambda v_1:T_1\ldots\lambda
    v_n:T_n\textbf{\{}x\textbf{\}}, \langle\pi_1\ldots\pi_n\rangle\rangle$}{$T$}}

\record{\mfield{$\ell$}{$x$}{$\langle\lambda v_1:T_1\ldots\lambda
    v_n:T_n(T), \langle\pi_1\ldots\pi_n\rangle\rangle$}}
\end{quote}
or
\begin{quote}
\hspace*{-1em}\smallrecord{\smallmfield{$\ell$}{$\langle\lambda v_1:T_1\ldots\lambda
    v_n:T_n\textbf{\{}x\textbf{\}}, \langle\pi_1\ldots\pi_n\rangle\rangle$}{$\langle\lambda v_1:T_1\ldots\lambda
    v_n:T_n(T), \langle\pi_1\ldots\pi_n\rangle\rangle$}}
\end{quote}
depending on how $T_x$ depends on $\pi_1\ldots\pi_n$.  We use
\textbf{\{} and \textbf{\}} to delimit $x$ since $x$ itself may be a
function thus leading to ambiguity in the notation if we do not
distinguish which $\lambda$'s represent dependency and which belong to
the resulting object.  Note that this ambiguity only arises in the
notation we are adopting for convenience.

\subsubsection{Proper names}

The most straightforward view of proper names is that they are based
on pairings of proper noun utterances and individuals.  While the full
story about proper names may have to be more complex, this will
suffice for our present purposes.

We define a function lex$_{\mathrm{n}_\mathrm{Prop}}$  which maps
 phonological types corresponding to proper names like
\textit{Sam} and individuals to record types, such that if $W$ is
a phonological type such as ``Sam'' or ``John'' and $a$:\textit{Ind},
lex$_{\mathrm{n}_\mathrm{Prop}}$($W,a$) is
\begin{quote}
\textit{Sign} \d{$\wedge$} \\
\record{\tfield{s-event}{\record{\tfield{phon}{\textit{W}}}} \\
        \tfield{synsem}{\record{\mfield{cat}{n$_{\mathrm{Prop}}$}{\textit{Cat}} \\
                                \mfield{cnt}{$\lambda
                                  v$:\textit{Ppty}($v$(\smallrecord{\field{x}{$a$}}))}{\textit{Quant}}}}}
\end{quote}

\noindent The idea of this function is that an agent could have it as a resource
to construct a lexical item for a local language on observing a
pairing of a particular type of utterance (e.g. utterances of
\textit{Sam}) and a particular individual. If the language we are building is small enough there will
be only one individual associated with a given phonological type such
as ``sam'' but it is easy to imagine situations where there will be a
need to have different individuals associated with the same name even
within a local language, for example, if you need to talk about two
people named \textit{Sam} who write a book together.  While this
creates potential for misunderstanding there is nothing technically
mysterious about having two lexical types which happen to share the
same phonology.  This is in contrast to the classical formal semantics
view of proper names as related to logical constants where it seems
unexpected that proper nouns should be able to refer to different
individuals on different uses. 

An example of a set of basic proper names which could be generated
with these resources given two individuals $a$ and $b$ (that is,
$a,b$:\textit{Ind}) would be
\begin{quote}
\begin{tabbing}
\{\=lex$_{\mathrm{n}_\mathrm{Prop}}$(``Sam'',$a$), \\
\>lex$_{\mathrm{n}_\mathrm{Prop}}$(``John'',$b$)\}
\end{tabbing}

\end{quote}



\subsubsection{Intransitive verbs}\label{pg:lexicon-iv}

For intransitive verbs we will take the paired observations to involve
a phonological type corresponding to an intransitive verb on the one
hand and a predicate on the other.  Philosophically, it may appear
harder to explain what it means to observe a predicate compared to
observing an individual, even though if you dig deep enough even
individuals are problematical.  However, it seems that any reasonable
theory of perception should account for the fact that we perceive the
world in terms of various kinds of objects standing in relations to
each other.  Our predicates correspond to these relations and we would
want to say that our cognitive apparatus is such that relations are
reified in a way that they need to be in order to become associated
with types of utterances.  For a verb like \textit{run} we will say
that the predicate is one that holds between individuals and time
intervals.  We will argue in section~\ref{sec:partee-puzzle} that for
other verbs we need frames instead of individuals.

We define a function lex$_{\mathrm{V_{\mathrm{i}}}}$ which maps phonological types corresponding to intransitive verbs like
\textit{run} and predicates with arity
$\langle$\textit{Ind},\textit{TimeInt}$\rangle$, such that if $W$ is
a phonological type like ``run'' or ``walk'' and $p$ is a predicate with arity $\langle$\textit{Ind},\textit{TimeInt}$\rangle$,
lex$_{\mathrm{V_{\mathrm{i}}}}$($W,p$) is
\begin{quote}
\hspace*{-2em}\textit{Sign} \d{$\wedge$} \\
\hspace*{-2em}\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{$W$}}}} \\
        \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{v$_{\mathrm{i}}$}{\textit{Cat}} \\
                                \smallmfield{cnt}{$\lambda
                                  r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
                                  (\smallrecord{\smalltfield{e-time}{\textit{TimeInt}}
                                    \\
                                           \smalltfield{c$_W$}{$\langle\lambda
                                             v$:\textit{TimeInt}($p$($r$.x,$v$), $\langle$e-time$\rangle\rangle$}}))}{\textit{Ppty}}}}}

\end{quote}

Similar remarks hold for this function as for the one we used for
proper names.  For different local languages different predicates may
be associated with utterances of \textit{run} and even within the same
local language, confusing though it may be, we may need to associate
different predicates with different occurrences of \textit{run}.  In
this way verbs are like proper names and one can think of verbs as
proper names of predicates.

However, this is not quite enough if we want to handle different forms
of verbs such as infinitives, and present and past tenses.  For purposes
of simplification as our concern is not with the details of
morphological types we will assume that all finite verb occurrences are third person
singular and will not represent these features.  In order to
achieve this we need to define lex$_{\mathrm{V_{\mathrm{i}}}}$ not in
terms of a single phonological type but a paradigm of phonological
types corresponding to different configurations of morphological
features.  For present purposes we will think of there just being one
morphological feature of tense which can take the values: inf
(``infinitive''), pres (``present tense''), past (``past tense'').  We
will think of paradigms as functions which map records of type
\smallrecord{\smalltfield{tns}{\textit{Tns}}} to phonological types.
  Here the type \textit{Tns} has elements inf, pres and past.  Let
  \textbf{\textsf{run}} be the paradigm for \textit{run}. The function
  is defined by
\begin{quote}
\textbf{\textsf{run}}(\smallrecord{\field{tns}{inf}})= ``run'' \\
\textbf{\textsf{run}}(\smallrecord{\field{tns}{pres}})= ``runs'' \\
\textbf{\textsf{run}}(\smallrecord{\field{tns}{past}})= ``ran''
\end{quote}
and for \textit{walk} we have
\begin{quote}
\textbf{\textsf{walk}}(\smallrecord{\field{tns}{inf}})= ``walk'' \\
\textbf{\textsf{walk}}(\smallrecord{\field{tns}{pres}})= ``walks'' \\
\textbf{\textsf{walk}}(\smallrecord{\field{tns}{past}})= ``walked''
\end{quote}

In order to obtain the interpretations of the tensed forms of the verb
we will need the following functions for present and past tense.
\begin{description}

\item[Pres] which is to be $\lambda
  t$:\textit{TimeInt}(\smallrecord{\smalltfield{e-time}{\textit{TimeInt}}
    \\
                                \smalltfield{tns}{$\langle\lambda
                                  v$:\textit{TimeInt}($v=t$), $\langle$e-time$\rangle\rangle$}})

\item[Past] which is to be $\lambda
  t$:\textit{TimeInt}(\smallrecord{\smalltfield{e-time}{\textit{TimeInt}}
    \\
                                \smalltfield{tns}{$\langle\lambda
                                  v$:\textit{TimeInt}($v$.end$<t$.start),$\langle$e-time$\rangle\rangle$}})

\end{description}
\noindent The present tense function expresses that the event time is
identical with the interval to which it is being compared. This is normally
the speech time as in the grammar defined here, though it could also
be a different time interval, for example in the interpretation of
historic presents.  The past tense function expresses that the end of
the event time interval has to be prior to the start of the interval
(e.g. the speech time) with which it is being compared.

We need also to make the distinction between finite and non-finite
verb utterances and we will do this by introducing a field labelled
`fin' which will take values in the type \textit{Bool} (``boolean'')
whose members are 0 and 1.

Now we redefine lex$_{\mathrm{V_{\mathrm{i}}}}$ to be a function which
takes a paradigm $\mathcal{W}$ such as \textbf{\textsf{run}} or \textbf{\textsf{walk}}, a
predicate $p$ with arity
$\langle$\textit{Ind},\textit{TimeInt}$\rangle$ and morphological
record $m$ of type \smallrecord{\smalltfield{tns}{\textit{Tns}}} such
that 

\begin{enumerate} 
 
\item if $m$ is \smallrecord{\field{tns}{inf}},
  lex$_{\mathrm{V_{\mathrm{i}}}}(\mathcal{W},p,m)$ is 

\hspace*{-2em}\textit{Sign} \d{$\wedge$} \\
\hspace*{-2em}\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{$\mathcal{W}(m)$}}} \\
        \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{v$_{\mathrm{i}}$}{\textit{Cat}}
            \\
\smallmfield{fin}{0}{\textit{Bool}} \\
                                \smallmfield{cnt}{$\lambda
                                  r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
                                  (\smallrecord{\smalltfield{e-time}{\textit{TimeInt}}
                                    \\
                                           \smalltfield{c$_{\mathcal{W}(m)}$}{$\langle\lambda
                                             v$:\textit{TimeInt}($p$($r$.x,$v$)), $\langle$e-time$\rangle\rangle$}})}{\textit{Ppty}}}}}

 
\item  if $m$ is \smallrecord{\field{tns}{pres}},
  lex$_{\mathrm{V_{\mathrm{i}}}}(\mathcal{W},p,m)$ is 

\hspace*{-2em}\textit{Sign} \d{$\wedge$} \\
\hspace*{-2em}\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{$\mathcal{W}(m)$}
    \\
\smalltfield{s-time}{\textit{TimeInt}}}} \\
        \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{v$_{\mathrm{i}}$}{\textit{Cat}}
            \\
\smallmfield{fin}{1}{\textit{Bool}} \\
                                \smallmfield{cnt}{$\langle\lambda v_1$:\textit{Time}\textbf{\{}$\lambda
                                  r$:\smallrecord{\smalltfield{x}{\textit{Ind}}} \\
                                  \hspace*{4em}(\smallrecord{\smalltfield{e-time}{\textit{TimeInt}}
                                    \\
                                           \smalltfield{c$_{\mathcal{W}(m)}$}{$\langle\lambda
                                             v_2$:\textit{TimeInt}($p$($r$.x,$v_2$)),
                                             $\langle$e-time$\rangle\rangle$}}\d{$\wedge$}\textbf{Pres}($v_1$))\textbf{\}}, \\
                                       \hspace*{20em}$\langle$s-event.s-time$\rangle\rangle$}{\textit{Ppty}}}}}

\item if $m$ is \smallrecord{\field{tns}{past}},
  lex$_{\mathrm{V_{\mathrm{i}}}}(\mathcal{W},p,m)$ is 

\hspace*{-2em}\textit{Sign} \d{$\wedge$} \\
\hspace*{-2em}\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{$\mathcal{W}(m)$}
    \\
\smalltfield{s-time}{\textit{TimeInt}}}} \\
        \smalltfield{synsem}{\smallrecord{\smallmfield{cat}{v$_{\mathrm{i}}$}{\textit{Cat}}
            \\
\smallmfield{fin}{1}{\textit{Bool}} \\
                                \smallmfield{cnt}{$\langle\lambda v_1$:\textit{Time}\textbf{\{}$\lambda
                                  r$:\smallrecord{\smalltfield{x}{\textit{Ind}}} \\
                                  \hspace*{4em}(\smallrecord{\smalltfield{e-time}{\textit{TimeInt}}
                                    \\
                                           \smalltfield{c$_{\mathcal{W}(m)}$}{$\langle\lambda
                                             v_2$:\textit{TimeInt}($p$($r$.x,$v_2$)),
                                             $\langle$e-time$\rangle\rangle$}}\d{$\wedge$}\textbf{Past}($v_1$))\textbf{\}}, \\
                                       \hspace*{20em}$\langle$s-event.s-time$\rangle\rangle$}{\textit{Ppty}}}}}

 
\end{enumerate}

An example of a set of intransitive verbs which could be generated
with these resources given appropriate predicates `run' and `walk' is
\begin{quote}
\begin{tabbing}
$\bigcup_{\alpha\in\{\textrm{inf,pres,past}\}}$\{\=lex$_{\mathrm{V_{\mathrm{i}}}}$(\textbf{\textsf{run}},run,\smallrecord{\field{tns}{$\alpha$}}),
\\
\>
lex$_{\mathrm{V_{\mathrm{i}}}}$(\textbf{\textsf{walk}},walk,\smallrecord{\field{tns}{$\alpha$}})\}
\end{tabbing}
\end{quote} 
  

 

\subsection*{Syntactic and semantic composition}

We will think of composition rules as functions which take a string of
utterances of various types and return a type for the whole string.
That is, the basic form of our composition rules will be:
\begin{quote}
$\lambda s:T_1(T_2)$
\end{quote}
where $T_1$ is a type of strings of signs and $T_2$ is a type of
signs.  More specifically we can say that \textit{unary} rules are
functions of the form
\begin{quote}
$\lambda s:T_1(T_2)$, where $T_1,T_2\sqsubseteq$\textit{Sign}
\end{quote}
and \textit{binary} rules are of the form
\begin{quote}
$\lambda s:T_1^{\frown}T_2(T_3)$, where $T_1,T_2,T_3\sqsubseteq$\textit{Sign} 
\end{quote}
\noindent `$\sqsubseteq$' here denotes the subtype relation defined in
section~\ref{sec:modal}.  (We are suppressing the subscript used
there.)  We can, of course, generalize these notions to $n$-ary rules
but unary and binary will be sufficient for our present purposes.

Note that to say that there is a string of signs $s_1^{\frown}s_2$ does not necessarily mean that
the signs are temporally ordered in the sense that
$s_1$.s-event.s-time.end $<$ $s_2$.s-event.s-time.start.  There could
be an advantage in this for the treatment of discontinuous
constituents or free word order.  But we can also define a special
``temporal concatenation'' type for concatenation of signs:

\begin{quote}
A system of complex types \textbf{TYPE}$_C$ = $\langle${\bf Type}, {\bf BType},
$\langle$\textbf{PType}, {\bf Pred}, \textbf{ArgIndices}, {\it
  Arity\/}$\rangle$, $\langle A,F\rangle$$\rangle$ \textit{has
  temporal concatenation types for the type Sign} if 
\begin{enumerate} 
 
\item for any $T_1$, $T_2$ $\sqsubseteq$ \textit{Sign},  ${T_1}^{\frown_{\mathrm{temp}}}\!T_2$ $\in$ {\bf Type} 
 
\item $s : {T_1}^{\frown_{\mathrm{temp}}}\!T_2$ iff
  $s=s_1^\frown\!s_2$, $s_1:T_1$, $s_2:T_2$ and $s_1$.s-event.s-time.end
  $<$ $s_2$.s-event.s-time.start. 
 
\end{enumerate}

\end{quote}
\noindent 

We will factor our rules into component functions which we will then
combine in order to make a complete rule.  The components we will use
here are:
\begin{description}

\item[\textsf{unary\_sign}] which we define to be
\begin{quote}
$\lambda s$:\textit{Sign}(\textit{Sign})
\end{quote}
\noindent This takes any sign and returns the type \textit{Sign}

\item[\textsf{binary\_sign}] which we define to be
\begin{quote}
$\lambda s$:\textit{Sign}$^{\frown_{\mathrm{temp}}}$\textit{Sign}(\textit{Sign})
\end{quote}
\noindent This takes any temporal concatenation of two signs and returns the type
\textit{Sign}

\item[\textsf{phon\_id}] which we define to be
\begin{quote}
$\lambda
s$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Phon}}}}}(\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{$s$.s-event.phon}{\textit{Phon}}}}})
\end{quote}
\noindent This takes any record $s$ of type
\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Phon}}}}}
and returns a type which is the same except that the phonology field
is now required to be filled by the value of that field in $s$.

\item[\textsf{phon\_concat}] which we define to be
\begin{quote}
$\lambda
s$:\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Phon}}}}}$^{\frown}$\smallrecord{\smalltfield{s-event}{\smallrecord{\smalltfield{phon}{\textit{Phon}}}}}
\\
\hspace*{2em}(\smallrecord{\smalltfield{s-event}{\smallrecord{\smallmfield{phon}{$s[1]$.s-event.phon$^{\frown}s[2]$.s-event.phon}{\textit{Phon}}}}})
\end{quote}
\noindent This takes a string of two records with phonology fields and
returns the type of a single record with a phonology field whose value
is required to be the concatenation of the values of the phonology
fields in the first and second elements of the string.

\item[\textsf{unary\_cat}] which we define to be
\begin{quote}
$\lambda c_1$:\textit{Cat}($\lambda c_2$:\textit{Cat}($\lambda
s$:\smallrecord{\smallmfield{cat}{$c_1$}{\textit{Cat}}}(\smallrecord{\smallmfield{cat}{$c_2$}{\textit{Cat}}})))
\end{quote}
\noindent This takes two categories and returns a function which maps
a record with a category field with value the first category to a type
of records with a category field which is required to be filled by the
second category.

\item[\textsf{binary\_cat}] which we define to be
\begin{quote}
$\lambda c_1$:\textit{Cat}($\lambda c_2$:\textit{Cat}($\lambda c_3$:\textit{Cat}($\lambda
s$:\smallrecord{\smallmfield{cat}{$c_1$}{\textit{Cat}}}$^\frown$\smallrecord{\smallmfield{cat}{$c_2$}{\textit{Cat}}}(\smallrecord{\smallmfield{cat}{$c_3$}{\textit{Cat}}})))
\end{quote}
\noindent This takes three categories and returns a function which maps
a string of two records with a category field with values identical to the respective categories to a type
of records with a category field which is required to be filled by the
third category.



\item[\textsf{cnt\_id}] which we define to be
\begin{quote}
$\lambda
s$:\smallrecord{\smalltfield{synsem}{\smallrecord{\smalltfield{cnt}{\textit{Cnt}}}}}(\smallrecord{\smalltfield{synsem}{\smallrecord{\smallmfield{cnt}{$s$.synsem.cnt}{\textit{Cnt}}}}})
\end{quote}
\noindent This takes any record $s$ of type
\smallrecord{\smalltfield{synsem}{\smallrecord{\smalltfield{cnt}{\textit{Cnt}}}}}
and returns a type which is the same except that the content field
is now required to be filled by the value of that field in $s$.

\item[\textsf{cnt\_forw\_app}] which we define to be
\begin{quote}
$\lambda T_1$:\textit{Type}($\lambda T_2$:\textit{Type}($\lambda
s$:\smallrecord{\smalltfield{synsem}{\smallrecord{\smalltfield{cnt}{$T_1\rightarrow
      T_2$}}}}$^\frown$\smallrecord{\smalltfield{synsem}{\smallrecord{\smalltfield{cnt}{$T_1$}}}}
\\
\hspace*{2em}(\smallrecord{\smalltfield{synsem}{\smallrecord{\smallmfield{cnt}{$s[1]$.synsem.cnt($s[2]$.synsem.cnt)}{$T_2$}}}})
\end{quote}
\noindent This takes any binary string of records $s$ such that the
content of the first record is a function which takes arguments of a
type to which the content of the second record belongs
and returns a type whose content field
is now required to be filled by the result of applying the content of
the first record to the content of the second record.

\item[\textsf{fin\_id}] which we define to be
\begin{quote}
$\lambda s$:\smallrecord{\smalltfield{fin}{\textit{Bool}}}(\smallrecord{\smallmfield{fin}{$s$.fin}{\textit{Bool}}})
\end{quote}
\noindent This requires that the value of a `fin'-field will be copied
into the new type (corresponding to feature percolation in a
non-branching tree in a more traditional feature-based grammar).


\item[\textsf{fin\_hd}] which we define to be
\begin{quote}
$\lambda
s$:\textit{Sign}$^\frown$\smallrecord{\smallmfield{fin}{1}{\textit{Bool}}}(\smallrecord{\smallmfield{fin}{$s$.fin}{\textit{Bool}}})
\end{quote}
\noindent This requires that the second sign in a string of two has a positive
specification for finiteness and copies it into the new type.

\end{description}

We will use the notion of merge defined in section~\ref{sec:merge} in
the characterization of how these component functions are to be
combined in order to form rules.  Since the combination of these
functions is so closely connected to the merge operation we will use
a related symbol `\d{\d{$\wedge$}}' with two dots rather than one.  In
the following definition we will use $T_i$ to represent types which
are not string types and $v$ to represent an arbitrary variable.
\begin{enumerate} 
 
\item $\lambda v$:$T_1(T_2)$ \d{\d{$\wedge$}} $\lambda v$:$T_3(T_4)$
  is to be $\lambda v$:$T_1$\d{$\wedge$}$T_3$($T_2$\d{$\wedge$}$T_4$)
 
\item $\lambda v$:$T_1^{\frown}{T_2}(T_3)$ \d{\d{$\wedge$}} $\lambda
  v$:$T_4^\frown T_5(T_6)$
  is to be $\lambda v$:$(T_1$\d{$\wedge$}$T_4)^\frown (T_2$\d{$\wedge$}$T_5$) ($T_3$\d{$\wedge$}$T_6$) 

\item $\lambda v$:$T_1^{\frown_\mathit{temp}}{T_2}(T_3)$ \d{\d{$\wedge$}} $\lambda
  v$:$T_4^\frown T_5(T_6)$
  is to be $\lambda v$:$(T_1$\d{$\wedge$}$T_4)^{\frown_\mathit{temp}} (T_2$\d{$\wedge$}$T_5$) ($T_3$\d{$\wedge$}$T_6$)  
\end{enumerate}
Since \d{\d{$\wedge$}}, like \d{$\wedge$}, is associative we will
write $f$\d{\d{$\wedge$}}$g$\d{\d{$\wedge$}}$h$ instead of
($f$\d{\d{$\wedge$}}$g$)\d{\d{$\wedge$}}$h$ or
$f$\d{\d{$\wedge$}}($g$\d{\d{$\wedge$}}$h$).

Now we can use the rule components we have defined to express the
three rules we need for this small fragment.
    

\begin{description}

\item[\textsf{S} $\rightarrow$ \textsf{NP VP}] \mbox{} \\
\textsf{binary\_sign} \d{\d{$\wedge$}} \textsf{phon\_concat} \d{\d{$\wedge$}}
\textsf{binary\_cat}(np)(vp)(s) \d{\d{$\wedge$}} \textsf{fin\_hd}\\
\hspace*{5em}\d{\d{$\wedge$}}
\textsf{cnt\_forw\_app}(\textit{Ppty})(\textit{RecType})

\item[\textsf{NP} $\rightarrow$ \textsf{N}] \mbox{} \\
\textsf{unary\_sign} \d{\d{$\wedge$}} \textsf{phon\_id} \d{\d{$\wedge$}}
\textsf{unary\_cat}(n$_{\mathrm{Prop}}$)(np) \d{\d{$\wedge$}} \textsf{cnt\_id}

\item[\textsf{VP} $\rightarrow$ \textsf{V}$_i$] \mbox{} \\
\textsf{unary\_sign} \d{\d{$\wedge$}} \textsf{phon\_id} \d{\d{$\wedge$}}
\textsf{unary\_cat}(v$_i$)(vp) \d{\d{$\wedge$}} \textsf{fin\_id} \d{\d{$\wedge$}} \textsf{cnt\_id}


\end{description}

This gives us a concise way to express rather complex functions
corresponding to simple rules.  The point of this is, however,  not
merely to
give us yet another formalism for expressing natural language phrase
structure and its interpretation but to show how such rules can be
broken down into abstract components which an agent learning the
language could combine in order to create rules which it has not
previously had available in its resources.  Thus an agent (such as a
child in the one-word stage) which does not have a rule \textsf{S}
$\rightarrow$ \textsf{NP VP} but who observes strings of linguistic
events where NP's are followed by VP's may reason its way to a rule
that combine NP-events followed by VP-events into a single event.
While this concerns linguistic events it is closely related to the way
we take strings of non-linguistic events to form single events, for example, a
going-to-bed-event for a child might normally consist of a string of
events
having-hot-milk$^\frown$putting-on-pyjamas$^\frown$getting-into-bed$^\frown$listening-to-a-story.
Our general ability to perceive events, that is, assign types to events and to combine these
types into larger event types seems to be a large part of the basis
for our linguistic ability.  We will return to this in our discussion
of Fernando's string theory of events in section~\ref{sec:events}.
