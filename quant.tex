\chapter{Quantification, anaphora and underspecification}
\label{ch:quant}
\setcounter{equation}{0}

\section{The interpretation of unbound pronouns}
\label{sec:unbound}
We will consider how to recreate a simple interpretation of pronouns
ranging over individuals, first treating them in a similar way to free
variables in logic and then showing how they can be bound by
quantifiers.  The central idea is to use records as \textit{pronominal
  contexts} which correspond to partial assignments to variables in
standard logical treatments.  Consider first a simple sentence with a deictic
pronoun as in \nexteg{}.
\begin{ex} 
he left 
\end{ex} 
In our initial pass we will ignore matters
of gender to make things simpler.  The content of \preveg{} is a type
which depends on a context (a situation) which provides a value of the
pronoun \textit{he}. Thus it will have a parametric content which is a
function from a context assigning a value to the pronoun to a
type.\footnote{We will consider later how to combine types of context
  which assign values to pronouns with other context types which we
  have introduced with parametric contents.}  We will use the variable
`$\mathfrak{s}$' to represent such contexts.  Thus the foreground of a parametric content for
\textit{he} could be that given in \nexteg{a}, for \textit{left}
(ignoring tense) that given in \nexteg{b} and their combination, using a variant
of S-combination which we will discuss as we progress, is represented
in \nexteg{c}.
\begin{ex} 
\begin{subex} 
 
\item $\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}} . 
        $\lambda P$:\textit{Ppty} . $P$(\smallrecord{\field{x}{$\mathfrak{s}$.x$_0$}})
 
\item $\lambda\mathfrak{s}$:\textit{Rec} . 
        $\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . 
              \record{\tfield{e}{leave($r$.x)}}

\item $\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
  . 
         \record{\tfield{e}{leave($\mathfrak{s}$.x$_0$)}}
 
\end{subex} 
   
\end{ex}
We follow Montague's strategy in allowing the content of \textit{he}
to be \nexteg{} for any natural number $i$.
\begin{ex}
$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_i$}{\textit{Ind}}} . 
        $\lambda P$:\textit{Ppty}
        . $P$(\smallrecord{\field{x}{$\mathfrak{s}$.x$_i$}})
\label{ex:pronoun-cont}
\end{ex} 
Thus considering the boy and the dog, a
content for \nexteg{a} will be \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item he hugged it 
 
\item $\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}\\
                                   \smalltfield{x$_1$}{\textit{Ind}}}
                                 . 
\record{\tfield{e}{hug($\mathfrak{s}$.x$_0$, $\mathfrak{s}$.x$_1$)}} 
 
\end{subex} 
   
\end{ex} 
An advantage of using record types to characterize pronominal contexts
rather than variable assignments is that we can add further
information represented by the pronoun such as gender.   Thus a simple
treatment of gender for \preveg{} might be given by making the content
be \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}\\
                             \smalltfield{c$_0$}{male(x$_0$)}\\
                             \smalltfield{x$_1$}{\textit{Ind}}\\
                             \smalltfield{c$_1$}{neuter(x$_1$)}}
                                 . 
\record{\tfield{e}{hug($\mathfrak{s}$.x$_0$, $\mathfrak{s}$.x$_1$)}} 
\end{ex} 
As we will see below, there are some complications with this simple
idea when it comes to the interpretation of pronouns which are bound
by quantifiers.  Even for deictic pronouns there are problems
determining which predicates should be used in a semantic treatment of
gender.  Even for a language like English which apparently has
semantic gender (as opposed to grammatical gender like German or
French), neuter can be used for objects which do not have gender (like
tables) and for animals other than humans which do have gender and
which can be referred to with masculine and feminine pronouns.

\section{Quantifier scope and underspecification}

Given the kind of interpretation rules we have so far we can obtain a
reading for \nexteg{a} which corresponds to the kind of parametric
content foreground using pronominal contexts
in \nexteg{b}, using the abbreviations `boy$'$' and `dog$'$' as
introduced in Chapter~\ref{ch:commonnouns}, example (\ref{ex:dogprime}).
\begin{ex} 
\begin{subex} 
 
\item a boy hugged every dog 
 
\item $\lambda \mathfrak{s}$:\textit{Rec} . \smallrecord{\smalltfield{e}{exist(boy$'$, $\lambda
      r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . 
\smallrecord{\smalltfield{e}{every(dog$'$, 
$\lambda r_2$: \smallrecord{\smalltfield{x}{\textit{Ind}}} . 
\smallrecord{\smalltfield{e}{hug($r_1$.x, $r_2$.x)}})}})}}
 
\end{subex} 
   
\end{ex} 
This, of course, represents the reading where there is a boy such that
he hugs every dog.  Notice that here we have vacuous abstraction over
pronominal contexts and the constraint on them is that they are a record of
some kind without requiring any particular fields.    

In order to obtain the reading where \textit{every dog} has wide
scope, we follow Montague and pretty much everybody else in basing our
treatment of quantifier scope on the treatment of free pronouns,
though without the contribution of any gender information.  Let us
imagine just for a moment that such a pronoun existed in English and
is written as \textit{it$^*$} with the kind of pronoun interpretations
given in (\ref{ex:pronoun-cont}).  Then the content for \nexteg{a} could be
\nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item a boy hugged it$^*$
 
\item $\lambda \mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}} . 
\smallrecord{\smalltfield{e}{exist(boy$'$, $\lambda
    r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
    . \smallrecord{\smalltfield{e}{hug($r$.x, $\mathfrak{s}$.x$_0$)}})}} 
 
\end{subex} 
   
\end{ex}
Let us further imagine, contrary to fact, that English represented the fact
that a noun phrase has wide scope over a sentence by placing it at the
beginning of a sentence as in \nexteg{a} and giving it an
interpretation where the interpretation of \textit{it$^*$} gets bound
as in \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item every dog, a boy hugged it$^*$ 
 
\item $\lambda\mathfrak{s}$:\textit{Rec} . 
\smallrecord{\smalltfield{e}{every(dog$'$,
$\lambda r_1$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}} . 
\smallrecord{\smalltfield{e}{exist(boy$'$, $\lambda
    r_2$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
    . \smallrecord{\smalltfield{e}{hug($r_2$.x, $r_1$.x$_0$)}})}})}} 
 
\end{subex} 
\label{ex:edabhi}   
\end{ex} 
The imaginary English expression \preveg{a} corresponds quite closely
to the kind of representation for wide scope readings that are used in
various theories of logical form.  A major difference is that in
logical form there is an index corresponding to the label `x$_0$' that
we use in the interpretation which shows that \textit{every dog} binds
\textit{it$^*$}.  This might be represented something like in
\nexteg{}.
\begin{ex} 
every dog$_{x_0}$, a boy hugged it$^*_{x_0}$ 
\end{ex} 
The imaginary sentence (\ref{ex:edabhi}a) also corresponds closely to
Montague's (\citeyear{Montague1973}) treatment of scope phenomena.
Montague would also index the pronoun and use a quantification rule
with the same index which would replace the pronoun with the
noun-phrase being quantified in.

Neither of these options are open to us since our syntax is defined in
terms of types of utterance situations and signs which relate
utterance situations to contents.  Our realistic strategy does not
allow for the use of additional imaginary utterance structures.  For this reason
we will adapt the kind of storage technique used in \cite{Cooper1983}.
In the original version of storage we moved from assigning a
single content to a syntactic structure to assigning a set of contents
in order to allow for the ambiguous interpretation of a single
syntactic structure.  In our sign-based approach using types the
corresponding move is not such a major change and the result yields a
theory involving underspecified content rather than a set of contents.

To see this consider the type \textit{Sign} introduced in
Chapter~\ref{ch:gram}.  Any object of type \textit{Sign} will be of
the type in \nexteg{}.
\begin{ex} 
\record{\tfield{s-event}{\textit{SEvent}} \\
         \tfield{syn}{\textit{Syn}} \\
        \tfield{cont}{\textit{Cont}}}  
\end{ex} 
The type in \preveg{} is completely underspecified.  Any sign will be
of this type.  We could specify it with respect to content by making
the `cont'-field be a manifest field as in \nexteg{b}, where $c$ is as
given in \nexteg{a}.
\begin{ex} 
\begin{subex} 
 
\item $c$ = \smallrecord{\smalltfield{e}{exist(boy$'$, $\lambda
      r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
        . \smallrecord{\smalltfield{e}{every(dog$'$, $\lambda
            r_2$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
              . \smallrecord{\smalltfield{e}{hug($r_1$.x, $r_2$.x)}})}})}}
 
\item  \record{\tfield{s-event}{\textit{SEvent}} \\
         \tfield{syn}{\textit{Syn}} \\
        \mfield{cont}{$c$}{\textit{Cont}}}  
 
\end{subex} 
   
\end{ex} 
Now recall that the manifest field
\smallrecord{\smallmfield{cont}{$c$}{\textit{Cont}}} is just a
convenient way of writing
\smallrecord{\smalltfield{cont}{\textit{Cont}$_c$}} where
\textit{Cont}$_c$ is a singleton type whose only witness is $c$.  It
is in this sense that the content has been specified to be $c$.
Suppose now that we do not have enough information to fully specify
the content, that is, tie it down to be one particular content, but we
know that it has to be one of either $c$ or $c'$ (as characterized in
\nexteg{a}).  This could be represented by using a join type of two
singleton types, \textit{Cont}$_c$$\vee$\textit{Cont}$_{c'}$, as in
\nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item $c'$ =  \smallrecord{\smalltfield{e}{every(dog$'$, $\lambda
      r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
        . \smallrecord{\smalltfield{e}{exist(boy$'$, $\lambda
            r_2$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
              . \smallrecord{\smalltfield{e}{hug($r_2$.x, $r_1$.x)}})}})}}
 
\item  \record{\tfield{s-event}{\textit{SEvent}} \\
         \tfield{syn}{\textit{Syn}} \\
        \tfield{cont}{\textit{Cont}$_c$$\vee$\textit{Cont}$_{c'}$}}  
 
\end{subex} 
   
\end{ex} 
\preveg{} is the type of signs whose contents are either $c$ or $c'$.
This is, then, a single type, which corresponds to an ``underspecified
content''.  Of course, the set of witnesses of the join type,
$\{c,c'\}$, corresponds to the set of contents that could be generated
by a storage algorithm.  Our strategy, then, is to devise a way of
computing such types on the basis of compositional interpretation.     
Notice that saying that the content is of type
\textit{Cont}$_c$$\vee$\textit{Cont}$_{c'}$, that is, that it is
either $c$ or $c'$ is distinct from saying that the content is the
disjunction of $c$ and $c'$, that is, if $c$ and $c'$ are types, the
type $c\vee c'$.  The witnesses for $c\vee c'$ will be situations $s$
such that either $s:c$ or $s:c'$ whereas the witness for
\textit{Cont}$_c$$\vee$\textit{Cont}$_{c'}$ will be the contents $c$
and $c'$.  This will make an important different in compositional
interpretation.  For example, if a sentence $S$ has a content of type     
\textit{Cont}$_c$$\vee$\textit{Cont}$_{c'}$ we would want to say that
the sentence \textit{Sam believes $S$} has a content of type
\textit{Cont}$_{believe(sam,c)}$$\vee$\textit{Cont}$_{believe(sam,c')}$
rather than that it has the content `believe(sam,$c\vee c'$)'.

In order to make the relationship between sets of contents and join
types smoother we will use generalized join types
(Appendix~\ref{app:jointypes}).  Suppose we have computed a set of
possible contents, $\{c_1,\ldots,c_n\}$, for a phrase, then the type
of the content for that phrase is
$\bigvee\{\textit{Cont}_{c_1},\ldots,\textit{Cont}_{c_n}\}$.  If
$\mathbb{C}$ represents the set of contents we have computed, we can
use the more convenient notation
$\displaystyle{\bigvee_{c\in\mathbb{C}}}\textit{Cont}_c$ to mean
$\bigvee\{\textit{Cont}_c\mid c\in\mathbb{C}\}$.

We will take content now to be divided into two fields labelled
`unplugged' and `plugged'.  This terminology goes back to
\cite{Bos1996}.  The `unplugged'-field contains a set of unplugged
interpretations consisting of a set of parametric quantifiers
(possibly empty) and a core interpretation consisting of a parametric
content.  Thus we define a type \textit{UInterp} of unplugged
interpretations as in \nexteg{}.
\begin{ex} 
\textit{UInterp} = \record{\tfield{quants}{\{\textit{PQuant}\}}\\
                           \tfield{core}{\textit{PCont}}}
\end{ex} 
The `cont'-field in a sign will now be required to be of the type in
\nexteg{}.
\begin{ex} 
\record{\tfield{unplugged}{\{\textit{UInterp}\}}\\
        \tfield{plugged}{$\displaystyle{\bigvee_{c\in\mathrm{unplugged},\
              c.\mathrm{quants}=\emptyset}\textit{Cont}_{c.\mathrm{core}}}$}}
\end{ex} 
That is, the `unplugged'-field in the content will contain a set of
unplugged interpretations (consisting of a quantifier store, possibly empty, and a core
interpretation) and the `plugged'-field will contain one of the cores
of those unplugged interpretations whose quantifier store is
empty.

Let us consider what this will look like for the example \textit{every
  boy wants a dog} using \textit{every}$'$, \textit{boy}$'$ etc. as
abbreviations for non-parametric contents for these words.  We show
the `cont'-field of the sign type associated with constituents of this
sentence.
\begin{ex} 
\begin{subex} 
 
\item a dog 
 
\item
  \smallrecord{\smallmfield{unplugged}{\{\smallrecord{\field{quants}{$\emptyset$}\\
                                            \field{core}{\smallrecord{\field{bg}{\textit{Rec}}\\
                                                                      \field{fg}{$\lambda\mathfrak{s}$:\textit{Rec}
                                                                        . \textit{a}$'$(\textit{dog}$'$)}}}}, \\
   \hspace*{5em}                            \smallrecord{\field{quants}{\{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}} \\
                                                                          \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
                                                                            . \textit{a}$'$(\textit{dog}$'$)}}\}} \\
                                            \field{core}{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}}
                                                \\
                                                                      \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
                                                                        . $\lambda
                                                                        P$:\textit{Ppty}
                                                                        . $P(\mathfrak{s}.\textrm{x}_0)$}}}}\}} {\{\textit{UInterp}\}}
                                                            \\
          \smalltfield{plugged}{\textit{Cont}$_{\text{\smallrecord{\field{bg}{\textit{Rec}}\\
                                                                      \field{fg}{$\lambda\mathfrak{s}$:\textit{Rec}
                                                                        . \textit{a}$'$(\textit{dog}$'$)}}}}$}}
 
\end{subex} 
   
\end{ex} 
\begin{ex} 
\begin{subex} 
 
\item want a dog 
 
\item
  \smallrecord{\smallmfield{unplugged}{\{\smallrecord{\field{quants}{$\emptyset$}\\
                                            \field{core}{\smallrecord{\field{bg}{\textit{Rec}}\\
                                                                      \field{fg}{$\lambda\mathfrak{s}$:\textit{Rec}
                                                                        . \textit{want}$'$(\textit{a}$'$(\textit{dog}$'$))}}}}, \\
   \hspace*{5em}                            \smallrecord{\field{quants}{\{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}} \\
                                                                          \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
                                                                            . \textit{a}$'$(\textit{dog}$'$)}}\}} \\
                                            \field{core}{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}}
                                                \\
                                                                      \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
                                                                        . \textit{want}$'$($\lambda
                                                                        P$:\textit{Ppty}
                                                                        . $P(\mathfrak{s}.\textrm{x}_0)$)}}}}\}} {\{\textit{UInterp}\}}
                                                            \\
          \smalltfield{plugged}{\textit{Cont}$_{\text{\smallrecord{\field{bg}{\textit{Rec}}\\
                                                                      \field{fg}{$\lambda\mathfrak{s}$:\textit{Rec}
                                                                        . \textit{want}(\textit{a}$'$(\textit{dog}$'$))}}}}$}}
 
\end{subex} 
   
\end{ex} 

\begin{ex} 
\begin{subex} 
 
\item every boy 
 
\item
  \smallrecord{\smallmfield{unplugged}{\{\smallrecord{\field{quants}{$\emptyset$}\\
                                            \field{core}{\smallrecord{\field{bg}{\textit{Rec}}\\
                                                                      \field{fg}{$\lambda\mathfrak{s}$:\textit{Rec}
                                                                        . \textit{every}$'$(\textit{boy}$'$)}}}}, \\
   \hspace*{5em}                            \smallrecord{\field{quants}{\{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}} \\
                                                                          \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
                                                                            . \textit{every}$'$(\textit{boy}$'$)}}\}} \\
                                            \field{core}{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}}
                                                \\
                                                                      \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
                                                                        . $\lambda
                                                                        P$:\textit{Ppty}
                                                                        . $P(\mathfrak{s}.\textrm{x}_0)$}}}}\}} {\{\textit{UInterp}\}}
                                                            \\
          \smalltfield{plugged}{\textit{Cont}$_{\text{\smallrecord{\field{bg}{\textit{Rec}}\\
                                                                      \field{fg}{$\lambda\mathfrak{s}$:\textit{Rec}
                                                                        . \textit{every}$'$(\textit{boy}$'$)}}}}$}}
 
\end{subex} 
   
\end{ex} 
    
\begin{ex} 
\begin{subex} 
 
\item every boy wants a dog 
 
\item
% \newsavebox{\test}
% \sbox\test{\begin{tabular}{l}a,\\b\end{tabular}}
% \usebox{\test}

% \newsavebox{\unplugged}
% \sbox\unplugged{$\left\{ \text{\begin{tabular}{l}\usebox{\unpluggeda},\\
%                                     \usebox{\unpluggedb},\\
%                                     \usebox{\unpluggedc},\\
%                                     \usebox{\unpluggedd},\\
%                                     \usebox{\unpluggede},\\
%                                     \usebox{\unpluggedf},\\
%                                     \usebox{\unpluggedg}
%                   \end{tabular}}\right\}$}

\newsavebox{\plugged}
\sbox\plugged{$\displaystyle{\bigvee_{c\in\mathbb{C}_{\mathrm{plugged}}}\textit{Cont}_c}$}
                              

\smallrecord{\smallmfield{unplugged}{$\mathbb{C}_{\mathrm{unplugged}}$}{\{\textit{UInterp}\}}\\
             \smalltfield{plugged}{\usebox{\plugged}}}

 
\end{subex} 
   
\end{ex} 
where $\mathbb{C}_{\mathrm{unplugged}}$ is the set whose members are
listed in \nexteg{} and $\mathbb{C}_{\mathrm{plugged}}$ is the set
whose members are listed in (\ref{ex:plugged}).
\newsavebox{\unpluggeda}
\sbox\unpluggeda{\smallrecord{\field{quants}{$\emptyset$}\\
                                                       \field{core}{\smallrecord{\field{bg}{\textit{Rec}}\\
                                                                                 \field{fg}{$\lambda\mathfrak{s}$:\textit{Rec}
                                                                         . \textit{every}$'$(\textit{boy}$'$)(\textit{want}$'$(\textit{a}$'$(\textit{dog}$'$)))}}}}}

\newsavebox{\unpluggedb}
\sbox\unpluggedb{\smallrecord{\field{quants}{\{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}} \\
                                                                           \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
                                                                            . \textit{every}$'$(\textit{boy}$'$)}}\}} \\
                                            \field{core}{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}}
                                                \\
                                                                      \field{fg}{\begin{tabular}{l}$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
                                                                        . \\
                                                                                   \hspace*{1em}$\lambda
                                                                        P$:\textit{Ppty}
                                                                        . \\
                                                                                   \hspace*{2em}$P(\mathfrak{s}.\textrm{x}_0)$(\textit{want}$'$(\textit{a}$'$(\textit{dog}$'$)))\end{tabular}}}}}}

\newsavebox{\unpluggedc}
\sbox\unpluggedc{\smallrecord{\field{quants}{\{\begin{tabular}{l}\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}} \\
                                                                          \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
                                                                            . \textit{every}$'$(\textit{boy}$'$)}}, \\
                                                                        \smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}} \\
                                                                          \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
                                                                            . \textit{a}$'$(\textit{dog}$'$)}}\end{tabular}\}} \\
                                            \field{core}{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}\\
                                                                                              \smalltfield{x$_1$}{\textit{Ind}}}}
                                                \\
                                                                      \field{fg}{\begin{tabular}{l}$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}} \\
                                                                                                                \smalltfield{x$_1$}{\textit{Ind}}}
                                                                        . \\
                                                                                                       \hspace*{1em}$\lambda
                                                                        P$:\textit{Ppty}
                                                                        . \\
                                                                                   \hspace*{2em}$P(\mathfrak{s}.\textrm{x}_0)$(\textit{want}$'$($\lambda
                                                                                   P$:\textit{Ppty}
                                                                                   .
                                                                                   $P(\mathfrak{s}.\textrm{x}_1)$))\end{tabular}}}}}}

\newsavebox{\unpluggedd}
\sbox\unpluggedd{\smallrecord{\field{quants}{\{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}} \\
                                                                          \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
                                                                            . \textit{a}$'$(\textit{dog}$'$)}}\}} \\
                                            \field{core}{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}}
                                                \\
                                                                      \field{fg}{\begin{tabular}{l}$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
                                                                        . \\
                                                                                   \hspace*{1em}\textit{every}$'$(\textit{boy}$'$) \\ 
\hspace*{2em}($\lambda
   r$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}} . \\
   \hspace*{3em}$\lambda P$:\textit{Ppty} .  $P$($r$.x$_0$)\\
                                                                                   \hspace*{4em}(\textit{want}$'$\\ \hspace*{5em}($\lambda
                                                                        P$:\textit{Ppty}
                                                                        .
                                                                                
$P(\mathfrak{s}.\textrm{x}_1)$)))\end{tabular}}}}}}

\newsavebox{\unpluggede}
\sbox\unpluggede{\smallrecord{\field{quants}{\{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}} \\
                                                                          \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
                                                                            . \textit{every}$'$(\textit{boy}$'$)}}\}} \\
                                            \field{core}{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}}
                                                \\
                                                                      \field{fg}{\begin{tabular}{l}$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
                                                                        . \\
                                                                                   \hspace*{1em}\textit{a}$'$(\textit{dog}$'$)\\
                                                                                   \hspace*{2em}($\lambda
                                                                        r$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
                                                                          . \\
                                                                                   \hspace*{3em}$\lambda
                                                                          P$:\textit{Ppty}
                                                                          . \\
                                                                                   \hspace*{4em}$P$($r$.x$_1$)\\
                                                                                   \hspace*{5em}(\textit{want}$'$($\lambda
                                                                        P$:\textit{Ppty}
                                                                        . $P(\mathfrak{s}.\textrm{x}_0)$))})\end{tabular}}}}}

\newsavebox{\unpluggedf}
\sbox\unpluggedf{\smallrecord{\field{quants}{\{\}}\\
                              \field{core}{\smallrecord{\field{bg}{\textit{Rec}}\\
                                                        \field{fg}{\begin{tabular}{l}
                                                                    $\lambda\mathfrak{s}$:\textit{Rec}
                                                                     \\
                                                                    \hspace*{1em}\textit{a}$'$(\textit{dog}$'$)
                                                                      \\
                                                                    \hspace*{2em}($\lambda
                                                                     r_1$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
                                                                     . \\
                                                                    \hspace*{3em}\textit{every}$'$(\textit{boy}$'$)\\
                                                                    \hspace*{4em}($\lambda
                                                                     r_2$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
                                                                     . \\
                                                                    \hspace*{5em}$\lambda
                                                                     P$:\textit{Ppty}
                                                                     . $P$($r_1$.x$_0$)\\
                                                                    \hspace*{6em}\textit{wants}$'$($\lambda
                                                                     P$:\textit{Ppty}
                                                                     . $P$($r_1$.x$_1$))))\end{tabular}}}}}}

\newsavebox{\unpluggedg}
\sbox\unpluggedg{\smallrecord{\field{quants}{\{\}}\\
                              \field{core}{\smallrecord{\field{bg}{\textit{Rec}}\\
                                                        \field{fg}{\begin{tabular}{l}
                                                                    $\lambda\mathfrak{s}$:\textit{Rec}
                                                                     \\
                                                                    \hspace*{1em}\textit{every}$'$(\textit{boy}$'$)
                                                                      \\
                                                                    \hspace*{2em}($\lambda
                                                                     r_1$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
                                                                     . \\
                                                                    \hspace*{3em}\textit{a}$'$(\textit{dog}$'$)\\
                                                                    \hspace*{4em}($\lambda
                                                                     r_2$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
                                                                     . \\
                                                                    \hspace*{5em}$\lambda
                                                                     P$:\textit{Ppty}
                                                                     . $P$($r_1$.x$_0$)\\
                                                                    \hspace*{6em}\textit{wants}$'$($\lambda
                                                                     P$:\textit{Ppty}
                                                                     . $P$($r_1$.x$_1$))))\end{tabular}}}}}}



\begin{ex} 
\begin{subex} 
 
\item \usebox{\unpluggeda} 
 
\item \usebox{\unpluggedb}

\item \usebox{\unpluggedc}

\item \usebox{\unpluggedd}

\item \usebox{\unpluggede}

\item \usebox{\unpluggedf}

\item \usebox{\unpluggedg} 
 
\end{subex} 
   
\end{ex} 

\begin{ex} 
\begin{subex} 
 
\item \smallrecord{\field{bg}{\textit{Rec}}\\
                   \field{fg}{$\lambda\mathfrak{s}$:\textit{Rec} . \textit{every}$'$(\textit{boy}$'$)(\textit{want}$'$(\textit{a}$'$(\textit{dog}$'$)))}}
                               
\item  \smallrecord{\field{bg}{\textit{Rec}}\\
                    \field{fg}{\begin{tabular}{l}
                                    $\lambda\mathfrak{s}$:\textit{Rec}
                                                                     \\
                                      \hspace*{1em}\textit{a}$'$(\textit{dog}$'$)
                                                                      \\
                                      \hspace*{2em}($\lambda
                                                           r_1$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
                                                                     . \\
                                      \hspace*{3em}\textit{every}$'$(\textit{boy}$'$)\\
                                      \hspace*{4em}($\lambda
                                                          r_2$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
                                                                     . \\
                                      \hspace*{5em}$\lambda
                                                        P$:\textit{Ppty}
                                                                     . $P$($r_1$.x$_0$)\\
                                       \hspace*{6em}\textit{wants}$'$($\lambda
                                                                     P$:\textit{Ppty}
                                                                     . $P$($r_1$.x$_1$))))\end{tabular}}}
 
\item  \smallrecord{\field{bg}{\textit{Rec}}\\
                                                        \field{fg}{\begin{tabular}{l}
                                                                    $\lambda\mathfrak{s}$:\textit{Rec}
                                                                     \\
                                                                    \hspace*{1em}\textit{every}$'$(\textit{boy}$'$)
                                                                      \\
                                                                    \hspace*{2em}($\lambda
                                                                     r_1$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
                                                                     . \\
                                                                    \hspace*{3em}\textit{a}$'$(\textit{dog}$'$)\\
                                                                    \hspace*{4em}($\lambda
                                                                     r_2$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
                                                                     . \\
                                                                    \hspace*{5em}$\lambda
                                                                     P$:\textit{Ppty}
                                                                     . $P$($r_1$.x$_0$)\\
                                                                    \hspace*{6em}\textit{wants}$'$($\lambda
                                                                     P$:\textit{Ppty}
                                                                     . $P$($r_1$.x$_1$))))\end{tabular}}}
 
\end{subex} 
\label{ex:plugged}   
\end{ex} 
  
We now take a look at what is needed in order achieve the analysis we
have discussed above.  We will express storage and retrieval as
constraints on linguistically allowable sign types.  As a preliminary
we will define a bookkeeping function, max$_x$, which enables us to determine
the maximum $i$ such that `x$_i$' is used as a label in a set of
records, $R$.  This will enable us to store quantifiers using labels
`x$_0$', `x$_1$' and so on in order as in the examples discussed
above. `max$_x$' is defined as in \nexteg{} where $R$ is an arbitrary
set of records.
\begin{ex} 
max$_x$($R$) = 
\begin{quote}
max($\{i\mid\exists r\in R\ \exists v\ \langle \mathrm{x}_i,v\rangle\in r.\mathrm{bg}\}$), if
defined

otherwise: -1 
\end{quote}
\end{ex}
That is, max$_x$($R$) is the maximum $i$ such that `x$_i$' is a label
in the `bg'-field of one of the records in $R$.  If there is no such label max$_x$($R$)
returns -1. Thus in adding to a quantifier store, $R$, (as in the
`quants'-fields in the examples above) we will always add a new
quantifier indexed by max$_x$($R$)+1.  For brevity we will denote this by
incr$_x$($R$), that is, the result of incrementing the maximal x in $R$. 

It will also be useful to define an operation that adds a field
\smallrecord{\field{$\ell$}{$v$}} to a record $r$ if there is no field
with the label $\ell$ or replaces the $\ell$-field in $r$ with
\smallrecord{\field{$\ell$}{$v$}}.  We will represent the new record
thus derived as $r\oplus$\smallrecord{\field{$\ell$}{$v$}}.  This
is defined in \nexteg{}.
\begin{ex} 
$r\oplus$\smallrecord{\field{$\ell$}{$v$}} is \\
\hspace*{1em}$r\cup\{\langle\ell,v\rangle\}$, if there is no $v'$ such
that $\langle\ell,v'\rangle\in\mathfrak{s}$\\
\hspace*{1em}$(r-\{\langle\ell,r.l\rangle\})\cup\{\langle\ell,v\rangle\}$, otherwise 
\end{ex} 
Similarly we define $T\ominus$\smallrecord{\smalltfield{$\ell$}{$v$}}
for record types, $T$, in
\nexteg{}.
\begin{ex} 
$T\ominus$\smallrecord{\smalltfield{$\ell$}{$v$}} is \\ 
\hspace*{1em}$T-\{\langle\ell,v\rangle\}$ 
\end{ex} 
Note that this version of subtraction for record types will only
result in a well-formed record type if there are not fields in $T$
which depend on $\ell$.  In order to rectify this we need to make
$T\ominus$\smallrecord{\smalltfield{$\ell$}{$v$}} remove in addition
all fields which depend on $\ell$.  A field, $f$, is dependent on $\ell$
just in case it is of the form
$\langle\ell',\langle\mathcal{F},\pi\rangle\rangle$ where $\pi$ is a
sequence of paths containing $\ell$. Therefore we can refine the
definition in \preveg{} as that in \nexteg{}.
\begin{ex} 
$T\ominus$\smallrecord{\smalltfield{$\ell$}{$v$}} is \\ 
\hspace*{1em}$T-(\{\langle\ell,v\rangle\}\cup\{f\in T\mid f\
\text{dependent on}\ \ell\})$ 
\end{ex} 
This is technically not enough, since there may still be fields left
which are dependent on the dependent fields we have removed.
Therefore we need to make the definition recursive as in \nexteg{}.
\begin{ex} 
$T\ominus$\smallrecord{\smalltfield{$\ell$}{$v$}} is \\ 
\hspace*{1em}$(\ldots(T-\{\langle\ell,v\rangle\}\ominus
f_0)\ldots)\ominus f_n$ where $\{f_0,\ldots,f_n\}$ is $\{f\in T\mid f\
\text{dependent on}\ \ell\}$ 
\end{ex}   

[Is this enough to cover paths which contain $\ell$?]

We can now define storage as in
\nexteg{}, where $\sigma$ is an arbitrary sign.
\begin{ex} 
\textbf{Storage}

If $\alpha\in\sigma$.cont.unplugged, $\alpha$.core : \textit{PQuant}
and \\ $\alpha$.core.fg $\not=$
$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_i$}{\textit{Ind}}}
  . $\lambda P$:\textit{Ppty} . $P$($\mathfrak{s}$.x$_i$) for any $i$, \\then

\hspace*{1em}\record{\field{quants}{$\alpha$.quants $\cup$ \{
                              \record{\field{bg}{\smallrecord{\smalltfield{x$_{\mathrm{incr}_x(\alpha.\mathrm{quants})}$}{\textit{Ind}}}}\\
        \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_{\mathrm{incr}_x(\alpha.\mathrm{quants})}$}{\textit{Ind}}}
          . $\alpha$.core.fg($\mathfrak{s}$)}}\}}\\
\field{core}{\record{\field{bg}{\smallrecord{\smalltfield{x$_{\mathrm{incr}_x(\alpha.\mathrm{quants})}$}{\textit{Ind}}}}\\
                     \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_{\mathrm{incr}_x(\alpha.\mathrm{quants})}$}{\textit{Ind}}}
                       . $\lambda P$:\textit{Ppty}
                       . $P$($\mathfrak{s}$.x$_{\mathrm{incr}_x(\alpha.\mathrm{quants})}$)}}}}

\hspace*{4em}$\in$ $\sigma$.cont.unplugged
                                 
\end{ex} 
If $\sigma$ is a sign, $\sigma$.cont.unplugged is a set of unplugged interpretations.
\preveg{} says that if any
of those is a noun-phrase interpretation, that is, its core is of type
\textit{PQuant}, and is not the result of applying storage, that is,
the foreground of its core is not an interpretation depending on a
context, $\mathfrak{s}$, as introduced by storage, then
$\sigma$.cont.unplugged also contains an unplugged interpretation
where the core has been stored. 

We now characterize retrieval (in a version corresponding to
quantification with scope over sentences, as opposed to verb phrases
or common nouns) in \nexteg{}, where again $\sigma$ is an arbitrary
sign.
\begin{ex} 
\textbf{Retrieval (S)} 

If $\alpha\in\sigma$.cont.unplugged, for some $i$,
$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_i$}{\textit{Ind}}}
. $Q$ $\in$ $\alpha$.quants and $\alpha$.core : ($T$ $\rightarrow$
\textit{Type}), where $T$ $\sqsubseteq$
\smallrecord{\smalltfield{x$_i$}{\textit{Ind}}}, then \\

\hspace*{1em}\record{\field{quants}{$\alpha$.quants $-$
    $\{\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_i$}{\textit{Ind}}}
    . $Q\}$} \\
        \field{core}{$\lambda\mathfrak{s}$:$T-$\{\smallrecord{\smalltfield{x$_i$}{\textit{Ind}}}\}
          . $Q$($\lambda
          r$:\smallrecord{\smalltfield{x$_i$}{\textit{Ind}}}
          . $\alpha$.core($\mathfrak{s}\oplus$\smallrecord{\field{x$_i$}{$r$.x$_i$}}))}}

\hspace*{4em}$\in$ $\sigma$.cont.unplugged
\end{ex} 
\preveg{} says that if any of the unplugged interpretations in a sign
contains a quantifier indexed by $i$, that is, it is a parametric
quantifier whose domain type is
\smallrecord{\smalltfield{x$_i$}{\textit{Ind}}}, and the core of this
unplugged interpretation is a function from contexts to a type, that
is, it corresponds to a (declarative) sentence interpretation, where
the context is required to provide a value for `x$_i$', that is, the
domain type is a subtype of
\smallrecord{\smalltfield{x$_i$}{\textit{Ind}}},\footnote{Note that
  this requirement will prevent the kind of vacuous binding that
  Keller storage \citep{Keller1988} avoided.} then the quantifier is
removed from the store and given scope over the sentence
interpretation in the core binding `x$_i$'.  The dependence on `x$_i$'
in the context is removed from the core interpretation. 

Finally, we show one way in which stored quantifiers can be
``percolated'' to higher constituents by showing in \nexteg{} how to
construct an unplugged content from two constituent unplugged contents
when the basic semantic composition involves function application.  To
facilitate this we first define the `x'-incrementation of an object
(such as a set or a function) with respect to a set of records $R$.

\begin{ex} 
The `x'\textit{-incrementation of an object $O$ with respect
  to a set of records $R$}, $[O]_{\mathrm{incr}_x(R)}$, is the result of
replacing each instance of x$_i$ in $O$, for any natural number $i$,
with x$_{\mathrm{incr}_x(R)+i}$.  
\end{ex} 
Now application for unplugged contents (that is, objects of type
\textit{UInterp}) can be characterized as in \nexteg{}.

\begin{ex} 
\textbf{Application}

If $\alpha$ and $\beta$ are of type \textit{UInterp} and $\beta$.core
is in the domain of $\alpha$.core, then the \textit{application of
  $\alpha$ to $\beta$}, $\alpha @@\beta$, is
\begin{quote}

\record{\field{quants}{$\alpha$.quants$\cup$[$\beta$.quants]$_{\mathrm{incr}(\alpha\mathrm{.quants})}$}\\
        \field{core}{$\alpha$.core@[$\beta$.core]$_{\mathrm{incr}(\alpha\mathrm{.quants})}$}}
\end{quote}
\end{ex} 
\preveg{} says that the application of an unplugged content, $\alpha$,
to another unplugged content, $\beta$, involves first changing the
quantifier indices in $\beta$ so that they increment the quantifier
indices in $\alpha$ in the way that is illustrated in the examples
discussed above.  For example, if both $\alpha$ and $\beta$ contain
the quantifier index `x$_0$' and this is the maximum in $\alpha$, then
`x$_0$' will be changed to `x$_1$' in $\beta$.  Now the result of
application is an unplugged content whose `quants' are the union of
$\alpha$'s `quants' and the incremented `quants' of $\beta$.  The core
is the result of applying $\alpha$'s core to $\beta$'s core using the
same incrementation. 
  

%[Grammar to be added.]

\section{Long distance dependencies}

Let us consider how to derive the content of \textit{who Sam hugged}
as a relative clause.  We use \textbf{hug}$_V$ to represent the
foreground of the content of \textit{hug} as a transitive verb,
characterized as in \nexteg{}.
\begin{ex} 
\textbf{hug}$_V$ = $\lambda\mathfrak{s}$:\textit{Rec} . $\lambda
r_2$:\smallrecord{\smalltfield{x}{\textit{Quant}}} . $\lambda
r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
. \smallrecord{\smalltfield{e}{hug($r_1$.x, $r_2$.x)}} 
\end{ex} 
Our theory of syntax in terms of event types means that what have been
called ``gaps'' or ``traces'' in other theories of syntax would
somehow have to correspond to non-events in which nothing happens and
do not have any temporal extent.  This strongly suggests that they do
not exist.  Instead we will take a strategy similar to that pursued,
for example, in combinatory categorial grammar (see, for example,
\citealp{Steedman2012}) where \textit{hug} can also be interpreted as
a verb phrase whose content is ``looking for'' a \textit{wh}-phrase
content.  We will represent the foreground of this content as
\textbf{hug}$_{\mathit{VP}}$ and characterize it in terms of
\textbf{hug}$_V$ as in \nexteg{a} which is identical with \nexteg{b}.
\begin{ex} 
\begin{subex}
\item \textbf{hug}$_{\mathit{VP}}$ = $\lambda\mathfrak{s}$:\smallrecord{\smalltfield{wh$_0$}{\textit{Ind}}}
. \textbf{hug}$_V$($\mathfrak{s}$)($\lambda P$:\textit{Ppty}
. $P$(\smallrecord{\field{x}{$\mathfrak{s}$.wh$_0$}})) 

\item
  $\lambda\mathfrak{s}$:\smallrecord{\smalltfield{wh$_0$}{\textit{Ind}}}
  . $\lambda r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
  . \smallrecord{\smalltfield{e}{hug($r_1$.x, $\lambda P$:\textit{Ppty}
. $P$(\smallrecord{\field{x}{$\mathfrak{s}$.wh$_0$}}))}}
\end{subex}
\end{ex}

Let us now consider the content of \textit{Sam hugged}.  In order to
avoid the additional complexity of combining different kinds of
context which we will undertake in Section~\ref{sec:struc-cntxt} we
will go back to the treatment of proper names in Chapter~\ref{ch:gram}
rather than the treatment in Chapter~\ref{ch:propnames} where proper
names introduce a constraint on the context. Thus we will consider the
foreground of the parametric content of \textit{Sam}, which we will
represent as \textbf{Sam}, to be \nexteg{}
where `sam' is a particular individual named Sam.
\begin{ex} 
\textbf{Sam} = $\lambda\mathfrak{s}$:\textit{Rec} . $\lambda P$:\textit{Ppty} . $P$(\smallrecord{\field{x}{sam}}) 
\end{ex}
The foreground of the content of \textit{Sam hugged}, which we will
represent as \textbf{Sam$^\frown$hugged}, is \nexteg{a} which is
identical with \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item \textbf{Sam$^\frown$hugged} =
  $\lambda\mathfrak{s}$:\smallrecord{\smalltfield{wh$_0$}{\textit{Ind}}}
  . \textbf{Sam}($\mathfrak{s}$)(\textbf{hug}$_{\mathit{VP}}$($\mathfrak{s}$)) 
 
\item
  $\lambda\mathfrak{s}$:\smallrecord{\smalltfield{wh$_0$}{\textit{Ind}}}
  . \smallrecord{\smalltfield{e}{hug(sam, $\lambda P$:\textit{Ppty} . $P$(\smallrecord{\field{x}{$\mathfrak{s}$.wh$_0$}}))}}
 
\end{subex} 
   
\end{ex}
The foreground of the content of \textit{who}, which we will represent
as \textbf{who}, is given in \nexteg{}.
\begin{ex} 
\textbf{who} =
$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{wh}{\textit{Ind}}}
. $\lambda P$:\textit{Ppty} . $P$(\smallrecord{\field{x}{$\mathfrak{s}$.wh}}) 
\end{ex} 
In order to be able to characterize the kind of binding involved in
combining \textit{who} with \textit{Sam hugged} we will define an
operation, $\oplus$, which adds a field to a record or, if the label
of the field being added
is already present in the record, will replace that field with the new
field.  This operation is characterized in \nexteg{}.
\begin{ex} 
If $r$ is a record, $\ell$ is a label and $v$ is some TTR object, then
\\
\hspace*{1em} $r\oplus[\ell=v]$ is \\
\hspace*{2em} $r\cup\{\langle\ell,v\rangle\}$, if there is no $v'$
such that $\langle\ell,v'\rangle\in r$\\
\hspace*{2em}
$(r-\{\langle\ell,r.\ell\rangle\})\cup\{\langle\ell,v\rangle\}$, otherwise 
\end{ex} 
We are using records here to do the work of partial variable
assignments in logic and the $\oplus$-operation carries out the kind
of modification which is performed on variable assignments when
defining binding in the logical treatment.  This now gives us what we
need to characterize the foreground of the content of the relative
clause \textit{who Sam hugged}, which we will represent as
\textbf{who}$^\frown$\textbf{Sam}$^\frown$\textbf{hugged}, as in
\nexteg{a} which is identical with \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item \textbf{who}$^\frown$\textbf{Sam}$^\frown$\textbf{hugged} = \\
  \hspace*{1em}$\lambda\mathfrak{s}$:\textit{Rec} . \\
\hspace*{2em}$\lambda
  r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
  . \\
\hspace*{3em}\textbf{who}($\mathfrak{s}\oplus[\text{wh}=r_1.\text{x}]$)
($\lambda
  r_2$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . \textbf{Sam}$^\frown$\textbf{hugged}($\mathfrak{s}\oplus[\text{wh}_0=r_2.\text{x}]$)) 
 
\item $\lambda\mathfrak{s}$:\textit{Rec} . $\lambda
  r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
  . \smallrecord{\smalltfield{e}{hug(sam, $\lambda P$:\textit{Ppty} . $P$(\smallrecord{\field{x}{$r_1$.x}}))}} 
 
\end{subex} 
   
\end{ex} 
     
   
    
    



\section{Conservativity and dynamic generalized quantifiers}

In Chapter~\ref{ch:commonnouns}, example (\ref{ex:dynqconstr}), we
introduced the notion of dynamic generalized quantifier and pointed
out that one of the original motivations for them was what is known as
donkey anaphora which we will discuss in Section~\ref{sec:anaph}.
Here we will point out a connection between dynamic quantifiers and
conservativity of quantifiers, noted in \cite{Chierchia1995}.  The informal way to state
conservativity for quantifiers is as in \nexteg{a} and an example is
given in \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item Q A B is true just in case Q A A\&B is true 
 
\item \textit{every farmer likes a donkey} is true just in case
  \textit{every farmer is a farmer and likes a donkey} (or more
  naturally, \textit{every farmer is a farmer who likes a donkey}) is true
 
\end{subex} 
   
\end{ex} 
Most, if not all, natural language quantifiers have this
property.\footnote{For discussion, see \cite{PetersWesterstahl2006},
  p. 138f.}

Now consider the definition of dynamic generalized quantifiers given
in Chapter~\ref{ch:commonnouns}, Section~\ref{sec:dgqs}.  There in
example~(\ref{ex:dynqconstr}) we gave dynamic versions of generalized
quantifiers.  We can give a general characterization of the witness
conditions for dynamic generalized quantifiers as in \nexteg{}, where
$q$ is a predicate corresponding to a quantifier and $q^*$ is the
relation between sets corresponding to $q$ in classical generalized
quantifier theory.
\begin{ex} 
$e:q(P,Q)$ iff $q^*$ holds between $\downP{P}$ and
$\downP{Q|_{\mathcal{F}(P.\mathrm{fg})}\restriction e}$
\label{ex:witness-cond-GQ}
\end{ex} 
According to the definitions given in Chapter~\ref{ch:commonnouns},
$\downP{Q|_{\mathcal{F}(P.\mathrm{fg})}\restriction e}$ is the set of
individuals which have property $Q|_{\mathcal{F}(P.\mathrm{fg})}$ in
$e$ and $Q|_{\mathcal{F}(P.\mathrm{fg})}$ is $Q$ with its
domain restricted by $P$ (example~(\ref{ex:function-restriction}), p.~\pageref{ex:function-restriction}).  We spell this out for the type
corresponding to \textit{every dog runs} in \nexteg{}.  Here, as
before, we only represent the foregrounds of the properties which are
arguments to the predicate `every' in order to make the presentation
clearer.    
\begin{ex} 
\begin{subex} 
 
\item dog$'$ = $\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
    . \smallrecord{\smalltfield{e}{dog($r$.x)}} 

run$'$ = $\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
    . \smallrecord{\smalltfield{e}{run($r$.x)}}
 
\item $T$ = every(dog$'$, run$'$)

\item \begin{tabbing}
$s:T$ \=iff
$\downP{\text{dog}'}\subseteq\downP{\text{run}'|_{\mathcal{F}(\text{dog}')}\restriction
s}  $ \hspace*{2em}(\ref{ex:witness-cond-GQ})\\
\> iff  $\downP{\text{dog}'}\subseteq\downP{\text{run}'|_{\text{\smallrecord{\smalltfield{x}{\textit{Ind}}\\\smalltfield{e}{dog(x)}}}}\restriction
s}  $ \hspace*{2em}(def. of fixed point types p.~\pageref{pg:fixedpointtype}f)\\
\> iff $\downP{\text{dog}'}\subseteq$ [$\downarrow\lambda
r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}\d{$\wedge$}\smallrecord{\smalltfield{x}{\textit{Ind}}\\\smalltfield{e}{dog(x)}}
     . \smallrecord{\smalltfield{e}{run($r$.x)}}$\restriction s$ ] \hspace*{2em} (Ch.~\ref{ch:commonnouns},
(\ref{ex:function-restriction}), p.~\pageref{ex:function-restriction})\\
\> iff $\downP{\text{dog}'}\subseteq$ [$\downarrow\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\\smalltfield{e}{dog(x)}}
     . \smallrecord{\smalltfield{e}{run($r$.x)}}$\restriction s$ ]
     \hspace*{2em}\begin{minipage}{.3\textwidth}(def. of merge, Appendix~\ref{app:merge})\end{minipage}\\
\> iff $\downP{\text{dog}'}\subseteq$ [$\downarrow\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\\smalltfield{e}{dog(x)}}
     . \smallrecord{\smallrfield{e}{$s$}{run($r$.x)}}
     ]\hspace*{2em}\begin{minipage}{.3\textwidth}(def. of property restriction,
     Appendix~\ref{app:gramrulesuniv}, p.~\pageref{pg:property-restriction})\end{minipage}\\
\> iff \=$\{a\mid\exists r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
  $\wedge
  r.\text{x}=a\wedge\down{\text{\smallrecord{\smalltfield{e}{dog($r$.x)}}}}\not=\emptyset\}$\\
\>\>$\subseteq\{a\mid\exists r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\\smalltfield{e}{dog(x)}}
  $\wedge
  r.\text{x}=a\wedge\down{\text{\smallrecord{\smallrfield{e}{$s$}{run($r$.x)}}}}\not=\emptyset\}$
  \hspace*{2em}(def. of $\downarrow$, p.~\pageref{pg:property-extension-rev})
  \\
\> iff
$\{a\mid\down{\text{dog}(a)}\not=\emptyset\}\subseteq\{a\mid\down{\text{dog}(a)}\not=\emptyset\wedge\exists
s'[s'\underline{\varepsilon}s\wedge
s':\text{run}(a)]\}$\\
\>\`\begin{minipage}{.3\textwidth}(Arity of `dog', `run' and set
extension of records, Appendix~\ref{app:rec}, \textit{cf.} p.~\pageref{pg:set-reduction-gq}ff)\end{minipage}\\ 
\> iff $\{a\mid\exists s'[s':\text{dog}(a)]\}\subseteq\{a\mid\exists
s'[s':\text{dog}(a)]\wedge\exists
s'[s'\underline{\varepsilon}s\wedge s':\text{run}(a)]\}$ \\
\>\`\begin{minipage}{.3\textwidth}(def. of $\down{T}$, p.~\pageref{pg:type-extension})\end{minipage}
\end{tabbing} 
\end{subex} 
\label{ex:witnessconds-edr}   
\end{ex} 
  
[We are now going to start a new version of witness conditions for
quantificational ptypes which will be inconsistent with some of what
we said before in the book about their witness conditions  --
eventually we need to go back and revise the previous discussion and
also the section on anaphora following this section.  The motivation
for this is in part to get neater treatment of anaphora, and a more
general treatment along the lines of Lcking and Ginzburg.]

\subsection{A witness based account of generalized quantifiers}

The classical view of quantifiers is based on the notion that noun
phrases represent sets of sets or properties and the definition of a
quantifier involves characterizing which set or sets or properties it
represents.  This was the view presented, for example, in
\cite{BarwiseCooper1981}.  Associated with this was the notion of
\textit{witness set} defined by Barwise and Cooper as in \nexteg{}.
\begin{ex} 
A \textit{witness set} for a quantifier $D(A)$ living on $A$ is any
subset $w$ of $A$ such that $w\in D(A)$. 
\end{ex} 
In \preveg{} $D$ was used as the function corresponding to a
determiner such as \textit{some} or \textit{most} mapping a set $A$
(corresponding, for example, to the set denoted by a common noun phrase such
as  \textit{farmer} or \textit{farmer who owns a donkey}) to a set of
sets.  The notion \textit{lives on} used by Barwise and Cooper
corresponds to what was later in the literature referred to as
\textit{conservativity}.  Their definition of the lives-on property,
slightly simplified by removing reference to the model, is given in \nexteg{}.
\begin{ex} 
A quantifier $Q$ \textit{lives on} a set $A$ if $Q$ is a set of sets
with the property that
\begin{quote}
$X\in Q \text{ iff } (X\cap A)\in Q$
\end{quote}  
\end{ex} 
This means that the notion of witness set given by Barwise and Cooper
is defined for conservative quantifiers.  Examples of witness sets
that they give include: a witness set for the quantifier corresponding
to a proper name \textit{John} as the singleton set containing the
individual John;  a witness set corresponding to \textit{a woman} as
any non-empty set of women; a witness set corresponding to
\textit{most women} as a set of women which contains most women.

The notion of witness set
was introduced by Barwise and Cooper in a section called
\textit{Processing Quantified Statements}.  It was introduced by them
as an auxiliary notion which could be used in an account of how an
agent might evaluate the truth of a quantified statement.  This
suggests that it should play an important role in a theory of
semantics like ours which is oriented towards explaining cognitive
semantic processing, especially if it is a theory which attempts to do
this in terms of judgements that objects (including situations) are
witnesses of types.  It seems natural to make a link between the
notion of witnesses for types and the notion of witnesses for
quantifiers.  We will go further and suggest that the characterization
of the meaning of determiners is based on witness sets, thus elevating
the witness sets from an auxiliary notion derived from the meaning
assigned to quantifiers to the central notion which characterizes the
distinctions between the various quantifier meanings available, just
as in type theory the notion of meaning is characterized in terms of
the witness conditions for types.

In the literature on generalized quantifiers \cite{Benthem1984}
introduced the perspective that we should think of determiners as
representing relations between sets rather than as mappings from sets
to families of sets.  This is reflected in our characterization of
quantifier relations as relations between properties (which can be
used to generate the set of objects which have the property) and the
use of ptypes constructed with quantifier relations and two properties
as arguments.

With each quantifier relation, $q$, and property, $P$, we will
associate a type of witness sets $q^w(P)$.  For example, a set, $X$,
is of type $\text{most}^w(P)$ if $X$ is a set of objects with property
$P$ which contains most of the objects which have property $P$.  We
will say that a witness for the quantificational ptype `most($P$,
$Q$)' is a pair (coded as a record and thus corresponding intuitively
to a situation) consisting of the set, $X$, where  $X:q^w(P)$
(i.e. $X$ is a witness set for $q$ and $P$) and a function, $f$,  whose domain
is $X$ and such that for any $a\in X$, $f(a)$ is a situation which
shows that $a$ has property $Q$.  In general for distributive readings
of monotone increasing
quantifiers, $q$, we can say that a witness for $q(P, Q)$ provides a
witness set $X$ of type $q^w(P)$ and a function which shows that every
member of $X$ has the property $Q$. For distributive readings of
monotone decreasing quantifiers we need a different kind of function
together with the witness set.  Here we have to check that everything
which has both property $P$ and property $Q$ is a member of the
witness set.  Thus we need a function, $f$, whose domain is the set of
objects having both $P$ and $Q$, such that if $a$ is in this set then
$f(a)$ is a situation which shows that $a$ is a member of the witness
set $X$.  These two kinds of functions correspond exactly to the
evaluation procedures suggested in \cite{BarwiseCooper1981} quoted in
\nexteg{}.
\begin{ex} 
\textit{To evaluate $X\in D(A)$ do the following:}
\begin{enumerate} 
 
\item Take some subset $w$ of $A$ which you know to be in $D(A)$ 
 
\item 
\begin{enumerate} 
 
\item[(i)] For mon$\uparrow$ $D(A)$, check $w\subseteq X$. 
 
\item[(ii)] For mon$\downarrow$ $D(A)$, check $(X\cap A)\subseteq w$
 
 
\end{enumerate} 
\item If there is such a $w$, the sentence is true.  Otherwise it is false.   
 
\end{enumerate} 
   
\end{ex} 

Using pairs of witness sets and functions as witnesses for
quantificational ptypes is also closely related to
the treatment of quantification in Martin-Lf type theory using
$\Sigma$-types and dependent types.  (See, for example,  discussion in
\citealp{Ranta1994}.)  A witness for the $\Sigma$-type \nexteg{a}
would be an ordered pair as characterized in \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item $(\Sigma x:A)B(x)$ 
 
\item $\langle a,b\rangle$ where $a:A$ and $b:B(a)$ 
 
\end{subex} 
   
\end{ex} 

In the following subsections we will develop the tools we need to make
our analysis precise in terms of the TTR machinery we have developed
so far to create a witness-based analysis of quantfiers.  We will also
consider how we can move away from a set-based account of
quantification to a type-based approach where we can estimate the
probability of a quantificational ptype being witnessed on the basis
of our previous experience.  
    


\subsection{Relating properties, types and sets}

[????In this section we revise the definition of properties.  We
probably need to go back and revise previous definitions for
consistency.]

We first define a type of record types whose labels include a certain
set of labels.  Let $L$ be a set of labels, then \textit{RecType}$_L$
is a type.  $T$ : \textit{RecType}$_L$ iff $T$ : \textit{RecType} and
$L\subseteq\text{labels}(T)$.  [????Check whether `labels' defined for
record types -- it is defined for records.]

Now we can define \textit{Ppty} to be the type in \nexteg{}.
\begin{ex} 
\record{\tfield{bg}{\textit{RecType}$_{\{x\}}$}\\
        \tfield{fg}{(bg$\rightarrow$\textit{RecType})}} 
\end{ex} 
A witness for this type,  a property, would be something like
\nexteg{}, ``the property of being a dog''.
\begin{ex} 
\record{\field{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}}}\\
        \field{fg}{$\lambda
          r$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . \record{\tfield{e}{dog($r$.x)}}}} 
\end{ex} 
This is a cumbersome notation for a property so we abbreviate it as
\nexteg{}.
\begin{ex} 
$\ulcorner\lambda
          r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
          . \record{\tfield{e}{dog($r$.x)}}$\urcorner$ 
\label{ex:ppty-dog}
\end{ex}
If $P$ is a property we will also use the notation $P(a)$ to represent $P.\text{fg}(a)$.
 
\preveg{} is a property of individuals  and we will have a subtype of
\textit{Ppty}, \textit{Ppty}(\textit{Ind}), to represent this more
specific type of property. In general we give the definition in
\nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item if $T$ is a type, then
\textit{Ppty}($T$) is a type 
 
\item $P$ : \textit{Ppty}($T$) iff
$P$ : \textit{Ppty} and $P$.bg$^{\text{x}}$ is
\smallrecord{\smalltfield{x}{$T$}} 
 
\end{subex} 
   
\end{ex} 
Here we use $P$.bg$^{\text{x}}$
to represent the generalization of $P$.bg to its `x'-field as
characterized in Appendix~\ref{app:gen-rectypes}, that is the type
whose only field is the `x'-field of $P$.bg. 

A property, $P$, can be \textit{pure}, as in (\ref{ex:ppty-dog}), that is,
$P$.bg has exactly one field, the required `x'-field;  or they can be
restricted by including additional fields in the background.  For
example, in \nexteg{a} we have the pure property of being an
individual that barks and in \nexteg{b} we have a restricted property
of being an individual which is a dog that barks.
\begin{ex} 
\begin{subex} 
 
\item $\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
  . \record{\tfield{e}{bark($r$.x)}}$\urcorner$ 
 
\item $\ulcorner\lambda
  r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                  \smalltfield{c}{dog(x)}}
  . \record{\tfield{e}{bark($r$.x)}}$\urcorner$  
 
\end{subex} 
   
\end{ex} 
Note that \preveg{b} is still of type \textit{Ppty}(\textit{Ind})
according to our definition above.


This ability to restrict properties will be important for analyzing
dynamic quantification where information from the first argument of
the quantifier relation is passed to the second argument of the
quantifier relation and this is what enables the treatment of donkey
anaphora.  Thus \textit{every farmer who owns a donkey likes it} will
be treated as the `every'-relation holding between the property of
being a farmer and owning a donkey and the property of being a farmer
who owns a donkey and likes it thus providing an antecedent for
\textit{it} within the second property (see
Section~\ref{sec:donkey-anaph}). However, it will also be important to
be able to ``purify'' such restricted properties, that is, relate them
systematically to a corresponding property whose background contains just
the one `x'-field.  This will allow us to avoid the proportion problem
that can arise in the analysis of donkey anaphora, that is in
computing whether a
sentence like \textit{most farmers who own a donkey like it} is true, we need
to ensure that the majority of farmers who own a donkey are such that
they like it and not that the majority of pairs of farmers and donkeys
where the farmer owns the donkey are such that the farmer likes the
donkey. Thus we need a property of individuals, not of farmer-donkey
pairs.  Suppose we have the restricted property \nexteg{a}.  We will
define an operation on functions which will yield the pure property
\nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item $\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                               \smalltfield{c$_1$}{farmer(x)}\\
                               \smalltfield{y}{\textit{Ind}}\\
                               \smalltfield{c$_2$}{donkey(y)}\\
                               \smalltfield{e}{own(x, y)}}
                             . \record{\tfield{e}{like($r$.x, $r$.y)}}$\urcorner$
 
\item $\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . \record{\tfield{$\mathfrak{c}$}{\smallrecord{\smallmfield{x}{$r$.x}{\textit{Ind}}\\
                               \smalltfield{c$_1$}{farmer(x)}\\
                               \smalltfield{y}{\textit{Ind}}\\
                               \smalltfield{c$_2$}{donkey(y)}\\
                               \smalltfield{e}{own(x, y)}}}\\
        \tfield{e}{\record{\tfield{e}{like($\Uparrow$$\mathfrak{c}$.x,
              $\Uparrow$$\mathfrak{c}$.y)}}}}$\urcorner$ 
 
\end{subex} 
\label{ex:pure-eg}   
\end{ex} 
This purification operation changes the property in \preveg{a}, a
property of farmers who own a donkey into the property \preveg{b}, a
property of individuals.  The restriction in \preveg{a} has been
lowered into the body of the property and labelled with
`$\mathfrak{c}$', intuitively a local context in the type returned by
the function.  We denote the purification operation by $\mathfrak{P}$
and define it as in \nexteg{}.
\begin{ex} 
If $P$ : \textit{Ppty}, then
\begin{quote}
if $P$.bg$^x$ = $P$.bg, then
\begin{quote}
$\mathfrak{P}(P)=P$
\end{quote}
otherwise:
\begin{quote}
$\mathfrak{P}(P)$ is $\lambda r$:$P$.bg$^{\text{x}}$
. \record{\tfield{$\mathfrak{c}$}{$P.\text{bg}\parallel$ \smallrecord{\field{x}{$r$.x}}}\\
          \tfield{e}{$P(\mathfrak{c})$}}
\end{quote}
\end{quote}
\end{ex} 
(Recall that $T\!\!\parallel\!\! r$ is the result of specifying or anchoring
$T$ with the record $r$ as defined in Appendix~\ref{app:specrec}.)

As an example let us apply $\mathfrak{P}$ to (\ref{ex:pure-eg}a).  The
result will be \nexteg{}
\begin{ex} 
$\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                               \smalltfield{c$_1$}{farmer(x)}\\
                               \smalltfield{y}{\textit{Ind}}\\
                               \smalltfield{c$_2$}{donkey(y)}\\
                               \smalltfield{e}{own(x, y)}}$^x$ . 
\record{\tfield{$\mathfrak{c}$}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                               \smalltfield{c$_1$}{farmer(x)}\\
                               \smalltfield{y}{\textit{Ind}}\\
                               \smalltfield{c$_2$}{donkey(y)}\\
                               \smalltfield{e}{own(x, y)}} $\parallel$
                             \smallrecord{\field{x}{$r$.x}}} \\  
        \tfield{e}{$\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                               \smalltfield{c$_1$}{farmer(x)}\\
                               \smalltfield{y}{\textit{Ind}}\\
                               \smalltfield{c$_2$}{donkey(y)}\\
                               \smalltfield{e}{own(x, y)}}
                             . \record{\tfield{e}{like($r$.x, $r$.y)}}$\urcorner$($\mathfrak{c}$)}}$\urcorner$
\label{ex:pure-eg1}
\end{ex} 
Following the definition of generalization of a type to a particular
field in Appendix~\ref{app:gen-rectypes}, \nexteg{a} represents
\nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item \smallrecord{\smalltfield{x}{\textit{Ind}}\\
                               \smalltfield{c$_1$}{farmer(x)}\\
                               \smalltfield{y}{\textit{Ind}}\\
                               \smalltfield{c$_2$}{donkey(y)}\\
                               \smalltfield{e}{own(x, y)}}$^x$ 
 
\item \smallrecord{\smalltfield{x}{\textit{Ind}}} 
 
\end{subex} 
   
\end{ex} 
According to the definition of the specification of a record type by a
record given in Appendix~\ref{app:specrec}, \nexteg{a} represents
\nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item \smallrecord{\smalltfield{x}{\textit{Ind}}\\
                               \smalltfield{c$_1$}{farmer(x)}\\
                               \smalltfield{y}{\textit{Ind}}\\
                               \smalltfield{c$_2$}{donkey(y)}\\
                               \smalltfield{e}{own(x, y)}} $\parallel$
                             \smallrecord{\field{x}{$r$.x}} 
 
\item \smallrecord{\smallmfield{x}{$r$.x}{\textit{Ind}}\\
                               \smalltfield{c$_1$}{farmer(x)}\\
                               \smalltfield{y}{\textit{Ind}}\\
                               \smalltfield{c$_2$}{donkey(y)}\\
                               \smalltfield{e}{own(x, y)}}  
 
\end{subex} 
   
\end{ex} 
To understand the reduction of the type in the `e'-field in (\ref{ex:pure-eg1}) we
represent it first in the official notation for dependent fields as in
\nexteg{a}.  This represents the same as \nexteg{b} (by
$\beta$-conversion) and its abbreviatory notation in the context of
(\ref{ex:pure-eg1}) is \nexteg{c}.
\begin{ex} 
\begin{subex} 
 
\item $\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                      \smalltfield{c$_1$}{farmer(x)}\\
                                      \smalltfield{y}{\textit{Ind}}\\
                                      \smalltfield{c$_2$}{donkey(y)}\\
                                      \smalltfield{e}{own(x,y)}}
                                    . $\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                      \smalltfield{c$_1$}{farmer(x)}\\
                                      \smalltfield{y}{\textit{Ind}}\\
                                      \smalltfield{c$_2$}{donkey(y)}\\
                                      \smalltfield{e}{own(x,y)}}
                                    . \record{\tfield{e}{like($r$.x,$r$.y)}}$\urcorner$($v$), $\langle\mathfrak{c}\rangle\rangle$
 
\item $\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                      \smalltfield{c$_1$}{farmer(x)}\\
                                      \smalltfield{y}{\textit{Ind}}\\
                                      \smalltfield{c$_2$}{donkey(y)}\\
                                      \smalltfield{e}{own(x,y)}}
                                    . 
                                    \record{\tfield{e}{like($v$.x,$v$.y)}},
                                      $\langle\mathfrak{c}\rangle\rangle$ 

\item \record{\tfield{e}{like($\Uparrow\!\mathfrak{c}$.x,$\Uparrow\!\mathfrak{c}$.y)}}
 
\end{subex} 
   
\end{ex} 
Making these substitutions yields (\ref{ex:pure-eg}b).

If $P$ is a pure property, we will use the notation $P\{a\}$ to
represent the type $P$(\smallrecord{\field{x}{$a$}}).  If $P\{a\}$ is
witnessed we say that $a$ has property $P$.  We can now define the
type of objects which have $P$, which we will represent as
$\mathfrak{T}(P)$. We introduce this type as in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item If $P$ : \textit{Ppty}, then $\mathfrak{T}(P)$ : \textit{Type}. 
 
\item $a:\mathfrak{T}(P)$ iff $\mathfrak{P}(P)\{a\}$ is witnessed. 
 
\end{subex} 
   
\end{ex} 
There is a different route to a type with the same witnesses as
$\mathfrak{T}(P)$.  We have previously defined $\downP{P}$ as the
set of objects which have the property $P$, as in
Chapter~\ref{ch:commonnouns}, p.~\pageref{pg:property-extension-rev}.  For
any set, $X$, we can define a type whose witnesses are exactly the
members of $X$.  We will represent this type as $\mathfrak{T}(X)$ and
introduce it as in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item If $T$ is a type and $X:\{T\}$, then $\mathfrak{T}(X)$ is a type 
 
\item $a:\mathfrak{T}(X)$ iff $a\in X$ 
 
\end{subex} 
   
\end{ex} 
Given this, it is straightforward to see that \nexteg{} holds.
\begin{ex} 
For any property, $P$, $a:\mathfrak{T}(P)$ iff
$a:\mathfrak{T}(\downP{P})$ 
\end{ex} 
What distinguishes these two types is the method they suggest for
determining whether something is a witness for the type.  In the case
of $\mathfrak{T}(\downP{P})$ we have to first determine the complete
set of objects which have the property and then determine whether the
object in question is a member of the set.  In the case of
$\mathfrak{T}(P)$ we only have to determine whether the object in
question has the property $P$.  Computing the set of all objects which
have a property may be viable when we are considering a property whose
extension is a small finite set of objects (for example, if the
property is that of being a dog in a particular small situation) but
it does not seem feasible in the case of large finite sets or infinite
sets.  We will return to this issue below when we consider the
interpretation of generalized quantifiers which are classically
treated by comparing sets and we will consider an alternative in terms
of types and estimated probabilities.        
     

\subsection{Types of witness sets for quantifiers}
\label{sec:witset-types}
In this section we will discuss the characterization of types of
witness sets for various generalized quantifiers as a step on our way
to characterizing a witnessed-based account of generalized
quantifiers.  The witness sets we characterize will be very close to
those of \cite{BarwiseCooper1981}, though not exactly the same in all
cases.  In general for a quantifier relation, $q$, and property,
$P$, a witness set, $X$, of type $q^w(P)$ must meet two conditions.  The
first is that it must be a subset of the property extension of $P$.
We now have two ways of expressing this as shown in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item $X\subseteq\downP{P}$
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\end{subex} 
   
\end{ex} 
\preveg{a} makes explicit the connection to the original definition of
witness sets by Barwise and Cooper.  \preveg{b} is an equivalent
condition on $X$ which does not involve the computation of the
complete property extension of $P$.

The second condition which must be met by witnesses, $X$, of $q^w(P)$ is a
cardinality condition on $X$.  This may be an absolute condition on
the size of $X$ or it may involve a comparison of the size of $X$ with
the size of the property extension of $P$, that is, $\downP{P}$.  Thus
even though we have a way of avoiding the computation of the total
property extension in the first condition on witness sets, we will not
always be able to avoid it in the second condition.  It is for this
reason that we will move to probability estimations in the next
section.

The witness condition for `exist$^{\text{w}}$($P$)' is given in
\nexteg{}.
\begin{ex} 
$X:\text{exist}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item $|X|=1$ 
 
\end{enumerate} 
   
\end{ex}
Note that this differs from Barwise and Cooper in that it requires
that the witness set contain exactly one object having property $P$
rather than at least one such object.  The quantifier relation `exist'
is used in interpreting the English determiner \textit{a} and also the
singular determiner \textit{some}.  Plural \textit{some} corresponds
to the quantifier relation `exist$_{\text{pl}}$'.  The witness condition for `exist$_{\text{pl}}^{\text{w}}$($P$)' is given in
\nexteg{}.
\begin{ex} 
$X:\text{exist}_{\text{pl}}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item $|X|\geq 2$ 
 
\end{enumerate} 
   
\end{ex}
Correspondingly we can define the witness condition for `no$^{\text{w}}$($P$)' is given in
\nexteg{}.
\begin{ex} 
$X:\text{no}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item $|X|=0$ 
 
\end{enumerate} 
   
\end{ex}
\preveg{} could, of course, be given more concisely as \nexteg{}.
\begin{ex} 
$X:\text{no}^{\text{w}}(P)$ iff $X=\emptyset$
\end{ex}

The witness condition for `every$^{\text{w}}$($P$)' is given in
\nexteg{}.
\begin{ex} 
$X:\text{every}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item $|X|=|\down{\mathfrak{T}(P)}|$ 
 
\end{enumerate}  
\end{ex} 
Note that \preveg{} requires $X$ to be identical with $\down{\mathfrak{T}{P}}$ and
we could, of course, express the witness condition more succinctly as
\nexteg{} if we are not concerned about demonstrating that the witness
conditions for the types witness sets for all quantifiers follow the
same pattern.
\begin{ex} 
$X:\text{every}^{\text{w}}(P)$ iff $X=\down{\mathfrak{T}(P)}$ 
\end{ex} 
Either way, we seem committed to computing the set $\downP{P}$ in
order to compute a witness set of `every' and $P$ and this can
therefore lead to problems if $\downP{P}$ is a large set.  A standard
way of avoiding the computation of this set in the interpretation of
universal quantification is to associate universal quantification with
a function so that, using the notions we have built up,  a witness for `every($P$,$Q$)' would be a function
from $\mathfrak{T}(P)$ to $\mathfrak{T}(Q)$ (see \citealp{Ranta1994},
for discussion of how this is done in a standard Martin-Lf type
theory).  This avoids computing the property extension of $P$ if we
have the right view of functions as intensional objects or procedures,
rather than the von Neumann notion of function as a set of ordered
pairs as is standard in set theory.  We will make use of such
functions when we come to treat the witness conditions for
quantificational ptypes.  Such a treatment on its own does not yield a
characterization of a witness set, however, and thus does not
immediately yield a way of treating plural discourse anaphora with
a universal quantifier as antecedent as in \nexteg{}.
\begin{ex} 
Every dog ran into the field.  They had seen the rabbits. 
\end{ex} 
For this reason we will pursue the witness set approach and attempt to
solve the problem of large sets by introducing probability estimation.  


In order to account for the witness condition for `most$^{\text{w}}$'
we assume that there is a threshold,
$\theta_{\text{most}}(P)$, which tells you what proportion of the
property extension of $P$ has to be included in the witness set.  This
is possibly an oversimplification in that the threshold may depend on
more than the quantifier relation and the first argument property
to the relation.  A common assumption in the generalized quantifier
literature is that `most($P$,$Q$)' is true just in case at least one more than
half of the $P$s are $Q$ (see, for example,
\citealp{PetersWesterstahl2006}).  This may be true if the property
extension of $P$ is a small finite set.  But it hardly seems to be the
case for an example involving a larger set as in \nexteg{}.
\begin{ex} 
Most supporters in the stadium cheered when the goal was scored. 
\end{ex} 
\preveg{} does not appear to be true if only one more than half of the
forty thousand supporters in the stadium cheered.  Rather we would expect the number
of cheering supporters to be something in excess of 75\% or 85\%  of the
supporters in the stadium.  The unclarity as to exactly which
proportion is involved leads us to introduce a threshold which can
vary with the context and the speaker.  

The witness condition for `most$^{\text{w}}$($P$)' is given in \nexteg{}. 
\begin{ex} 
$X:\text{most}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item $\frac{|X|}{|\downP{P}|}\geq\theta_{\text{most}}(P)$ 
 
\end{enumerate}  
\end{ex}
Clause~2 in \preveg{} requires us to count both the witness set, which
may be quite large, like the number of supporters in a stadium, as
well as the property extension of $P$.  We will address this by using
probability estimations in the next section.

The English determiner \textit{many}, has two readings: absolute and
proportional.  We will treat this in terms of two quantifier relations
`many$_a$' and `many$_p$'.  For any property, $P$, we will assume that
thresholds, $\theta_{\text{many}_a}(P)$ and $\theta_{\text{many}_p}(P)$ are
provided.  These will indicate, respectively, the number of objects
having property $P$ that will count as many and the proportion of the
set of objects having $P$ that will count as many.  The witness
condition for `many$_a^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{many}_a^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item $|X|\geq\theta_{\text{many}_a}(P)$ 
 
\end{enumerate} 
 
\end{ex}
The witness condition for `many$_p^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{many}_p^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item $\frac{|X|}{|\downP{P}|}\geq\theta_{\text{many}_p}(P)$ 
 
\end{enumerate}  
\end{ex} 
The quantifier relations corresponding to \textit{few} are treated in
an exactly similar fashion to those corresponding to \textit{many}
except that the cardinality of the witness set or the proportion of
the property extension included in the witness set is required to be
less than or equal to the relevant threshold. The witness
condition for `few$_a^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{few}_a^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item $|X|\leq\theta_{\text{few}_a}(P)$ 
 
\end{enumerate} 
 
\end{ex}
The witness condition for `few$_p^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{few}_p^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item $\frac{|X|}{|\downP{P}|}\leq\theta_{\text{few}_p}(P)$ 
 
\end{enumerate}  
\end{ex}
The quantifier relations corresponding to \textit{a few} use the same
thresholds as those corresponding to \textit{few} but in the case of
\textit{a few} the size of the witness set and the proportion of the
witness set to the property extension have to be greater than or equal
to the threshold. The witness
condition for `a\_few$_a^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{a\_few}_a^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item $|X|\geq\theta_{\text{few}_a}(P)$ 
 
\end{enumerate} 
 
\end{ex}
The witness condition for `a\_few$_p^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{a\_few}_p^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item $\frac{|X|}{|\downP{P}|}\geq\theta_{\text{few}_p}(P)$ 
 
\end{enumerate}  
\end{ex} 
     

\subsection{Relating witness sets to probabilities}
In general our strategy for relating witness sets to probabilities
will involve two conditions, the first of which is the same as we had
in the previous section, that is that the witness set, $X$, is a set
of objects which have the property, $P$, i.e. $X:\mathfrak{T}(P)$.
The second condition, however, will place a constraint on the value of
a conditional probability which we will represent as
$p(\mathfrak{T}(X)\|\mathfrak{T}(P))$, that its, the probability for
any object $a$ that it is of type $\mathfrak{T}(X)$ given that it is
of type $\mathfrak{T}(P)$.\footnote{We contrast this with
  $p(\mathfrak{T}(X)|\mathfrak{T}(P)$, the probability that there is
  something of type $\mathfrak{T}(X)$, given that there is something
  of type $\mathfrak{T}(P)$. See \cite{CooperDobnikLappinLarsson2014a}
  and ???? for discussion.}  Here we will take a
frequentist view of this probability and define it according the
equation in \nexteg{}.
\begin{ex} 
$p(T_1\|T_2)=\frac{|\down{T_1\wedge T_2}|}{|\down{T_2}|}$ if $T_2$ is
witnessed and $0$ otherwise.
\label{ex:freq-cond-prob}
\end{ex} 
Clearly, this of itself will not help if we wish to avoid counting the
set of witnesses of $T_1$ or $T_2$. However, probabilities can be
estimated on the basis of previous experience.  We will assume that an
agent has available in memory a finite set of Austinian propositions,
$\mathfrak{J}$, recording judgements previously made.  We will define
a notion of having a type with respect to a set of Austinian
propositions, $\mathfrak{J}$, using $a:_{\mathfrak{J}}T$ to represent
``$a$ is of type $T$ with respect to $\mathfrak{J}$''.  This notion
is defined in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item $a:_{\mathfrak{J}}T$ if \record{\field{sit}{$a$}\\
                                         \field{type}{$T$}}
                                       $\in$ $\mathfrak{J}$ 
 
\item If $T=(T_1\wedge T_2)$, then $a:_{\mathfrak{J}}T$ if $a:_{\mathfrak{J}}T_1$ and
  $a:_{\mathfrak{J}}T_2$

\item Otherwise $a\not:_{\mathfrak{J}}T$
 
\end{subex} 
   
\end{ex} 
We will use the notation $\down{T}_{\mathfrak{J}}$ to represent the
extension of $T$ with respect to $\mathfrak{J}$, defined in \nexteg{}.
\begin{ex} 
$\down{T}_{\mathfrak{J}}=\{a\mid a:_{\mathfrak{J}}T\}$ 
\end{ex} 
We can now define the notion of \textit{estimate of} $p(T_1\|T_2)$
\textit{based on} $\mathfrak{J}$, $p_{\mathfrak{J}}(T_1\|T_2)$, as in
\nexteg{}.
\begin{ex} 
$p_{\mathfrak{J}}(T_1\|T_2)=\frac{|\down{T_1\wedge T_2}_{\mathfrak{J}}|}{|\down{T_2}_{\mathfrak{J}}|}$ 
\end{ex} 
A measure of reliability of the estimate could be related to the
number of instances observed, that is, about which a judgement has
been made, for example as in \nexteg{}.
\begin{ex} 
reliability($p_{\mathfrak{J}}(T_1\|T_2)$) = ln min($|\down{T_1}_{\mathfrak{J}}|,|\down{T_2}_{\mathfrak{J}}|$) 
\end{ex} 
This could still involve an agent in a serious amount of counting
which might be unintuitive from a psychological point of view. From a
computational point of view it would be straghtforward enough to keep
track of how many objects of each type have already been judged and to
increment these numbers when a new object of the type is encountered.
However, we do not seem to be aware of how many objects of a given
type we have encountered when the numbers get high.  For example, I
know that I have seen a lot of dogs in my life but I have no idea how
many.  It would also not explain how I could estimate the probability
that any person in a stadium is wearing an IFK Gteborg scarf just by
looking around the stadium but not exactly counting the number of
people in the stadium and the number of those wearing the scarf.  This
seems to point to the related proposals based on Austinian
propositions involving Bayesian reasoning about probability which are
suggested in \cite{CooperDobnikLappinLarsson2014a} and ????.  An
important difference between what we are doing here and what we did in
the earlier work is that here we assume that the Austinian
propositions in $\mathfrak{J}$ are categorical rather than
probabilistic.  We could, of course, derive a set of categorical
propositions from a set of probabilistic propositions by choosing
categorical propositions for all those in the probabilistic set whose
probabilities exceed a given threshold.

Here we will look at the straight frequentist interpretation of
probabilities associated with types of witness sets of quantifiers as
this can be shown to relate directly to the characterization of these
types in Section~\ref{sec:witset-types} and assume that these
probabilities can be estimated on the basis of a (tractably small) set, $\mathfrak{J}$,
of propositions available to the agent in memory.   For convenience in
the discussion below we will repeat the second clause of the
non-deterministic characterization from Section~\ref{sec:witset-types}
for comparison.

The witness condition for `exist$^{\text{w}}$($P$)' is given in
\nexteg{}.
\begin{ex} 
$X:\text{exist}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item
  $p(\mathfrak{T}(X)\|\mathfrak{T}(P))=\frac{1}{|\down{\mathfrak{T}(P)}|}$
  (corresponds to $|X|=1$) 
 
\end{enumerate} 
   
\end{ex}
It is easy to see that the clauses~(1.) and (2.) in \preveg{} are
equivalent to the non-probabilistic version if we take the frequentist
interpretation of the conditional probability in
(\ref{ex:freq-cond-prob}).  Nothing is gained by going to the extra
expense of computing the probability here.  All we need to do is check
that the witness set is a singleton and that its member is of the type
$\mathfrak{T}(P)$.  

The witness condition for `exist$_{\text{pl}}^{\text{w}}$($P$)' is given in
\nexteg{}.
\begin{ex} 
$X:\text{exist}_{\text{pl}}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item
  $p(\mathfrak{T}(X)\|\mathfrak{T}(P))\geq\frac{2}{|\down{\mathfrak{T}(P)}|}$
  (corresponds to $|X|\geq 2$) 
 
\end{enumerate} 
   
\end{ex}
The probabilistic condition is again equivalent to the
non-probabilistic condition and there is no point in going to the
extra expense of computing the probability.

The witness condition for `no$^{\text{w}}$($P$)' is given in
\nexteg{}.
\begin{ex} 
$X:\text{no}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item $p(\mathfrak{T}(X)\|\mathfrak{T}(P))=0$ (corresponds to $|X|=0$) 
 
\end{enumerate} 
   
\end{ex}
Again the probabilistic and non-probabilistic conditions are
equivalent and there is no point to computing the probability since
all we have to do is check that the witness set is the empty set.

The witness condition for `every$^{\text{w}}$($P$)' is given in
\nexteg{}.
\begin{ex} 
$X:\text{every}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item $p(\mathfrak{T}(X)\|\mathfrak{T}(P))=1$ (corresponds to $|X|=|\down{\mathfrak{T}(P)}|$) 
 
\end{enumerate}  
\end{ex}
Again the probabilistic and non-probabilistic conditions are
equivalent given the frequentist interpretation of probability.
However, here there is some point to the probability for semantic
processing. Both the conditions as formulated require counting the set
of objects which have the property, $P$, which can be intractable
especially if the set is infinite or finite and reasonably large.
However, the probability can be estimated on the basis of a finite
number of observations.  The more relevant observations you have, the
more reliable your estimate.  Consider the sentence in \nexteg{}.
\begin{ex} 
Every dog barks when it is time to go for a walk 
\end{ex} 
An utterance of \preveg{} is naturally interpreted to be quantifying
over dogs in general, or at least those which are physically capable
of barking.  I have no practical way of determining the truth or
falsity of this
sentence, though I can make an estimate on the basis my observations
of dogs in pre-walk situations.  If all relevant observations of dogs
involved the dog barking, then I can estimate that the sentence is
true.  Of course, if I have only observed
two or three dogs, my estimate is not very reliable even though it is
consistent with my experience.  If on the other hand I have observed
hundreds of situations where a dog is about to go for a walk, all of
them with the dog barking, then it seems like a more reliable estimate,
although my experience will not show conclusively that it will be
true.  How do sentences like this get used in a dialogue.  Consider
the (constructed) dialogue in \nexteg{}.
\begin{ex} 
\begin{tabular}[t]{lp{.8\textwidth}}
\multicolumn{2}{p{.9\textwidth}}{\textit{$A$ and $B$ are about to
  take $A$'s  dog
  for a walk.  The dog, realizing that a walk is in the offing, begins
  to bark excitedly.}}\\
$A:$ & I must apologize for the racket.\\
$B:$ & Not to worry. Every dog barks when it is time to go for a
       walk. \textit{$B$ is thinking of her past experience of dogs in
       similar situations.}\\
$A:$ & Yes, that's right. \textit{$A$ is thinking of
       \emph{her} past experience of dogs in similar situations.}
\end{tabular}
\label{ex:walkies}
\end{ex} 
$A$ and $B$ are agreeing on the basis of their own distinct
observations.  They both know what the sentence means but they both
also know that it is not practically possible for a human agent to
verify the truth of the sentence on the set-based view or its
equivalent frequentist probabilistic interpretation and therefore that
the basis for the assertion must be a probability estimation.  The
situation seems similar to that with predicates of personal taste on
the kind of approach taken by \cite{Cooper2015a,Cooper2017c}.
Consider the (constructed) dialogue in \nexteg{}.
\begin{ex} 
\begin{tabular}[t]{lp{.8\textwidth}}
\multicolumn{2}{p{.9\textwidth}}{\textit{$A$ and $B$ are eating lunch
  together and have just been served soup}}\\
$A:$ & \textit{(tasting the soup)}  Hhm, this soup is good.
       \textit{$A$ is basing her assertion on her taste sensations.}\\
$B:$ & \textit{(also tasting the soup)} You're right.  It
       is. \textit{$B$ is basing her assertion on \emph{her} taste
       sensations.}
\end{tabular}
\label{ex:taste}
\end{ex} 
Again $A$ and $B$ are agreeing on the basis of their own distinct
observations.  The reason here, however, does not have to do with the
impracticality of counting a large set but rather that it is not
possible to directly observe another person's taste sensation. But
there is also an important difference between (\ref{ex:walkies}) and
\preveg{}.  In (\ref{ex:walkies}) there is a fact of the matter which
is being discussed.  For example, consider the continuation of
(\ref{ex:walkies}) given in \nexteg{} where a third dialogue participant, $C$, joins the
conversation.
\begin{ex} 
\begin{tabular}[t]{lp{.8\textwidth}}
$C:$ & Actually, I used to have a dog which never barked except when
       he saw another dog or a squirrel. \\
$B:$ & OK, then, \textit{most} dogs bark when it's time for a walk /
       \#Well, \textit{I} think that every dog barks when it's time
       for a walk
\end{tabular}
\end{ex} 
This contrasts with a continuation of (\ref{ex:taste}) in a similar
vein.
\begin{ex} 
\begin{tabular}[t]{lp{.8\textwidth}}
$C:$ & No, this soup is not good.\\
$A:$ & \#OK, then the soup is sort of/mostly good / Well, \textit{I}
       think it's good. 
\end{tabular}
\end{ex} 
What the examples have in common is that the justification for the
assertions of the same ``proposition'' is different facts based on
personal experience.   Where they differ is in whether there is an
objective fact or not.

A similar discussion holds for \textit{most}. The witness condition for `most$^{\text{w}}$($P$)' is given in \nexteg{}. 
\begin{ex} 
$X:\text{most}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item $p(\mathfrak{T}(X)\|\mathfrak{T}(P))\geq\theta_{\text{most}}(P)$ (corresponds to $\frac{|X|}{|\downP{P}|}\geq\theta_{\text{most}}(P)$) 
 
\end{enumerate}  
\end{ex}
As usual the frequentist interpretation of the conditional probability
is equivalent to the corresponding non-probabilistic.  In order to see
this note that
\nexteg{} holds.
\begin{ex} 
$\frac{|\down{\mathfrak{T}(X)\wedge\mathfrak{T}(P)}|}{|\down{\mathfrak{T}(P)}|}=\frac{|X|}{|\downP{P}|}$
\end{ex} 
\preveg{} holds because of the equalities in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item $|\down{\mathfrak{T}(X)}|=|X|$ since $\down{\mathfrak{T}(X)}=X$ 
 
\item $\down{\mathfrak{T}(P)}=\downP{P}$

\item
  $|\down{\mathfrak{T}(X)\wedge\mathfrak{T}(P)}|=|\down{\mathfrak{T}(X)}|$
    since $\down{\mathfrak{T}(X)}\subseteq\down{\mathfrak{T}(P)}$
    (since $X:\{\mathfrak{T}(P)\}$)
 
\end{subex} 
   
\end{ex} 
Again, to make an evaluation when large sets are involved we may need to
estimate the relevant probability on the basis of our own experience
and the kind of dialogue which we illustrated for \textit{every} might
occur.

The witness
condition for `many$_a^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{many}_a^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item
$p(\mathfrak{T}(X)\|\mathfrak{T}(P))\geq\frac{\theta_{\text{many}_a}(P)}{[\down{\mathfrak{T}(P)}]}$
  (corresponds to $|X|\geq\theta_{\text{many}_a}(P)$) 
 
\end{enumerate} 
\end{ex}
Again the probabilistic condition on the frequentist interpretation is equivalent to the
non-probabilistic one since both require that the cardinality of $X$ is
greater than or equal to $\theta_{\text{many}_a}(P)$.

The witness condition for `many$_p^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{many}_p^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\{\mathfrak{T}(P)\}$ 
 
\item
  $p(\mathfrak{T}(X)\|\mathfrak{T}(P)\geq\theta_{\text{many}_p}(P)$ (corresponds to $\frac{|X|}{|\downP{P}|}\geq\theta_{\text{many}_p}(P)$) 
 
\end{enumerate}  
\end{ex}     
Again, the frequentist interpretation of the probabilisitic condition
is equivalent to the non-probabilistic condition and with large sets
we may need to estimate the probability rather than compute the
cardinality of the witness set.
    

\subsection{Witness conditions for quantificational ptypes}

\subsection{Some examples}



\section{Anaphora}
\label{sec:anaph}

\subsection{\textit{No girl thinks she failed}}

Given the strategy we suggested in Section~\ref{sec:unbound} for
interpreting unbound pronouns  the foreground of a content for
\textit{she failed} would be \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}} . \record{\tfield{e}{fail($\mathfrak{s}$.x$_0$)}} 
\end{ex} 
Call this \textbf{she$^\frown$failed}.  Then the foreground of the
content for \textit{thinks she failed} is \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
  . $\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
    . \record{\tfield{e}{think($r$.x,
        \textbf{she$^\frown$failed}($\mathfrak{s}$))}}
\label{ex:thinks-she-failed-x0} 
\end{ex} 
Call this \textbf{thinks$^\frown$she$^\frown$failed$_{x_0}$}. Here
\textit{she} is still a free occurrence of a pronoun dependent on the
context for resolution.  An alternative interpretation is \nexteg{},
where the pronoun has become bound as the subject of the property.
\begin{ex} 
$\lambda\mathfrak{s}$:\textit{Rec} . $\lambda
r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
. \record{\tfield{e}{think($r$.x, \textbf{she$^\frown$failed}($\mathfrak{s}\oplus$\smallrecord{\field{x$_0$}{$r$.x}}))}} 
\end{ex} 
We will call this a logophoric interpretation of the verb phrase,
\textbf{thinks$^\frown$she$^\frown$failed$_{\mathrm{lg}}$}. These two
readings for the verb-phrase yields two alternatives for the complete
sentence, one where the pronoun remains unbound as in \nexteg{a} and
one where it is bound as in \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item
  $\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
    . \record{\tfield{e}{no(girl$'$, \textbf{thinks$^\frown$she$^\frown$failed$_{x_0}$}($\mathfrak{s}$))}} 
 
\item $\lambda\mathfrak{s}$:\textit{Rec}
  . \record{\tfield{e}{no(girl$'$, \textbf{thinks$^\frown$she$^\frown$failed$_{\mathrm{lg}}$}($\mathfrak{s}$))}} 
 
\end{subex} 
   
\end{ex} 

Let us now consider an option where we store the interpretation of
\textit{no girl}.  For this we ill use the abbreviatory notation
\nexteg{b} for \nexteg{a}
\begin{ex} 
\begin{subex} 
 
\item \record{\field{bg}{$T_1$}\\
              \field{fg}{$\lambda\mathfrak{v}$:$T_1$ . $T_2(\mathfrak{v})$}} 
 
\item $\ulcorner\lambda\mathfrak{v}$:$T_1$ . $T_2(\mathfrak{v})\urcorner$
 
\end{subex} 
   
\end{ex} 
[????We should introduce this notation from the beginning, starting
p. 121 ``Parametric contents as we have presented them so far are
problematic...''] If $\frec{f}$ is a record as
characterized in \preveg{} then we use the notation $\frec{f}(a)$ to
represent $\frec{f}.\text{fg}(a)$, that is, $f(a)$. 

Interpreting \textit{no girl} with storage yields \nexteg{}.
\begin{ex} 
\record{\field{quants}{\{$\ulcorner\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
      . $\lambda P$:\textit{Ppty} . \record{\tfield{e}{no(girl$'$,
          $P$(\smallrecord{\field{x}{$\mathfrak{s}$.x$_1$}}))}}$\urcorner$\}}\\
\field{core}{$\ulcorner\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
  . $\lambda P$:\textit{Ppty} . $P$(\smallrecord{\smalltfield{x}{$\mathfrak{s}$.x$_1$}})$\urcorner$}} 
\end{ex} 
Then \textit{no girl thinks she failed} yields \nexteg{}.
\begin{ex} 
 \record{\field{quants}{\{$\ulcorner\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
      . $\lambda P$:\textit{Ppty} . \record{\tfield{e}{no(girl$'$,
          $P$(\smallrecord{\field{x}{$\mathfrak{s}$.x$_1$}}))}}$\urcorner$\}}\\
\field{core}{$\ulcorner\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
      . \record{\tfield{e}{\textbf{thinks$^\frown$she$^\frown$failed$_{x_0}$}($\mathfrak{s}\oplus$\smallrecord{\field{x$_0$}{$\mathfrak{s}$.x$_1$}})}}$\urcorner$}}
\end{ex} 
\preveg{} uses the definition of
\textbf{thinks$^\frown$she$^\frown$failed$_{x_0}$} given in
(\ref{ex:thinks-she-failed-x0}).  Let us call the value of the
`core'-field in \preveg{}
\textbf{thinks$^\frown$she$^\frown$failed$_{x_1}$}.  Then the result
of applying retrieval to \preveg{} is \nexteg{}.
\begin{ex} 
\record{\field{quants}{\{\}}\\
        \field{core}{$\ulcorner\lambda\mathfrak{s}$:\textit{Rec}
          . \record{\tfield{e}{no(girl$'$, $\lambda
              r$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}} .  \textbf{thinks$^\frown$she$^\frown$failed$_{x_1}$}($\mathfrak{s}\oplus$\smallrecord{\field{x$_1$}{$r$.x$_1$}})})}$\urcorner$}}
\end{ex} 
     
\subsection{\textit{A man walked. He whistled.} }

Given our strategy for defining the content of quantified sentences in
terms of generalized quantifiers the content of \textit{a man walked}
will be \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:\textit{Rec} . \record{\tfield{e}{exist(man$'$, walk$'$)}} 
\end{ex} 
This does not give us a field which \textit{he} could pick up on to
obtain the anaphoric reference.  However, we can show that the type
in \nexteg{a} and \nexteg{b} are truth-conditionally equivalent, that is,  \nexteg{a}
has a witness just in case \nexteg{b} has a witness.
\begin{ex} 
\begin{subex} 
 
\item exist(man$'$, walk$'$) 
 
\item \record{\tfield{x}{\textit{Ind}}\\
              \tfield{c}{man(x)}\\
              \tfield{e}{walk(x)}}
 
\end{subex} 
\label{ex:amw-drt}  
\end{ex} 
The argument for this goes as follows.  By an argument parallel to
that in (\ref{ex:witnessconds-edr}c) we can show that \nexteg{a} and
\nexteg{b} are equivalent.
\begin{ex} 
\begin{subex} 
 
\item $s$ : exist(man$'$, walk$'$) 
 
\item $\{a\mid\exists s'[s':\text{man}(a)]\}\cap\{a\mid\exists
  s'[s':\text{man}(a)]\wedge\exists s'[s'\underline{\varepsilon}s\wedge s':\text{walk}(a)]\}\not=\emptyset$ 
 
\end{subex} 
\label{ex:amw-wit}   
\end{ex} 
This entails \nexteg{a} which, because of the arity of `man' and
`walk', is equivalent to \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item $\exists a[\exists s'[s':\text{man}(a)]\wedge\exists s'[s':\text{walk}(a)]]$
 
\item $\exists a[a:\textit{Ind}\wedge\exists s'[s':\text{man}(a)]\wedge\exists s'[s':\text{walk}(a)]]$ 
 
\end{subex} 
   
\end{ex} 
If \preveg{b} is true, then it will be possible to construct a witness
for (\ref{ex:amw-drt}b).  On the other hand, if $s$ is of type
(\ref{ex:amw-drt}b), then (\ref{ex:amw-wit}b) will be true so there
will be a witness for (\ref{ex:amw-drt}a), for example, $s$ itself.
Thus if it has been asserted that there is a situation of type
(\ref{ex:amw-drt}a), it is safe to assume that there is a situation of
type (\ref{ex:amw-drt}b) (assuming that the assertion was true).
(\ref{ex:amw-drt}b) gives us a field which can be picked up by anaphora.  

@@  

\subsection{every farmer who owns a donkey likes it}
\label{sec:donkey-anaph}[donkey anaphora]

\section{Structured contexts, binding principles and projection}
\label{sec:struc-cntxt}

\section{Compositional semantics and incremental processing}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "ttl"
%%% End: 
