\chapter{Witness-based quantification and type-based underspecification}
\label{ch:quant}
\setcounter{equation}{0}



\section{Introduction}

In this chapter we are going to explore how the TTR approach to
semantics we have developed gives us a novel treatment of quantification and binding in
natural language.

In Section~\ref{sec:quantification} we are going to propose a revision of witness conditions for
quantificational ptypes which will constitute what we will call a
\textit{witness based} account of generalized quantifiers. % which will be inconsistent with some of what
% we said before in the book about their witness conditions  --
% eventually we need to go back and revise the previous discussion and
% also the section on anaphora following this section.
The motivation
for this is in part to get a neater treatment of anaphora, and a more
general treatment along the lines of \cite{LueckingGinzburg2019}.
   
In Section~\ref{sec:binding-anaph} we will look at how the witness
based approach to quantification interacts with binding and anaphoric
phenomena.

Finally, in Section~\ref{sec:qscope-underspec}, we will explore a way
of treating underspecification in terms of types of content rather
than the standard view of underspecification in terms of underspecified representations corresponding to sets of contents.
    

\section{Quantification}
\label{sec:quantification}

\subsection{Conservativity and dynamic generalized quantifiers}

Here we review the treatment of quantifiers that we have presented so
far and its relation to the notion of \textit{conservativity} which we
will discuss here.  This property of conservativity facilitates the
witness-based account of quantifiers that we will undertake below.

In Chapter~\ref{ch:commonnouns}, example (\ref{ex:dynqconstr}), we
introduced the notion of dynamic generalized quantifier and pointed
out that one of the original motivations for them was what is known as
donkey anaphora which we will discuss in Section~\ref{sec:anaph}.
Here we will point out a connection between dynamic quantifiers and
conservativity of quantifiers, noted in \cite{Chierchia1995}.  The informal way to state
conservativity for quantifiers is as in \nexteg{a} and an example is
given in \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item Q A B is true just in case Q A A\&B is true 
 
\item \textit{every farmer likes a donkey} is true just in case
  \textit{every farmer is a farmer and likes a donkey} (or more
  naturally, \textit{every farmer is a farmer who likes a donkey}) is true
 
\end{subex} 
   
\end{ex} 
Most, if not all, natural language quantifiers have this
property.\footnote{For discussion, see \cite{PetersWesterstahl2006},
  p. 138f.}

Now consider the discussion of dynamic generalized quantification in Chapter~\ref{ch:commonnouns}, Section~\ref{sec:dgqs}.  There in
example~(\ref{ex:dynqconstr}) we gave dynamic versions of generalized
quantifier interpretations of noun-phrases.  % We can give a general characterization of the witness
% conditions for dynamic generalized quantifiers as in \nexteg{}, where
% $q$ is a predicate corresponding to a quantifier and $q^*$ is the
% relation between sets corresponding to $q$ in classical generalized
% quantifier theory.
% \begin{ex} 
% $e:q(P,Q)$ iff $q^*$ holds between $\downP{P}$ and
% $\downP{Q|_{\mathcal{F}(P.\mathrm{fg})}\restriction e}$
% \label{ex:witness-cond-GQ}
% \end{ex} 
% According to the definitions given in Chapter~\ref{ch:commonnouns},
% $\downP{Q|_{\mathcal{F}(P.\mathrm{fg})}\restriction e}$ is the set of
% individuals which have property $Q|_{\mathcal{F}(P.\mathrm{fg})}$ in
% $e$ and $Q|_{\mathcal{F}(P.\mathrm{fg})}$ is $Q$ with its
% domain restricted by $P$ (example~(\ref{ex:function-restriction}), p.~\pageref{ex:function-restriction}).
We spell out the witness condition for the quantificational ptype, \nexteg{b},
corresponding to \textit{every dog runs} in \nexteg{}.  % Here, as
% before, we only represent the foregrounds of the properties which are
% arguments to the predicate `every' in order to make the presentation
% clearer.

\begin{ex} 
\begin{subex} 
 
\item dog$'$ = $\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
    . \smallrecord{\smalltfield{e}{dog($r$.x)}}$\urcorner$ 

run$'$ = $\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
    . \smallrecord{\smalltfield{e}{run($r$.x)}}$\urcorner$
 
\item $T$ = every(dog$'$, run$'\mid_{\mathfrak{F}(\text{dog}')}$)

\item \begin{tabbing}
$s:T$ \=iff
$\downP{\text{dog}'}\subseteq\downP{\text{run}'|_{\mathcal{F}(\text{dog}')}\restriction
s}  $ \hspace*{2em}(witness condition for `every', p.~\pageref{ex:witcond-every})\\
\> iff  $\downP{\text{dog}'}\subseteq\downP{\text{run}'|_{\text{\smallrecord{\smalltfield{x}{\textit{Ind}}\\\smalltfield{e}{dog(x)}}}}\restriction
s}  $ \hspace*{2em}(fixed point types, p.~\pageref{ex:fixedpointtype})\\
\> iff $\downP{\text{dog}'}\subseteq$ [$\downarrow\lambda
r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}\d{$\wedge$}\smallrecord{\smalltfield{x}{\textit{Ind}}\\\smalltfield{e}{dog(x)}}
     . \smallrecord{\smalltfield{e}{run($r$.x)}}$\restriction s$ ]
     \hspace*{2em} (function restriction, p.~\pageref{ex:function-restriction})\\
\> iff $\downP{\text{dog}'}\subseteq$ [$\downarrow\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\\smalltfield{e}{dog(x)}}
     . \smallrecord{\smalltfield{e}{run($r$.x)}}$\restriction s$ ]
     \hspace*{2em}\begin{minipage}{.3\textwidth}(merge, p.~\pageref{pg:merge})\end{minipage}\\
\> iff $\downP{\text{dog}'}\subseteq$ [$\downarrow\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\\smalltfield{e}{dog(x)}}
     . \smallrecord{\smallrfield{e}{$s$}{run($r$.x)}}
     ]\hspace*{2em}\begin{minipage}{.3\textwidth}(property restriction,
      p.~\pageref{pg:property-restriction})\end{minipage}\\
\> iff \=$\{a\mid\exists r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
  $\wedge
  r.\text{x}=a\wedge\down{\text{\smallrecord{\smalltfield{e}{dog($r$.x)}}}}\not=\emptyset\}$\\
\>\>$\subseteq\{a\mid\exists r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\\smalltfield{e}{dog(x)}}
  $\wedge
  r.\text{x}=a\wedge\down{\text{\smallrecord{\smallrfield{e}{$s$}{run($r$.x)}}}}\not=\emptyset\}$
  \hspace*{2em}($\downarrow$, p.~\pageref{pg:property-extension-rev})
  \\
\> iff
$\{a\mid\down{\text{dog}(a)}\not=\emptyset\}\subseteq\{a\mid\down{\text{dog}(a)}\not=\emptyset\wedge\exists
s'[s'\underline{\varepsilon}s\wedge
s':\text{run}(a)]\}$\\
\>\`\begin{minipage}{.3\textwidth}(Arity of `dog', `run' and set
extension of records,  p.~\pageref{pg:set-reduction-gq}ff)\end{minipage}\\ 
\> iff $\{a\mid\exists s'[s':\text{dog}(a)]\}\subseteq\{a\mid\exists
s'[s':\text{dog}(a)]\wedge\exists
s'[s'\underline{\varepsilon}s\wedge s':\text{run}(a)]\}$ \\
\>\`\begin{minipage}{.3\textwidth}($\down{T}$, p.~\pageref{pg:type-extension})\end{minipage}
\end{tabbing} 
\end{subex} 
\label{ex:witnessconds-edr}   
\end{ex} 
  


\subsection{Witness sets}



The classical view of quantifiers is based on the notion that noun
phrases represent sets of sets or set of properties and the definition of a
quantifier involves characterizing which set of sets or properties it
represents.  This was the view presented, for example, in
\cite{BarwiseCooper1981}.  Associated with this was the notion of
\textit{witness set} defined by Barwise and Cooper as in \nexteg{}.
\begin{ex} 
A \textit{witness set} for a quantifier $D(A)$ living on $A$ is any
subset $w$ of $A$ such that $w\in D(A)$. 
\end{ex} 
In \preveg{} $D$ was used as the function corresponding to a
determiner such as \textit{some} or \textit{most} mapping a set $A$
(corresponding, for example, to the set denoted by a common noun phrase such
as  \textit{farmer} or \textit{farmer who owns a donkey}) to a set of
sets.  The notion \textit{lives on} used by Barwise and Cooper
corresponds to what was later in the literature referred to as
\textit{conservativity}.  Their definition of the lives-on property,
slightly simplified by removing reference to the model, is given in \nexteg{}.
\begin{ex} 
A quantifier $Q$ \textit{lives on} a set $A$ if $Q$ is a set of sets
with the property that
\begin{quote}
$X\in Q \text{ iff } (X\cap A)\in Q$
\end{quote}  
\end{ex} 
This means that the notion of witness set given by Barwise and Cooper
is defined for conservative quantifiers.  Examples of witness sets
that they give include: a witness set for the quantifier corresponding
to a proper name \textit{John} as the singleton set containing the
individual John;  a witness set corresponding to \textit{a woman} as
any non-empty set of women; a witness set corresponding to
\textit{most women} as a set of women which contains most women.

The notion of witness set
was introduced by Barwise and Cooper in a section called
\textit{Processing Quantified Statements}.  It was introduced 
as an auxiliary notion which could be used in an account of how an
agent might evaluate the truth of a quantified statement.  This
suggests that it should play an important role in a theory of
semantics like ours which is oriented towards explaining cognitive
semantic processing, especially if it is a theory which attempts to do
this in terms of judgements that objects (including situations) are
witnesses of types.  It seems natural to make a link between the
notion of witnesses for types and the notion of witnesses for
quantifiers.  We will go further and suggest that the characterization
of the meaning of determiners is based on witness sets, thus elevating
the witness sets from an auxiliary notion derived from the meaning
assigned to quantifiers to the central notion which characterizes the
distinctions between the various quantifier meanings available, just
as in type theory the notion of meaning is characterized in terms of
the witness conditions for types.  In doing this we will be going at
least part way to meeting some of the requirements of the proposals by \cite{GinzburgPurver2008,LueckingGinzburg2019}.

In the literature on generalized quantifiers \cite{Benthem1984}
introduced the perspective that we should think of determiners as
representing relations between sets rather than as mappings from sets
to families of sets.  This is reflected in our characterization of
quantifier relations as relations between properties (which can be
used to generate the set of objects which have the property) and the
use of ptypes constructed with quantifier relations and two properties
as arguments.

With each quantifier relation, $q$, and property, $P$, we will
associate a type of witness sets $q^w(P)$.  For example, a set, $X$,
is of type $\text{most}^w(P)$ if $X$ is a set of objects with property
$P$ which contains most of the objects which have property $P$.  We
will say that a witness for the quantificational ptype `most($P$,
$Q$)' is a pair (coded as a record and thus corresponding intuitively
to a situation) consisting of the set, $X$, where  $X:q^w(P)$
(i.e. $X$ is a witness set for $q$ and $P$) and a function, $f$,  whose domain
is $X$ and such that for any $a\in X$, $f(a)$ is a situation which
shows that $a$ has property $Q$.  In general for distributive readings
of monotone increasing
quantifiers, $q$, we can say that a witness for $q(P, Q)$ provides a
witness set $X$ of type $q^w(P)$ and a function which shows that every
member of $X$ has the property $Q$. For distributive readings of
monotone decreasing quantifiers we need a different kind of function
together with the witness set.  Here we have to check that everything
which has both property $P$ and property $Q$ is a member of the
witness set.  Thus we need a function, $f$, whose domain is the set of
objects having both $P$ and $Q$, such that if $a$ is in this set then
$f(a)$ is a situation which shows that $a$ is a member of the witness
set $X$.  These two kinds of functions correspond exactly to the
evaluation procedures suggested in \cite{BarwiseCooper1981} quoted in
\nexteg{}.
\begin{ex} 
\textit{To evaluate $X\in D(A)$ do the following:}
\begin{enumerate} 
 
\item Take some subset $w$ of $A$ which you know to be in $D(A)$ 
 
\item 
\begin{enumerate} 
 
\item[(i)] For mon$\uparrow$ $D(A)$, check $w\subseteq X$. 
 
\item[(ii)] For mon$\downarrow$ $D(A)$, check $(X\cap A)\subseteq w$
 
 
\end{enumerate} 
\item If there is such a $w$, the sentence is true.  Otherwise it is false.   
 
\end{enumerate} 
   
\end{ex} 

Using pairs of witness sets and functions as witnesses for
quantificational ptypes is also closely related to
the treatment of quantification in Martin-Löf type theory using
$\Sigma$-types and dependent types.  (See, for example,  discussion in
\citealp{Ranta1994}.)  A witness for the $\Sigma$-type \nexteg{a}
would be an ordered pair as characterized in \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item $(\Sigma x:A)B(x)$ 
 
\item $\langle a,b\rangle$ where $a:A$ and $b:B(a)$ 
 
\end{subex} 
   
\end{ex} 

In the following subsections we will develop the tools we need to make
our analysis precise in terms of the TTR machinery we have developed
so far to create a witness-based analysis of quantfiers.  We will also
consider how we can move away from a set-based account of
quantification to a type-based approach where we can estimate the
probability of a quantificational ptype being witnessed on the basis
of our previous experience.  
    

\subsection{Relating properties, types and sets}

% [????In this section we revise the definition of properties.  We
% probably need to go back and revise previous definitions for
% consistency.]

% We first define a type of record types whose labels include a certain
% set of labels.  Let $L$ be a set of labels, then \textit{RecType}$_L$
% is a type.  $T$ : \textit{RecType}$_L$ iff $T$ : \textit{RecType} and
% $L\subseteq\text{labels}(T)$.  [????Check whether `labels' defined for
% record types -- it is defined for records.]

% Now we can define \textit{Ppty} to be the type in \nexteg{}.
% \begin{ex} 
% \record{\tfield{bg}{\textit{RecType}$_{\{x\}}$}\\
%         \tfield{fg}{(bg$\rightarrow$\textit{RecType})}} 
% \end{ex} 
% A witness for this type,  a property, would be something like
% \nexteg{}, ``the property of being a dog''.
% \begin{ex} 
% \record{\field{bg}{\smallrecord{\smalltfield{x}{\textit{Ind}}}}\\
%         \field{fg}{$\lambda
%           r$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . \record{\tfield{e}{dog($r$.x)}}}} 
% \end{ex} 
% This is a cumbersome notation for a property so we abbreviate it as
% \nexteg{}.
% \begin{ex} 
% $\ulcorner\lambda
%           r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
%           . \record{\tfield{e}{dog($r$.x)}}$\urcorner$ 
% \label{ex:ppty-dog}
% \end{ex}
% If $P$ is a property we will also use the notation $P(a)$ to represent $P.\text{fg}(a)$.
 
% \preveg{} is a property of individuals  and we will have a subtype of
% \textit{Ppty}, \textit{Ppty}(\textit{Ind}), to represent this more
% specific type of property. In general we give the definition in
% \nexteg{}.
% \begin{ex} 
% \begin{subex} 
 
% \item if $T$ is a type, then
% \textit{Ppty}($T$) is a type 
 
% \item $P$ : \textit{Ppty}($T$) iff
% $P$ : \textit{Ppty} and $P$.bg$^{\text{x}}$ is
% \smallrecord{\smalltfield{x}{$T$}} 
 
% \end{subex} 
   
% \end{ex} 
% Here we use $P$.bg$^{\text{x}}$
% to represent the generalization of $P$.bg to its `x'-field as
% characterized in Appendix~\ref{app:gen-rectypes}, that is the type
% whose only field is the `x'-field of $P$.bg. 

A property, $P$, can be \textit{pure}, as in \nexteg{a}, that is,
$P$.bg has exactly one field, the required `x'-field;  or it can be
restricted by including additional fields in the background as in
\nexteg{b}, the restricted property
of being an individual which is a dog that barks.
\begin{ex} 
\begin{subex} 
 
\item $\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
  . \record{\tfield{e}{bark($r$.x)}}$\urcorner$ 
 
\item $\ulcorner\lambda
  r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                  \smalltfield{c}{dog(x)}}
  . \record{\tfield{e}{bark($r$.x)}}$\urcorner$  
 
\end{subex} 
   
\end{ex} 
% Note that \preveg{b} is still of type \textit{Ppty}(\textit{Ind})
% according to our definition above.


The ability to restrict properties will be important for analyzing
dynamic quantification where information from the first argument of
the quantifier relation is passed to the second argument of the
quantifier relation and this is what enables the treatment of donkey
anaphora.  Thus \textit{every farmer who owns a donkey likes it} will
be treated as the `every'-relation holding between the property of
being a farmer and owning a donkey and the property of being a farmer
who owns a donkey and likes it thus providing an antecedent for
\textit{it} within the second property (see
Section~\ref{sec:donkey-anaph}). However, it will also be important to
be able to ``purify'' such restricted properties, that is, relate them
systematically to a corresponding property whose background contains just
the one `x'-field.  This will allow us to avoid the proportion problem
that can arise in the analysis of donkey anaphora, that is in
computing whether a
sentence like \textit{most farmers who own a donkey like it} is true, we need
to ensure that the majority of farmers who own a donkey are such that
they like it and not that the majority of pairs of farmers and donkeys
where the farmer owns the donkey are such that the farmer likes the
donkey. Thus we need a property of individuals, not of farmer-donkey
pairs.  Suppose we have the restricted property \nexteg{a}.  We will
define an operation on functions which will yield the pure property
\nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item $\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                               \smalltfield{c$_1$}{farmer(x)}\\
                               \smalltfield{y}{\textit{Ind}}\\
                               \smalltfield{c$_2$}{donkey(y)}\\
                               \smalltfield{e}{own(x, y)}}
                             . \record{\tfield{e}{like($r$.x, $r$.y)}}$\urcorner$
 
\item $\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . \record{\tfield{$\mathfrak{c}$}{\smallrecord{\smallmfield{x}{$r$.x}{\textit{Ind}}\\
                               \smalltfield{c$_1$}{farmer(x)}\\
                               \smalltfield{y}{\textit{Ind}}\\
                               \smalltfield{c$_2$}{donkey(y)}\\
                               \smalltfield{e}{own(x, y)}}}\\
        \tfield{e}{\record{\tfield{e}{like($\Uparrow$$\mathfrak{c}$.x,
              $\Uparrow$$\mathfrak{c}$.y)}}}}$\urcorner$ 
 
\end{subex} 
\label{ex:pure-eg}   
\end{ex} 
This purification operation changes the property in \preveg{a}, a
property of farmers who own a donkey into the property \preveg{b}, a
property of individuals.  The restriction in \preveg{a} has been
lowered into the body of the property and labelled with
`$\mathfrak{c}$', intuitively a local context in the type returned by
the function.

We first define an operation which will generalize a type to the type
containing one of its non-dependent fields.  This is just one way of
many to operate on a type to make it more general.  Consider \nexteg{}.
\begin{ex}
\record{\tfield{x}{\textit{Ind}}\\
        \tfield{e}{dog(x)}}
\end{ex}
We can pick out the `x'-field which is not dependent, unlike the
`e'-field. The result is \nexteg{}
\begin{ex}
\record{\tfield{x}{\textit{Ind}}}
\end{ex}
In general for a record type,  $T$, we will represent the generalization
of $T$ to its non-dependent $\ell$-field as $T^\ell$.
\begin{shaded}
The general
definition of this is \nexteg{}, repeated in Appendix~\ref{app:gen-rectypes}.
\begin{ex}
If $T$ : \textit{RecType}, $\ell\in\text{labels}(T)$ and
$\langle\ell,T'\rangle\in T$ where $T'$: \textit{Type} (that is,
$[\ell,T']$ is a non-dependent field in $T$), then \textit{the
  generalization of $T$ to its $\ell$-field}, $T^\ell$, is
\begin{quote}
\record{\tfield{$\ell$}{$T'$}}
\end{quote}
\label{ex:gen-to-ell}
\end{ex}
\end{shaded}


We denote the purification operation on properties by $\mathfrak{P}$
and define it as in \nexteg{}.
\begin{ex} 
If $P$ : \textit{Ppty}, then
\begin{quote}
if $P$.bg$^x$ = $P$.bg, then
\begin{quote}
$\mathfrak{P}(P)=P$
\end{quote}
otherwise:
\begin{quote}
$\mathfrak{P}(P)$ is $\ulcorner\lambda r$:$P$.bg$^{\text{x}}$
. \record{\tfield{$\mathfrak{c}$}{$P.\text{bg}\parallel$ \smallrecord{\field{x}{$r$.x}}}\\
          \tfield{e}{$P(\mathfrak{c})$}}$\urcorner$
\end{quote}
\end{quote}
\label{ex:purification}
\end{ex} 
(Recall that $T\!\!\parallel\!\! r$ is the result of specifying or anchoring
$T$ with the record $r$ as defined in Appendix~\ref{app:specrec}.)

As an example let us apply $\mathfrak{P}$ to (\ref{ex:pure-eg}a).  The
result will be \nexteg{}
\begin{ex} 
$\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . 
\record{\tfield{$\mathfrak{c}$}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                               \smalltfield{c$_1$}{farmer(x)}\\
                               \smalltfield{y}{\textit{Ind}}\\
                               \smalltfield{c$_2$}{donkey(y)}\\
                               \smalltfield{e}{own(x, y)}} $\parallel$
                             \smallrecord{\field{x}{$r$.x}}} \\  
        \tfield{e}{$\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                               \smalltfield{c$_1$}{farmer(x)}\\
                               \smalltfield{y}{\textit{Ind}}\\
                               \smalltfield{c$_2$}{donkey(y)}\\
                               \smalltfield{e}{own(x, y)}}
                             . \record{\tfield{e}{like($r$.x, $r$.y)}}$\urcorner$($\mathfrak{c}$)}}$\urcorner$
\label{ex:pure-eg1}
\end{ex} 
% Following the definition of generalization of a type to a particular
% field in Appendix~\ref{app:gen-rectypes}, \nexteg{a} represents
% \nexteg{b}.
% \begin{ex} 
% \begin{subex} 
 
% \item \smallrecord{\smalltfield{x}{\textit{Ind}}\\
%                                \smalltfield{c$_1$}{farmer(x)}\\
%                                \smalltfield{y}{\textit{Ind}}\\
%                                \smalltfield{c$_2$}{donkey(y)}\\
%                                \smalltfield{e}{own(x, y)}}$^x$ 
 
% \item \smallrecord{\smalltfield{x}{\textit{Ind}}} 
 
% \end{subex} 
   
% \end{ex} 
According to the definition of the specification of a record type by a
record, \nexteg{a} represents
\nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item \smallrecord{\smalltfield{x}{\textit{Ind}}\\
                               \smalltfield{c$_1$}{farmer(x)}\\
                               \smalltfield{y}{\textit{Ind}}\\
                               \smalltfield{c$_2$}{donkey(y)}\\
                               \smalltfield{e}{own(x, y)}} $\parallel$
                             \smallrecord{\field{x}{$r$.x}} 
 
\item \smallrecord{\smallmfield{x}{$r$.x}{\textit{Ind}}\\
                               \smalltfield{c$_1$}{farmer(x)}\\
                               \smalltfield{y}{\textit{Ind}}\\
                               \smalltfield{c$_2$}{donkey(y)}\\
                               \smalltfield{e}{own(x, y)}}  
 
\end{subex} 
   
\end{ex} 
To understand the reduction of the type in the `e'-field in (\ref{ex:pure-eg1}) we
represent it first in the official notation for dependent fields as in
\nexteg{a}.  This represents the same as \nexteg{b} (by
$\beta$-conversion) and its abbreviatory notation in the context of
(\ref{ex:pure-eg1}) is \nexteg{c}.
\begin{ex} 
\begin{subex} 
 
\item $\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                      \smalltfield{c$_1$}{farmer(x)}\\
                                      \smalltfield{y}{\textit{Ind}}\\
                                      \smalltfield{c$_2$}{donkey(y)}\\
                                      \smalltfield{e}{own(x,y)}}
                                    . $\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                      \smalltfield{c$_1$}{farmer(x)}\\
                                      \smalltfield{y}{\textit{Ind}}\\
                                      \smalltfield{c$_2$}{donkey(y)}\\
                                      \smalltfield{e}{own(x,y)}}
                                    . \record{\tfield{e}{like($r$.x,$r$.y)}}$\urcorner$($v$), $\langle\mathfrak{c}\rangle\rangle$
 
\item $\langle\lambda v$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                      \smalltfield{c$_1$}{farmer(x)}\\
                                      \smalltfield{y}{\textit{Ind}}\\
                                      \smalltfield{c$_2$}{donkey(y)}\\
                                      \smalltfield{e}{own(x,y)}}
                                    . 
                                    \record{\tfield{e}{like($v$.x,$v$.y)}},
                                      $\langle\mathfrak{c}\rangle\rangle$ 

\item \record{\tfield{e}{like($\Uparrow\!\mathfrak{c}$.x,$\Uparrow\!\mathfrak{c}$.y)}}
 
\end{subex} 
   
\end{ex} 
Making these substitutions yields (\ref{ex:pure-eg}b).

If $P$ is a pure property, we will use the notation $P\{a\}$ to
represent the type $P$(\smallrecord{\field{x}{$a$}}).  If $P\{a\}$ is
witnessed we say that $a$ has property $P$.  We can now define the
type of objects which have $P$, which we will represent as
$\mathfrak{T}(P)$. We introduce this type as in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item If $P$ : \textit{Ppty}, then $\mathfrak{T}(P)$ : \textit{Type}. 
 
\item $a:\mathfrak{T}(P)$ iff $\mathfrak{P}(P)\{a\}$ is witnessed. 
 
\end{subex} 
   
\end{ex} 
There is a different route to a type with the same witnesses as
$\mathfrak{T}(P)$.  We have previously defined $\downP{P}$ as the
set of objects which have the property $P$, as in
Chapter~\ref{ch:commonnouns}, p.~\pageref{pg:property-extension-rev}.  For
any set, $X$, we can define a type whose witnesses are exactly the
members of $X$.  We will represent this type as $\mathfrak{T}(X)$ and
introduce it as in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item If $T$ is a type and $X:\mathrm{set}(T)$, then $\mathfrak{T}(X)$ is a type 
 
\item $a:\mathfrak{T}(X)$ iff $a\in X$ 
 
\end{subex} 
\label{ex:mathfrakT}   
\end{ex} 
Given this, it is straightforward to see that \nexteg{} holds.
\begin{ex} 
For any property, $P$, $a:\mathfrak{T}(P)$ iff
$a:\mathfrak{T}(\downP{P})$ 
\end{ex} 
What distinguishes these two types is the method they suggest for
determining whether something is a witness for the type.  In the case
of $\mathfrak{T}(\downP{P})$ we have to first determine the complete
set of objects which have the property and then determine whether the
object in question is a member of the set.  In the case of
$\mathfrak{T}(P)$ we only have to determine whether the object in
question has the property $P$.  Computing the set of all objects which
have a property may be viable when we are considering a property whose
extension is a small finite set of objects (for example, if the
property is that of being a dog in a particular small situation) but
it does not seem feasible in the case of large finite sets or infinite
sets.  We will return to this issue below when we consider the
interpretation of generalized quantifiers which are classically
treated by comparing sets and we will consider an alternative in terms
of types and estimated probabilities.        
     

\subsection{Types of witness sets for quantifiers}
\label{sec:witset-types}
In this section we will discuss the characterization of types of
witness sets for various generalized quantifiers as a step on our way
to characterizing a witnessed-based account of generalized
quantifiers.  The witness sets we characterize will be very close to
those of \cite{BarwiseCooper1981}, though not exactly the same in all
cases.  In general for a quantifier relation, $q$, and property,
$P$, a witness set, $X$, of type $q^w(P)$ must meet two conditions.  The
first is that it must be a subset of the property extension of $P$.
We now have two ways of expressing this as shown in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item $X\subseteq\downP{P}$
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\end{subex} 
   
\end{ex} 
\preveg{a} makes explicit the connection to the original definition of
witness sets by Barwise and Cooper.  \preveg{b} is an equivalent
condition on $X$ which does not involve the computation of the
complete property extension of $P$.

The second condition which must be met by witnesses, $X$, of $q^w(P)$ is a
cardinality condition on $X$.  This may be an absolute condition on
the size of $X$ or it may involve a comparison of the size of $X$ with
the size of the property extension of $P$, that is, $\downP{P}$.  Thus
even though we have a way of avoiding the computation of the total
property extension in the first condition on witness sets, we will not
always be able to avoid it in the second condition.  It is for this
reason that we will move to probability estimations in the next
section.

The witness condition for `exist$^{\text{w}}$($P$)' is given in
\nexteg{}.
\begin{ex} 
$X:\text{exist}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $|X|=1$ 
 
\end{enumerate} 
   
\end{ex}
Note that this differs from Barwise and Cooper in that it requires
that the witness set contain exactly one object having property $P$
rather than at least one such object.  The quantifier relation `exist'
is used in interpreting the English determiner \textit{a} and also the
singular determiner \textit{some}.  Plural \textit{some} corresponds
to the quantifier relation `exist$_{\text{pl}}$'.  The witness condition for `exist$_{\text{pl}}^{\text{w}}$($P$)' is given in
\nexteg{}.
\begin{ex} 
$X:\text{exist}_{\text{pl}}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $|X|\geq 2$ 
 
\end{enumerate} 
   
\end{ex}
Correspondingly we can define the witness condition for `no$^{\text{w}}$($P$)' is given in
\nexteg{}.
\begin{ex} 
$X:\text{no}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $|X|=0$ 
 
\end{enumerate} 
   
\end{ex}
\preveg{} could, of course, be given more concisely as \nexteg{}.
\begin{ex} 
$X:\text{no}^{\text{w}}(P)$ iff $X=\emptyset$
\end{ex}

The witness condition for `every$^{\text{w}}$($P$)' is given in
\nexteg{}.
\begin{ex} 
$X:\text{every}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $|X|=|\down{\mathfrak{T}(P)}|$ 
 
\end{enumerate}  
\end{ex} 
Note that \preveg{} requires $X$ to be identical with $\down{\mathfrak{T}(P)}$ and
we could, of course, express the witness condition more succinctly as
\nexteg{} if we are not concerned about demonstrating that the witness
conditions for the types witness sets for all quantifiers follow the
same pattern.
\begin{ex} 
$X:\text{every}^{\text{w}}(P)$ iff $X=\down{\mathfrak{T}(P)}$ 
\end{ex} 
Either way, we seem committed to computing the set $\downP{P}$ in
order to compute a witness set of `every' and $P$ and this can
therefore lead to problems if $\downP{P}$ is a large set.  A standard
way of avoiding the computation of this set in the interpretation of
universal quantification is to associate universal quantification with
a function so that, using the notions we have built up,  a witness for `every($P$,$Q$)' would be a function
from $\mathfrak{T}(P)$ to $\mathfrak{T}(Q)$ (see \citealp{Ranta1994},
for discussion of how this is done in a standard Martin-Löf type
theory).  This avoids computing the property extension of $P$ if we
have the right view of functions as intensional objects or procedures,
rather than the von Neumann notion of function as a set of ordered
pairs as is standard in set theory.  We will make use of such
functions when we come to treat the witness conditions for
quantificational ptypes.  Such a treatment on its own does not yield a
characterization of a witness set, however, and thus does not
immediately yield a way of treating plural discourse anaphora with
a universal quantifier as antecedent as in \nexteg{}.
\begin{ex} 
Every dog ran into the field.  They had seen the rabbits. 
\end{ex} 
For this reason we will pursue the witness set approach and attempt to
solve the problem of large sets by introducing probability estimation.  


In order to account for the witness condition for `most$^{\text{w}}$'
we assume that there is a threshold,
$\theta_{\text{most}}(P)$, which tells you what proportion of the
property extension of $P$ has to be included in the witness set.  This
is possibly an oversimplification in that the threshold may depend on
more than the quantifier relation and the first argument property
to the relation.  A common assumption in the generalized quantifier
literature is that `most($P$,$Q$)' is true just in case at least one more than
half of the $P$s are $Q$ (see, for example,
\citealp{PetersWesterstahl2006}).  This may be true if the property
extension of $P$ is a small finite set.  But it hardly seems to be the
case for an example involving a larger set as in \nexteg{}.
\begin{ex} 
Most supporters in the stadium cheered when the goal was scored. 
\end{ex} 
\preveg{} does not appear to be true if only one more than half of the
forty thousand supporters in the stadium cheered.  Rather we would expect the number
of cheering supporters to be something in excess of 75\% or 85\%  of the
supporters in the stadium.  The unclarity as to exactly which
proportion is involved leads us to introduce a threshold which can
vary with the context and the speaker.  

The witness condition for `most$^{\text{w}}$($P$)' is given in \nexteg{}. 
\begin{ex} 
$X:\text{most}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $\frac{|X|}{|\downP{P}|}\geq\theta_{\text{most}}(P)$ 
 
\end{enumerate}  
\end{ex}
Clause~2 in \preveg{} requires us to count both the witness set, which
may be quite large, like the number of supporters in a stadium, as
well as the property extension of $P$.  We will address this by using
probability estimations in the next section.

The English determiner \textit{many}, has two readings: absolute and
proportional.  We will treat this in terms of two quantifier relations
`many$_a$' and `many$_p$'.  For any property, $P$, we will assume that
thresholds, $\theta_{\text{many}_a}(P)$ and $\theta_{\text{many}_p}(P)$ are
provided.  These will indicate, respectively, the number of objects
having property $P$ that will count as many and the proportion of the
set of objects having $P$ that will count as many.  The witness
condition for `many$_a^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{many}_a^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $|X|\geq\theta_{\text{many}_a}(P)$ 
 
\end{enumerate} 
 
\end{ex}
The witness condition for `many$_p^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{many}_p^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $\frac{|X|}{|\downP{P}|}\geq\theta_{\text{many}_p}(P)$ 
 
\end{enumerate}  
\end{ex} 
The quantifier relations corresponding to \textit{few} are treated in
an exactly similar fashion to those corresponding to \textit{many}
except that the cardinality of the witness set or the proportion of
the property extension included in the witness set is required to be
less than or equal to the relevant threshold. The witness
condition for `few$_a^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{few}_a^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $|X|\leq\theta_{\text{few}_a}(P)$ 
 
\end{enumerate} 
 
\end{ex}
The witness condition for `few$_p^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{few}_p^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $\frac{|X|}{|\downP{P}|}\leq\theta_{\text{few}_p}(P)$ 
 
\end{enumerate}  
\end{ex}
The quantifier relations corresponding to \textit{a few} use the same
thresholds as those corresponding to \textit{few} but in the case of
\textit{a few} the size of the witness set and the proportion of the
witness set to the property extension have to be greater than or equal
to the threshold. The witness
condition for `a\_few$_a^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{a\_few}_a^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $|X|\geq\theta_{\text{few}_a}(P)$ 
 
\end{enumerate} 
 
\end{ex}
The witness condition for `a\_few$_p^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{a\_few}_p^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $\frac{|X|}{|\downP{P}|}\geq\theta_{\text{few}_p}(P)$ 
 
\end{enumerate}  
\end{ex} 
     

\subsection{Relating witness sets to probabilities}
In general our strategy for relating witness sets to probabilities
will involve two conditions, the first of which is the same as we had
in the previous section, that is that the witness set, $X$, is a set
of objects which have the property, $P$, i.e. $X:\mathrm{set}(\mathfrak{T}(P))$.
The second condition, however, will place a constraint on the value of
a conditional probability which we will represent as
$p(\mathfrak{T}(X)\|\mathfrak{T}(P))$, that its, the probability for
any object $a$ that it is of type $\mathfrak{T}(X)$ given that it is
of type $\mathfrak{T}(P)$.\footnote{We contrast this with
  $p(\mathfrak{T}(X)|\mathfrak{T}(P)$, the probability that there is
  something of type $\mathfrak{T}(X)$, given that there is something
  of type $\mathfrak{T}(P)$. See \cite{CooperDobnikLappinLarsson2014a}
  for discussion.}  Here we will take a
frequentist view of this probability and define it according the
equation in \nexteg{}.
\begin{ex} 
$p(T_1\|T_2)=\frac{|\down{T_1\wedge T_2}|}{|\down{T_2}|}$ if $T_2$ is
witnessed and $0$ otherwise.
\label{ex:freq-cond-prob}
\end{ex} 
Clearly, this of itself will not help if we wish to avoid counting the
set of witnesses of $T_1$ or $T_2$. However, probabilities can be
estimated on the basis of previous experience.  We will assume that an
agent has available in memory a finite set of Austinian propositions,
$\mathfrak{J}$, recording judgements previously made.  We will define
a notion of having a type with respect to a set of Austinian
propositions, $\mathfrak{J}$, using $a:_{\mathfrak{J}}T$ to represent
``$a$ is of type $T$ with respect to $\mathfrak{J}$''.  This notion
is defined in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item $a:_{\mathfrak{J}}T$ if \record{\field{sit}{$a$}\\
                                         \field{type}{$T$}}
                                       $\in$ $\mathfrak{J}$ 
 
\item If $T=(T_1\wedge T_2)$, then $a:_{\mathfrak{J}}T$ if $a:_{\mathfrak{J}}T_1$ and
  $a:_{\mathfrak{J}}T_2$

\item Otherwise $a\not:_{\mathfrak{J}}T$
 
\end{subex} 
   
\end{ex} 
We will use the notation $\down{T}_{\mathfrak{J}}$ to represent the
extension of $T$ with respect to $\mathfrak{J}$, defined in \nexteg{}.
\begin{ex} 
$\down{T}_{\mathfrak{J}}=\{a\mid a:_{\mathfrak{J}}T\}$ 
\end{ex} 
We can now define the notion of \textit{estimate of} $p(T_1\|T_2)$
\textit{based on} $\mathfrak{J}$, $p_{\mathfrak{J}}(T_1\|T_2)$, as in
\nexteg{}.
\begin{ex} 
$p_{\mathfrak{J}}(T_1\|T_2)=\frac{|\down{T_1\wedge T_2}_{\mathfrak{J}}|}{|\down{T_2}_{\mathfrak{J}}|}$ 
\end{ex} 
A measure of reliability of the estimate could be related to the
number of instances observed, that is, about which a judgement has
been made, for example as in \nexteg{}.
\begin{ex} 
reliability($p_{\mathfrak{J}}(T_1\|T_2)$) = ln min($|\down{T_1}_{\mathfrak{J}}|,|\down{T_2}_{\mathfrak{J}}|$) 
\end{ex} 
This could still involve an agent in a serious amount of counting
which might be unintuitive from a psychological point of view. From a
computational point of view it would be straghtforward enough to keep
track of how many objects of each type have already been judged and to
increment these numbers when a new object of the type is encountered.
However, we do not seem to be aware of how many objects of a given
type we have encountered when the numbers get high.  For example, I
know that I have seen a lot of dogs in my life but I have no idea how
many.  It would also not explain how I could estimate the probability
that any person in a stadium is wearing an IFK Göteborg scarf just by
looking around the stadium but not exactly counting the number of
people in the stadium and the number of those wearing the scarf.  This
seems to point to the related proposals based on Austinian
propositions involving Bayesian reasoning about probability which are
suggested in \cite{CooperDobnikLappinLarsson2014a}.  An
important difference between what we are doing here and what we did in
the earlier work is that here we assume that the Austinian
propositions in $\mathfrak{J}$ are categorical rather than
probabilistic.  We could, of course, derive a set of categorical
propositions from a set of probabilistic propositions by choosing
categorical propositions for all those in the probabilistic set whose
probabilities exceed a given threshold.

Here we will look at the straight frequentist interpretation of
probabilities associated with types of witness sets of quantifiers as
this can be shown to relate directly to the characterization of these
types in Section~\ref{sec:witset-types} and assume that these
probabilities can be estimated on the basis of a (tractably small) set, $\mathfrak{J}$,
of propositions available to the agent in memory.   For convenience in
the discussion below we will repeat the second clause of the
non-deterministic characterization from Section~\ref{sec:witset-types}
for comparison.

The witness condition for `exist$^{\text{w}}$($P$)' is given in
\nexteg{}.
\begin{ex} 
$X:\text{exist}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item
  $p(\mathfrak{T}(X)\|\mathfrak{T}(P))=\frac{1}{|\down{\mathfrak{T}(P)}|}$
  (corresponds to $|X|=1$) 
 
\end{enumerate} 
   
\end{ex}
It is easy to see that the clauses~(1.) and (2.) in \preveg{} are
equivalent to the non-probabilistic version if we take the frequentist
interpretation of the conditional probability in
(\ref{ex:freq-cond-prob}).  Nothing is gained by going to the extra
expense of computing the probability here.  All we need to do is check
that the witness set is a singleton and that its member is of the type
$\mathfrak{T}(P)$.  

The witness condition for `exist$_{\text{pl}}^{\text{w}}$($P$)' is given in
\nexteg{}.
\begin{ex} 
$X:\text{exist}_{\text{pl}}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item
  $p(\mathfrak{T}(X)\|\mathfrak{T}(P))\geq\frac{2}{|\down{\mathfrak{T}(P)}|}$
  (corresponds to $|X|\geq 2$) 
 
\end{enumerate} 
   
\end{ex}
The probabilistic condition is again equivalent to the
non-probabilistic condition and there is no point in going to the
extra expense of computing the probability.

The witness condition for `no$^{\text{w}}$($P$)' is given in
\nexteg{}.
\begin{ex} 
$X:\text{no}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $p(\mathfrak{T}(X)\|\mathfrak{T}(P))=0$ (corresponds to $|X|=0$) 
 
\end{enumerate} 
   
\end{ex}
Again the probabilistic and non-probabilistic conditions are
equivalent and there is no point to computing the probability since
all we have to do is check that the witness set is the empty set.

The witness condition for `every$^{\text{w}}$($P$)' is given in
\nexteg{}.
\begin{ex} 
$X:\text{every}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $p(\mathfrak{T}(X)\|\mathfrak{T}(P))=1$ (corresponds to $|X|=|\down{\mathfrak{T}(P)}|$) 
 
\end{enumerate}  
\end{ex}



Again the probabilistic and non-probabilistic conditions are
equivalent given the frequentist interpretation of probability.
However, here there is some point to the probability for semantic
processing. Both the conditions as formulated require counting the set
of objects which have the property, $P$, which can be intractable
especially if the set is infinite or finite and reasonably large.
However, the probability can be estimated on the basis of a finite
number of observations.  The more relevant observations you have, the
more reliable your estimate.  Consider the sentence in \nexteg{}.
\begin{ex} 
Every dog barks when it is time to go for a walk 
\end{ex} 
An utterance of \preveg{} is naturally interpreted to be quantifying
over dogs in general, or at least those which are physically capable
of barking.  I have no practical way of determining the truth or
falsity of this
sentence, though I can make an estimate on the basis of my observations
of dogs in pre-walk situations.  If all relevant observations of dogs
involved the dog barking, then I can estimate that the sentence is
true.  Of course, if I have only observed
two or three dogs, my estimate is not very reliable even though it is
consistent with my experience.  If on the other hand I have observed
hundreds of situations where a dog is about to go for a walk, all of
them with the dog barking, then it seems like a more reliable estimate,
although my experience will not show conclusively that it will be
true.  How do sentences like this get used in a dialogue.  Consider
the (constructed) dialogue in \nexteg{}.
\begin{ex} 
\begin{tabular}[t]{lp{.8\textwidth}}
\multicolumn{2}{p{.9\textwidth}}{\textit{$A$ and $B$ are about to
  take $A$'s  dog
  for a walk.  The dog, realizing that a walk is in the offing, begins
  to bark excitedly.}}\\
$A:$ & I must apologize for the racket.\\
$B:$ & Not to worry. Every dog barks when it is time to go for a
       walk. \textit{$B$ is thinking of her past experience of dogs in
       similar situations.}\\
$A:$ & Yes, that's right. \textit{$A$ is thinking of
       \emph{her} past experience of dogs in similar situations.}
\end{tabular}
\label{ex:walkies}
\end{ex} 
$A$ and $B$ are agreeing on the basis of their own distinct
observations.  They both know what the sentence means but they both
also know that it is not practically possible for a human agent to
verify the truth of the sentence on the set-based view or its
equivalent frequentist probabilistic interpretation and therefore that
the basis for the assertion must be a probability estimation.  The
situation seems similar to that with predicates of personal taste on
the kind of approach taken by \cite{Cooper2015a,Cooper2017c}.
Consider the (constructed) dialogue in \nexteg{}.
\begin{ex} 
\begin{tabular}[t]{lp{.8\textwidth}}
\multicolumn{2}{p{.9\textwidth}}{\textit{$A$ and $B$ are eating lunch
  together and have just been served soup}}\\
$A:$ & \textit{(tasting the soup)}  Hhm, this soup is good.
       \textit{$A$ is basing her assertion on her taste sensations.}\\
$B:$ & \textit{(also tasting the soup)} You're right.  It
       is. \textit{$B$ is basing her assertion on \emph{her} taste
       sensations.}
\end{tabular}
\label{ex:taste}
\end{ex} 
Again $A$ and $B$ are agreeing on the basis of their own distinct
observations.  The reason here, however, does not have to do with the
impracticality of counting a large set but rather that it is not
possible to directly observe another person's taste sensation. But
there is also an important difference between (\ref{ex:walkies}) and
\preveg{}.  In (\ref{ex:walkies}) there is a fact of the matter which
is being discussed.  For example, consider the continuation of
(\ref{ex:walkies}) given in \nexteg{} where a third dialogue participant, $C$, joins the
conversation.
\begin{ex} 
\begin{tabular}[t]{lp{.8\textwidth}}
$C:$ & Actually, I used to have a dog which never barked except when
       he saw another dog or a squirrel. \\
$B:$ & OK, then, \textit{most} dogs bark when it's time for a walk /
       \#Well, \textit{I} think that every dog barks when it's time
       for a walk
\end{tabular}
\end{ex} 
This contrasts with a continuation of (\ref{ex:taste}) in a similar
vein.
\begin{ex} 
\begin{tabular}[t]{lp{.8\textwidth}}
$C:$ & No, this soup is not good.\\
$A:$ & \#OK, then the soup is sort of/mostly good / Well, \textit{I}
       think it's good. 
\end{tabular}
\end{ex} 
What the examples have in common is that the justification for the
assertions of the same ``proposition'' is different facts based on
personal experience.   Where they differ is in whether there is an
objective fact or not.

A similar discussion holds for \textit{most}. The witness condition for `most$^{\text{w}}$($P$)' is given in \nexteg{}. 
\begin{ex} 
$X:\text{most}^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $p(\mathfrak{T}(X)\|\mathfrak{T}(P))\geq\theta_{\text{most}}(P)$ (corresponds to $\frac{|X|}{|\downP{P}|}\geq\theta_{\text{most}}(P)$) 
 
\end{enumerate}  
\end{ex}
As usual the frequentist interpretation of the conditional probability
is equivalent to the corresponding non-probabilistic.  In order to see
this note that
\nexteg{} holds.
\begin{ex} 
$\frac{|\down{\mathfrak{T}(X)\wedge\mathfrak{T}(P)}|}{|\down{\mathfrak{T}(P)}|}=\frac{|X|}{|\downP{P}|}$
\end{ex} 
\preveg{} holds because of the equalities in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item $|\down{\mathfrak{T}(X)}|=|X|$ since $\down{\mathfrak{T}(X)}=X$ 
 
\item $\down{\mathfrak{T}(P)}=\downP{P}$

\item
  $|\down{\mathfrak{T}(X)\wedge\mathfrak{T}(P)}|=|\down{\mathfrak{T}(X)}|$
    since $\down{\mathfrak{T}(X)}\subseteq\down{\mathfrak{T}(P)}$
    (since $X:\mathrm{set}(\mathfrak{T}(P))$)
 
\end{subex} 
   
\end{ex} 
Again, to make an evaluation when large sets are involved we may need to
estimate the relevant probability on the basis of our own experience
and the kind of dialogue which we illustrated for \textit{every} might
occur.

The witness
condition for `many$_a^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{many}_a^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P)$ 
 
\item
$p(\mathfrak{T}(X)\|\mathfrak{T}(P))\geq\frac{\theta_{\text{many}_a}(P)}{[\down{\mathfrak{T}(P)}]}$
  (corresponds to $|X|\geq\theta_{\text{many}_a}(P)$) 
 
\end{enumerate} 
\end{ex}
Again the probabilistic condition on the frequentist interpretation is equivalent to the
non-probabilistic one since both require that the cardinality of $X$ is
greater than or equal to $\theta_{\text{many}_a}(P)$.

The witness condition for `many$_p^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{many}_p^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item
  $p(\mathfrak{T}(X)\|\mathfrak{T}(P)\geq\theta_{\text{many}_p}(P)$ (corresponds to $\frac{|X|}{|\downP{P}|}\geq\theta_{\text{many}_p}(P)$) 
 
\end{enumerate}  
\end{ex}     
Again, the frequentist interpretation of the probabilisitic condition
is equivalent to the non-probabilistic condition and with large sets
we may need to estimate the probability rather than compute the
cardinality of the witness set.

The same holds for the quantifier relations corresponding to
\textit{few} and \textit{a few}. The witness
condition for `few$_a^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{few}_a^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item
  $p(\mathfrak{T}(X)\|\mathfrak{T}(P))\leq\frac{\theta_{\text{few}_a}(P)}{[\down{\mathfrak{T}(P)}]}$
  (corresponds to $|X|\leq\theta_{\text{few}_a}(P)$) 
 
\end{enumerate} 
 
\end{ex}

The witness condition for `few$_p^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{few}_p^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $p(\mathfrak{T}(X)\|\mathfrak{T}(P)\leq\theta_{\text{few}_p}(P)$
  (corresponds to $\frac{|X|}{|\downP{P}|}\leq\theta_{\text{few}_p}(P)$) 
 
\end{enumerate}  
\end{ex}

The witness
condition for `a\_few$_a^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{a\_few}_a^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $p(\mathfrak{T}(X)\|\mathfrak{T}(P))\geq\frac{\theta_{\text{few}_a}(P)}{[\down{\mathfrak{T}(P)}]}$
  (corresponds to $|X|\geq\theta_{\text{few}_a}(P)$) 
 
\end{enumerate} 
 
\end{ex}

The witness condition for `a\_few$_p^{\text{w}}$($P$)' is given in \nexteg{}.
\begin{ex} 
$X:\text{a\_few}_p^{\text{w}}(P)$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $p(\mathfrak{T}(X)\|\mathfrak{T}(P)\geq\theta_{\text{few}_p}(P)$
  (corresponds to $\frac{|X|}{|\downP{P}|}\geq\theta_{\text{few}_p}(P)$) 
 
\end{enumerate}  
\end{ex}


    

\subsection{Witness conditions for quantificational ptypes}

In general there are two witness conditions that can be associated
with quantificational ptypes $q(P,Q)$ where $q$ is a quantifier
relation and $P$ and $Q$ are properties.  These correspond to the two
evaluation procedures suggested by \cite{BarwiseCooper1981} in
connection with witness sets for monotone increasing and decreasing
quantifiers respectively.  The two conditions are given in
\nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item $s:q(P,Q)$ iff $s$ :
  \record{\tfield{X}{$q^w(P)$}\\
          \tfield{f}{$((a:\mathfrak{T}(\text{X}))\rightarrow\mathfrak{P}(Q)\{a\})$}} 
 
\item $s:q(P,Q)$ iff $s$ :
  \record{\tfield{X}{$q^w(P)$}\\
          \tfield{f}{($(a:(\mathfrak{T}(P)\wedge\mathfrak{T}(Q)))\rightarrow$
            \record{\mfield{x}{$a$}{$\mathfrak{T}$(X)}})}} 
 
\end{subex} 
   
\end{ex} 
\preveg{a} is the condition to be associated with monotone increasing
quantifiers.  It says that $s$ is of the quantificational ptype just in
case it provides an appropriate witness set (in a field labelled `X')
and a function (in a field labelled `f') from objects, $a$, in that witness set to situations
(modelled as records) which show that $a$ has the purified property
derived from second argument of the quantificational ptype.
\preveg{b} is the condition to be associated with monotone decreasing
quantifiers.  It says that $s$ is of the quantificational ptype just
in case it provides an appropriate witness set (in a field labelled
`X') and a function from objects, $a$, which have both the property
which is the first argument  and the purified property derived from
the second argument to a situation (record) which shows that $a$ is a
member of the witness set.

For each quantifier relation, $q$, we have to say whether ptypes
constructed with $q$ have the witness condition \preveg{a} or
\preveg{b}.  We shall call these the \textit{general} witness
conditions.  Judging from the anaphoric possibilities associated with
natural language quantified expressions the witness conditions used
for some quantifier relations
are not the general witness conditions but simpler conditions (which
we will call \textit{particular} witness conditions) using an equivalent type.  That
is, if the relevant witness condition expressed in \preveg{} is $s:T$
what actually gets used is $s:T'$ where $T$ is witnessed if and only
if $T'$ is witnessed.  We shall discuss these cases as we go through
the witness conditions associated with the individual quantifier
relations. 

The general witness condition for `exist($P$,$Q$)' is given in
\nexteg{}.
\begin{ex} 
 $s:\text{exist}(P,Q)$ iff $s$ :
  \record{\tfield{X}{exist$^w(P)$}\\
          \tfield{f}{$((a:\mathfrak{T}(\text{X}))\rightarrow\mathfrak{P}(Q)\{a\})$}}
\end{ex} 
This requires that a witness for `exist($P$,$Q$)' must be a record
providing a pair of a singleton set whose member is an object which
has property $P$ and a function whose domain is this set which returns
for any $a$ a situation in which $a$ has (the purification of) the
property $Q$.  Thus if we let `dog$'$' and `bark$'$' represent the
properties indicated in \nexteg{a} and \nexteg{b} respectively then a
witness for `exist(dog$'$,bark$'$)' will according to \preveg{} be of
the type \nexteg{c}.
\begin{ex} 
\begin{subex} 
 
\item $\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . \record{\tfield{e}{dog($r$.x)}}$\urcorner$ 
 
\item $\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
  . \record{\tfield{e}{bark($r$.x)}}$\urcorner$ 

\item \record{\tfield{X}{exist$^w$(dog$'$)}\\
              \tfield{f}{$((a:\mathfrak{T}(X))\rightarrow\text{bark}'\{a\})$}}
 
\end{subex} 
   
\end{ex} 
It is trivial to show that \preveg{c} has a witness just in case
\nexteg{} has a witness.
\begin{ex} 
\record{\tfield{x}{$\mathfrak{T}$(dog$'$)}\\
        \tfield{e}{bark$'$\{x\}}} 
\end{ex} 
The argument is essentially that there is a singleton set containing a
dog all of whose members bark just in case there is a dog which barks.
We might prefer to have the particular witness condition for
`exist($P$,$Q$)' in \nexteg{}.
\begin{ex} 
$s:\text{exist}(P,Q)$ iff $s$ :
  \record{\tfield{x}{$\mathfrak{T}(P)$}\\
        \tfield{e}{$\mathfrak{P}(Q)$\{x\}}}
\label{ex:existPQ-part}
\end{ex} 
Apart from its intuitive simplicity and correspondence to the
classical DRT treatment of indefinites as well as to the use of
$\Sigma$-types to interpret indefinites in type theory the particular
witness condition provides a component in the witness (in the
`x'-field) which can be
picked up on by singular anaphora in examples like \nexteg{}.
\begin{ex} 
A dog is barking. It is right outside my window 
\end{ex} 

The general witness condition for `exist$_{\text{pl}}$($P$,$Q$)' is
\nexteg{}.
\begin{ex} 
$s:\text{exist}_{\text{pl}}(P,Q)$ iff $s$ :
  \record{\tfield{X}{exist$_{\text{pl}}^w(P)$}\\
          \tfield{f}{$((a:\mathfrak{T}(\text{X}))\rightarrow\mathfrak{P}(Q)\{a\})$}} 
\end{ex} 
This corresponds to a distributive reading of plural \textit{some}.
It says intuitively that a situation, $s$, is of type
`exist$_{\text{pl}}$($P$,$Q$) just in case $s$ provides a set of
objects which have property $P$
with at least two members and a function which shows that each member
of 
the set has property $Q$.  In this case the witness set provides us
with a suitable antecedent for plural anaphora as in \nexteg{} and we
do not need a particular witness condition.
\begin{ex} 
Some dogs are barking.  They are right outside my window. 
\end{ex} 

The general witness condition for `no($P$,$Q$)' is given in \nexteg{}.
\begin{ex} 
$s:\text{no}(P,Q)$ iff $s$ :
  \record{\tfield{X}{$\text{no}^w(P)$}\\
          \tfield{f}{($(a:(\mathfrak{T}(P)\wedge\mathfrak{T}(Q)))\rightarrow$
            \record{\mfield{x}{$a$}{$\mathfrak{T}$(X)}})}}  
\end{ex} 
The only witness set allowed (that is,  the only set of type
$\text{no}^w(P)$, no matter what $P$ is) is the empty set.  Suppose
that we find some object, $a$, which has both properties $P$ and $Q$,
then the function will return a situation (record) that shows that $a$
is in the empty set.  There is, however, no such situation.  The only
way that there can be a function of this type is if the set of objects
which have both $P$ and $Q$ is also the empty set.  While this is
technically correct and fits the general pattern for monotone
decreasing quantifiers it does not seem to be an intuitive account of
how we would check that `no($P$,$Q$)' is witnessed.  More intuitive is
to check each object that has property $P$ and find that it does not
have property $Q$.  This method is equivalent to the first and the
relationship between the two corresponds to the equivalence between
\nexteg{a} and \nexteg{b} in first order logic.
\begin{ex} 
\begin{subex} 
 
\item $\neg\exists x[P(x)\wedge Q(x)]$ 
 
\item $\forall x [P(x)\rightarrow\neg Q(x)]$ 
 
\end{subex} 
   
\end{ex} 
In order to do this we will use the notion of negation given  in
\cite{CooperGinzburg2011,CooperGinzburg2012}.  % [We should probably
% introduce negation somewhere else independently! ????]
First we say that two
types, $T_1$ and $T_2$ \textit{preclude each other}, $T_1\bot T_2$, just in case there is no
possibility in which $\down{T_1}$ and $\down{T_2}$ overlap.  That is,
nothing can be of both types.  We then introduce negated types as in
\nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item if $T$ is a type, then $\neg T$ is a type 
 
\item $a:\neg T$ iff for some type, $T'$, such that $T\bot T'$, $a:T'$ 
 
\end{subex} 
   
\end{ex}   
We will define the particular witness condition for `no($P$,$Q$)' as
\nexteg{}.
\begin{ex} 
$s:\text{no}(P,Q)$ iff $s$ :
  \record{\tfield{X}{$\text{every}^w(P)$}\\
          \tfield{f}{$((x:\mathfrak{T}(X))\rightarrow\neg\mathfrak{P}(Q)\{x\})$}} 
\label{ex:noPQ-part}
\end{ex} 
Some evidence that English uses the particular witness condition
rather than the general one comes from the fact that we can have
plural discourse anaphora related to a noun phrase with \textit{no} as
its determiner, as in \nexteg{}.
\begin{ex} 
No dog barked.  They were all busy gnawing on a bone. 
\end{ex} 
Clearly, \textit{they} does not refer to the witness set of type
`no$^w$(dog$'$)', which would have to be the empty set, but rather to
a witness set of type `every$^w$(dog$'$)', the set of all dogs.  This
is an instance of \textit{complement set anaphora}, first discussed in
the psychology literature by
\cite{MoxeySanford1987,SanfordMoxey1993} and discussed in the
semantics literature by
\cite{Kibble1997,Nouwen2003,LueckingGinzburg2019} among others.

The general witness condition for `every($P$,$Q$)' is given in
\nexteg{}.
\begin{ex} 
$s:\text{every}(P,Q)$ iff $s$ :
  \record{\tfield{X}{$\text{every}^w(P)$}\\
          \tfield{f}{$((a:\mathfrak{T}(\text{X}))\rightarrow\mathfrak{P}(Q)\{a\})$}} 
\end{ex} 
In this case we do not need a particular witness condition.  \preveg{}
correctly predicts the availability of plural discourse anaphora as in
\nexteg{}.
\begin{ex} 
Every dog barked.  They had been disturbed by the intruder. 
\end{ex} 

The same holds for \textit{most}.  The general witness condition for `most($P$,$Q$)' is given in
\nexteg{}.
\begin{ex} 
$s:\text{most}(P,Q)$ iff $s$ :
  \record{\tfield{X}{$\text{most}^w(P)$}\\
          \tfield{f}{$((a:\mathfrak{T}(\text{X}))\rightarrow\mathfrak{P}(Q)\{a\})$}} 
\label{ex:mostPQ-witcond}
\end{ex} 
In this case we do not need a particular witness condition.  \preveg{}
correctly predicts the availability of plural discourse anaphora as in
\nexteg{}.
\begin{ex} 
Most dogs bark when somebody unknown comes into their territory.  They
are disturbed by an intruder.
\end{ex}       
Note that the occurrence of \textit{they} here can be interpreted to refer not to all dogs
or dogs in general but to the witness set of dogs containing most
dogs. (This is what Moxey and Sanford call REFSET anaphora.) It can, however, also be interpreted to refer to dogs in
general, that is, all dogs are disturbed by an intruder but not all of
them bark when this happens.  This is referred to as MAXSET anaphora
by Moxey and Sanford.  This could be taken as motivation for having a
field which introduces the property `dog' in the sign corresponding to
\textit{most dogs} in the manner suggested in
Chapter~\ref{ch:gram}. Alternatively, it might be considered as
motivation for an additional field corresponding to $P$ in the witness
for `most($P$,$Q$)'.  We will leave this issue unresolved.   It seems clear, though, as has been pointed out in the
literature \citep{Nouwen2003}, that COMPSET anaphora is not possible with
\textit{most}.  That is, \textit{they} in \nexteg{} cannot refer to
dogs which do not bark when somebody unknown comes into their
territory.
\begin{ex} 
\#Most dogs bark when somebody unknown comes into their territory.  They
never feel threatened whatever happens. 
\end{ex} 
The lack of this reading is consistent with the witness condition in
(\ref{ex:mostPQ-witcond}).

Similar remarks can be made for \textit{many}.  The general witness condition for `many$_a$($P$,$Q$)' is given in
\nexteg{}.
\begin{ex} 
$s:\text{many}_a(P,Q)$ iff $s$ :
  \record{\tfield{X}{$\text{many}_a^w(P)$}\\
          \tfield{f}{$((a:\mathfrak{T}(\text{X}))\rightarrow\mathfrak{P}(Q)\{a\})$}} 
\label{ex:mostPQ-witcond}
\end{ex}   
The general witness condition for `many$_p$($P$,$Q$)' is given in
\nexteg{}.
\begin{ex} 
$s:\text{many}_p(P,Q)$ iff $s$ :
  \record{\tfield{X}{$\text{many}_p^w(P)$}\\
          \tfield{f}{$((a:\mathfrak{T}(\text{X}))\rightarrow\mathfrak{P}(Q)\{a\})$}} 
\label{ex:mostPQ-witcond}
\end{ex}   
For both absolute and proportional readings of \textit{many} REFSET
and MAXSET anaphora are available but not COMPSET.  There is no
motivation for a particular witness condition.

The general witness condition for `few$_a$($P$,$Q$)' is given in
\nexteg{}. 
\begin{ex} 
 $s:\text{few}_a(P,Q)$ iff $s$ :
  \record{\tfield{X}{$\text{few}_a^w(P)$}\\
          \tfield{f}{($(a:(\mathfrak{T}(P)\wedge\mathfrak{T}(Q)))\rightarrow$
            \record{\mfield{x}{$a$}{$\mathfrak{T}$(X)}})}}
\end{ex} 
The general witness condition for `few$_p$($P$,$Q$)'  is exactly
similar as given in \nexteg{}.
\begin{ex} 
 $s:\text{few}_p(P,Q)$ iff $s$ :
  \record{\tfield{X}{$\text{few}_p^w(P)$}\\
          \tfield{f}{($(a:(\mathfrak{T}(P)\wedge\mathfrak{T}(Q)))\rightarrow$
            \record{\mfield{x}{$a$}{$\mathfrak{T}$(X)}})}}
\end{ex}  
% As with \textit{no} we can formulate particular witness conditions
% using the dual of \textit{few}, that is, \textit{many} and type
% negation.  This corresponds to our intuition that few $P$ have
% property $Q$ is equivalent to saying that many $P$ do not have
% property $Q$.  
These witness conditions involve computing first the set of all
objects that have both property $P$ and $Q$ and then checking that all
the members of the set are in the witness set.  A more intuitive and
less computationally expensive way of achieving an equivalent result
is to find a sufficient number of objects that have property $P$ but
which don't have property $Q$ (in our terms they have a property which
precludes them having $Q$).  What counts as a sufficient  number of
objects?  It has to be a number of objects with property $P$ such that
only few objects having property $P$ remain, that is, it has to be a
set with cardinality at least the cardinality of the set whose members
have $P$ minus the threshold, $\theta_{\text{few}}$ in the case of an
absolute quantifier.  In the case of a proportional quantifier the
proportion of objects having $P$ but not $Q$ has to be greater than
one minus the proportional threshold.  We treat this by introducing
types of complement witness sets for \textit{few}.  The absolute case
is given in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item If few$_a^w$($P$) is a type, then $\overline{\text{few}_a^w(P)}$ is a type 
 
\item $X:\overline{\text{few}_a^w(P)}$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $|X|\geq|\down{\mathfrak{T}(P)}|-\theta_{\text{few}_a}(P)$ 
 
\end{enumerate} 
   
 
\end{subex} 
   
\end{ex}
The proportional case is given in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item If few$_p^w$($P$) is a type, then $\overline{\text{few}_p^w(P)}$ is a type 
 
\item $X:\overline{\text{few}_p^w(P)}$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item $\frac{|X|}{|\down{\mathfrak{T}(P)}|}\geq 1-\theta_{\text{few}_p}(P)$ 
 
\end{enumerate} 
   
 
\end{subex} 
   
\end{ex} 
Clearly, computing whether a set is a witness for one of these new
types can involve computing the cardinality of the set of objects
which have property $P$ and for this reason is may be more tractable
to estimate a probability.  The relevant probabilities here are
similar to those associated with \textit{many}.  The witness condition
for $\overline{\text{few}_a^w(P)}$ is given in \nexteg{}.
\begin{ex} 
$X:\overline{\text{few}_a^w(P)}$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item
$p(\mathfrak{T}(X)\|\mathfrak{T}(P))\geq\frac{\theta_{\text{few}_a}(P)}{[\down{\mathfrak{T}(P)}]}$
   
 
\end{enumerate} 
\end{ex}
The witness condition for $\overline{\text{few}_p^w(P)}$ is given in
\nexteg{}.
\begin{ex} 
$X:\overline{\text{few}_p^w(P)}$ iff
\begin{enumerate} 
 
\item $X:\mathrm{set}(\mathfrak{T}(P))$ 
 
\item
  $p(\mathfrak{T}(X)\|\mathfrak{T}(P)\geq1-\theta_{\text{few}_p}(P)$  
 
\end{enumerate}  
\end{ex} 
   
Now we can give particular witness conditions for ptypes constructed with the
quantifier predicates `few$_a$' and `few$_p$'.  The witness condition
for `few$_a$($P$,$Q$)' is given in \nexteg{}.
\begin{ex} 
$s:\text{few}_a(P,Q)$ iff $s$ :
  \record{\tfield{X}{$\overline{\text{few}_a^w(P)}$}\\
          \tfield{f}{$((x:\mathfrak{T}(X))\rightarrow\neg\mathfrak{P}(Q)\{x\})$}} 
\label{ex:fewaPQwitcond-part} 
\end{ex} 
The witness condition
for `few$_p$($P$,$Q$)' is given in \nexteg{}.
\begin{ex} 
$s:\text{few}_p(P,Q)$ iff $s$ :
  \record{\tfield{X}{$\overline{\text{few}_p^w(P)}$}\\
          \tfield{f}{$((x:\mathfrak{T}(X))\rightarrow\neg\mathfrak{P}(Q)\{x\})$}} 
\label{ex:fewpPQwitcond-part} 
\end{ex}

Why do we use complement witness set types for \textit{few} in the
particular witness conditions rather than witness sets related to
\textit{many}?  We might naively have thought that \textit{few dogs
  barked} was equivalent to \textit{many dogs did not bark}.  A
standard analysis of \textit{few} in the literature is as \textit{not
  many}, that is \textit{few dogs barked} is equivalent to \textit{not
  many dogs barked} or \textit{it is not true that many dogs barked}.
On the kind of analysis that we are proposing here neither of these
will work. We illustrate this with an example.  Suppose that we have a
dog hotel with twenty-five dogs in residence.  Suppose that what
counts as many dogs in the context is ten and what counts as few is
five.  This means that few dogs barked means that five or less dogs
barked.  If this is true then it follows that many dogs did not bark
(fifteen or more, and we only need ten to count as many) and it also
follows that it is not the case that many dogs barked (since at most
five did and for many dogs to bark we would need ten).  Thus
\textit{few} seems to imply both \textit{many not} and \textit{not
  many}.  However, the implications do not go back the other way.
Suppose that many dogs did not bark.  This means that ten or more dogs
did not bark.  If ten dogs did not bark then fifteen did bark.  Thus
many dogs barked at the same time as many dogs did not bark.  It does
not follow that few dogs barked.  Suppose that it is not the case that
many dogs barked.  This means that less than ten dogs barked.  For
example, nine dogs barked.  While nine is not many in this context
neither is it few.  We might say \textit{quite a lot} or \textit{quite
  a few}.  That is, our analysis allows for a gap between what counts
as many and what counts as few and thus \textit{not many} is not
equivalent to \textit{few}.
 
Adopting the particular witness condition predicts the existence of
COMPSET anaphora as in \nexteg{}.
\begin{ex} 
Few dogs in the kennels barked.  They didn't hear the intruder. 
\end{ex} 
However, there are convincing examples in the literature that
\textit{few} will also allow REFSET anaphora, which would be predicted
by the general witness condition.  \cite{Nouwen2003} quotes \nexteg{}
from \cite{Evans1980}.
\begin{ex} 
Few congressmen admire Kennedy, and they are very junior. 
\end{ex} 
One way to handle this is to allow both the general and particular
witness conditions as alternatives. Another solution to consider is
letting the general witness condition be used for absolute
\textit{few} and the particular witness condition for proportional
\textit{few}.  This would perhaps be consistent with Kibble's
(\citeyear{Kibble1997}) observation that complement anaphora seems to be
associated with monotone decreasing proportional quantifiers.

The general witness condition for `a\_few$_a$($P$,$Q$)' is given in
\nexteg{}.
\begin{ex} 
$s:\text{a\_few}_a(P,Q)$ iff $s$ :
  \record{\tfield{X}{$\text{a\_few}_a^w(P)$}\\
          \tfield{f}{$((a:\mathfrak{T}(\text{X}))\rightarrow\mathfrak{P}(Q)\{a\})$}} 
\end{ex} 
The general witness condition for `a\_few$_p$($P$,$Q$)' is given in
\nexteg{}.
\begin{ex} 
$s:\text{a\_few}_p(P,Q)$ iff $s$ :
  \record{\tfield{X}{$\text{a\_few}_p^w(P)$}\\
          \tfield{f}{$((a:\mathfrak{T}(\text{X}))\rightarrow\mathfrak{P}(Q)\{a\})$}} 
\end{ex} 
These will correctly predict the availability of REFSET anaphora as in
\nexteg{}.
\begin{ex} 
A few dogs barked.  They had heard the intruder. 
\end{ex} 
If these are the only witness conditions then this will correctly
predict the unavailability of COMPSET anaphora as shown by \nexteg{},
where \textit{they} cannot refer to the dogs that did not bark.
\begin{ex} 
\#A few dogs barked.  They hadn't heard the intruder 
\end{ex} 
     
            

\subsection{Some examples}

In this section we show how these definitions could be
used to express content for English utterances, ignoring for the
moment the parametric properties using in Chapter~\ref{ch:commonnouns}
and expressing the content of a quantified declarative sentence as a
quantificational ptype rather than a record type containing a
quantificational ptype as in Chapter~\ref{ch:gram} and subsequent
chapters.


\paragraph{\textit{A dog barks}}
The content of the indefinite article, \textit{a(n)}, is given in
\nexteg{}. This is `SemIndefArt'
\begin{ex} 
% $\lambda Q$:\textit{Ppty} . $\lambda P$:\textit{Ppty}
% . exist($Q$,$P|_{\mathcal{F}(Q)}$)
$\lambda Q$:\textit{Ppty} . \\
  \hspace*{1em}$\ulcorner\lambda c$:\textit{Cntxt} . \\
  \hspace*{2em}$\lambda P$:\textit{Ppty} . \\
  \hspace*{3em}\record{
    \mfield{restr}{$Q$}{\textit{Ppty}}\\
    \mfield{scope}{$P\mid_{\mathfrak{F}(\text{restr})}$}{\textit{Ppty}}\\
    \tfield{e}{exist(restr, scope)}}$\urcorner$  

\end{ex} 
The content of \textit{a dog} would then be as in \nexteg{}.
\begin{ex} 
%$\lambda
%P$:\textit{Ppty}. exist(dog$'$,$P|_{\mathcal{F}(\text{dog}')}$)
$\ulcorner\lambda c$:\textit{Cntxt} . \\
  \hspace*{1em}$\lambda P$:\textit{Ppty} . \\
  \hspace*{2em}\record{
    \mfield{restr}{dog$'$}{\textit{Ppty}}\\
    \mfield{scope}{$P\mid_{\mathfrak{F}(\text{dog}')}$}{\textit{Ppty}}\\
    \tfield{e}{exist(restr, scope)}}$\urcorner$  
\end{ex} 
Finally, the content of \textit{a dog barks} would be as in \nexteg{}.
\begin{ex} 
  % exist(dog$'$,bark$'|_{\mathcal{F}(\text{dog}')}$)
  $\ulcorner\lambda c$:\textit{Cntxt} . \\
  \hspace*{1em}\record{
    \mfield{restr}{dog$'$}{\textit{Ppty}}\\
    \mfield{scope}{bark$'\mid_{\mathfrak{F}(\text{dog}')}$}{\textit{Ppty}}\\
    \tfield{e}{exist(restr, scope)}}$\urcorner$
\label{ex:cont-a-dog-barks}
\end{ex} 
Following the particular witness condition for `exist($P$,$Q$)' in
(\ref{ex:existPQ-part}) we can infer \nexteg{}.
\begin{ex} 
$s$ : exist(dog$'$,bark$'|_{\mathcal{F}(dog')}$) iff
\begin{quote}
$s$ : \record{\tfield{x}{$\mathfrak{T}$(dog$'$)}\\
              \tfield{e}{$\mathfrak{P}$(bark$'|_{\mathcal{F}(\text{dog}')}$)\{x\}}}
\end{quote}
\label{ex:adb-witcond} 
\end{ex} 
$\mathcal{F}$(dog$'$) is given in \nexteg{}.
\begin{ex} 
\record{\tfield{x}{\textit{Ind}}\\
        \tfield{e}{dog(x)}} 
\end{ex} 
`bark$'|_{\mathcal{F}(\text{dog}')}$' is thus \nexteg{}.
\begin{ex} 
$\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                         \smalltfield{e}{dog(x)}} . \record{\tfield{e}{bark($r$.x)}} 
\end{ex} 
This means that `$\mathfrak{P}$(bark$'|_{\mathcal{F}(\text{dog}')}$)'
is \nexteg{}.
\begin{ex} 
$\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . 
\record{\tfield{$\mathfrak{c}$}{\record{\mfield{x}{$r$.x}{\textit{Ind}}\\
                                        \tfield{e}{dog(x)}}}\\
        \tfield{e}{bark($\mathfrak{c}$.x)}} 
\label{ex:Pdog_Fbark}
\end{ex} 
This means we can restate (\ref{ex:adb-witcond}) as \nexteg{}.
\begin{ex} 
$s$ : exist(dog$'$,bark$'|_{\mathcal{F}(dog')}$) iff
\begin{quote}
$s$ : \record{\tfield{x}{$\mathfrak{T}$(dog$'$)}\\
              \tfield{e}{\record{\tfield{$\mathfrak{c}$}{\record{\mfield{x}{$\Uparrow^2$x}{\textit{Ind}}\\
                                        \tfield{e}{dog(x)}}}\\
                                    \tfield{e}{bark($\mathfrak{c}$.x)}} }}
\label{ex:witcond-exist-dog-bark}
\end{quote}
\label{ex:adb-witcond-spelledout} 
\end{ex} 
Note that the record type on the right hand side of \preveg{} is
truth-conditionally equivalent to the simpler record types in
\nexteg{}, that is, for any pair of the types there is a witness for one of the types just in
case there is a witness for the other type.
\begin{ex}
\begin{subex} 
\item \record{\tfield{x}{$\mathfrak{T}$(dog$'$)}\\
        \tfield{e}{bark(x)}} 
\item \record{\tfield{x}{\textit{Ind}}\\
              \tfield{c}{dog(x)}\\
              \tfield{e}{bark(x)}}
\end{subex}
\end{ex} 
The additional structure in (\ref{ex:adb-witcond-spelledout}) is
unnecessary for this example but it will help us when we come to
donkey anaphora.

% We have ignored the additional structure associated with quantifiers
% in Chapter~\ref{ch:gram} and the introduction of context dependence
% using parametric properties and contents as discussed in
% Chapter~\ref{ch:commonnouns} for the sake of readability but this
% additional structure can be added.  For example, the content of the indefinite
% article  could be \nexteg{}, following Chapter~\ref{ch:commonnouns}.
% \begin{ex} 
% $\lambda Q$:\textit{PPpty} . $\ulcorner\lambda
% r$:\smallrecord{\smalltfield{f}{\textit{Rec}}\\
%                 \smalltfield{a}{$Q$.bg}} . $\lambda P$:\textit{Ppty}
%               . \record{\mfield{restr}{$Q$.fg($r$.a)}{\textit{Ppty}}\\
%                         \mfield{scope}{$P|_{\mathfrak{F}(Q)}$}{\textit{Ppty}}\\
%                         \tfield{e}{exist(restr,scope)}}$\urcorner$
% \end{ex} 
% [???? This might change after we have reconsidered the presentation of
% quantifiers in Ch. 5 in the light of this section.]

The witness condition in (\ref{ex:witcond-exist-dog-bark}) means that
anything of the type resulting from applying
(\ref{ex:cont-a-dog-barks}) to a context will also be of the type
\nexteg{}.
\begin{ex} 
\record{
    \mfield{restr}{dog$'$}{\textit{Ppty}}\\
    \mfield{scope}{bark$'\mid_{\mathfrak{F}(\text{dog}')}$}{\textit{Ppty}}\\
    \tfield{e}{\record{\tfield{x}{$\mathfrak{T}$(dog$'$)}\\
              \tfield{e}{\record{\tfield{$\mathfrak{c}$}{\record{\mfield{x}{$\Uparrow^2$x}{\textit{Ind}}\\
                                        \tfield{e}{dog(x)}}}\\
                                    \tfield{e}{bark($\mathfrak{c}$.x)}} }}}} 
\end{ex} 
  

Assuming a theory of anaphora where anaphoric references must relate
to paths in a witness, $s$, for the content,  we could potentially have all of the
examples of anaphora in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item A dog barked.  They (dogs in general, $s$.restr, MAXSET) do when they notice an
  intruder.

\item A dog barked.  They (dogs in general which bark, $s$.scope) make such
  a racket.

  
\item A dog barked.  That (an event of a dog barking, $s$.e, event
  anaphora) frightened off an intruder.

\item A dog barked.  It (the dog which barked, $s$.e.x, individual,
   REFSET, anaphora) heard an intruder. 
 
\end{subex} 
   
\end{ex} 
% Of these, \preveg{b} seems very doubtful as a reasonable case of
% anaphora.  However, if we make the pronominal reference generic as
% might be appropriate if we are deriving the anaphoric interpretation
% from a property then the anaphora seems more plausible.
% \begin{ex} 
% A dog barked.  They (dogs in general which barked) frightened me when
% I was a child, but now I remained calm. 
% \end{ex}


\paragraph{\textit{No dog barks}} The content for
\textit{no dog barks} would be derived in an exactly similar way as
that for \textit{a dog barks}.  We obtain \nexteg{}.
\begin{ex} 
  % no(dog$'$,bark$'|_{\mathcal{F}(\text{dog}')}$)
  $\ulcorner\lambda c$:\textit{Cntxt} . \\
  \hspace*{1em}\record{
    \mfield{restr}{dog$'$}{\textit{Ppty}}\\
    \mfield{scope}{bark$'\mid_{\mathfrak{F}(\text{dog}')}$}{\textit{Ppty}}\\
    \tfield{e}{no(restr, scope)}}$\urcorner$
  \label{ex:cont-no-dog-barks}
\end{ex} 
Following the particular witness condition in (\ref{ex:noPQ-part}), we
can infer \nexteg{}.
\begin{ex} 
$s$ : no(dog$'$,bark$'|_{\mathcal{F}(\text{dog}')}$) iff
\begin{quote}
$s$ :
  \record{\tfield{X}{$\text{every}^w(\text{dog}')$}\\
          \tfield{f}{$((x:\mathfrak{T}(X))\rightarrow\neg
            \mathfrak{P}(\text{bark}'|_{\mathfrak{F}(\text{dog}')})\{x\})$}}
\end{quote} 
\end{ex}
Given that $\mathfrak{P}(\text{bark}'|_{\mathfrak{F}(\text{dog}')})$
is (\ref{ex:Pdog_Fbark}) we can restate \preveg{} as \nexteg{}.
\begin{ex}
$s$ : no(dog$'$,bark$'|_{\mathcal{F}(\text{dog}')}$) iff
\begin{quote} 
$s$ :
  \record{\tfield{X}{$\text{every}^w(\text{dog}')$}\\
          \tfield{f}{$((x:\mathfrak{T}(X))\rightarrow\neg$
           \record{\tfield{$\mathfrak{c}$}{\record{\mfield{x}{$\Uparrow^2$x}{\textit{Ind}}\\
                                        \tfield{e}{dog(x)}}}\\
        \tfield{e}{bark($\mathfrak{c}$.x)}} $)$}} 
\end{quote}
\end{ex}

Anything of the type resulting from applying
(\ref{ex:cont-no-dog-barks}) to a context will also be of the type
\nexteg{}.
\begin{ex} 
 \record{
    \mfield{restr}{dog$'$}{\textit{Ppty}}\\
    \mfield{scope}{bark$'\mid_{\mathfrak{F}(\text{dog}')}$}{\textit{Ppty}}\\
    \tfield{e}{\record{\tfield{X}{$\text{every}^w(\text{dog}')$}\\
          \tfield{f}{$((x:\mathfrak{T}(X))\rightarrow\neg$
           \record{\tfield{$\mathfrak{c}$}{\record{\mfield{x}{$\Uparrow^2$x}{\textit{Ind}}\\
                                        \tfield{e}{dog(x)}}}\\
        \tfield{e}{bark($\mathfrak{c}$.x)}} $)$}}}}
\end{ex} 
This suggests that we could potentially have the anaphora in
\nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item No dog barked.  They (dogs in general, $s$.restr, MAXSET)
  normally do when they notice an
  intruder.

\item No dog barked.  They (dogs in general which bark, $s$.scope)
  normally make such
  a racket.

  
\item No dog barked.  That (an event of no dog barking, $s$.e, event
  anaphora) made it easy for the intruder.

\item No dog barked.  They (the dogs which didn't bark, $s$.e.X, 
   COMPSET anaphora) did not hear the intruder. 
 
\end{subex} 
   
\end{ex} 
% That no dog barks just in case every dog is such that it is not a dog
% that barks.  This can be made to take account of the additional
% structure used in Chapter~\ref{ch:commonnouns} in the same way that we
% did for \textit{a dog barks}.

\paragraph{few dogs bark}  The content for an utterance of
\textit{few dogs bark} is either \nexteg{a} or \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item % few$_a$(dog$'$,bark$'|_{\mathcal{F}(\text{dog}')}$)
  $\ulcorner\lambda c$:\textit{Cntxt} . \\
  \hspace*{1em}\record{
    \mfield{restr}{dog$'$}{\textit{Ppty}}\\
    \mfield{scope}{bark$'\mid_{\mathfrak{F}(\text{dog}')}$}{\textit{Ppty}}\\
    \tfield{e}{few$_a$(restr, scope)}}$\urcorner$
 
\item % few$_p$(dog$'$,bark$'|_{\mathcal{F}(\text{dog}')}$)
  $\ulcorner\lambda c$:\textit{Cntxt} . \\
  \hspace*{1em}\record{
    \mfield{restr}{dog$'$}{\textit{Ppty}}\\
    \mfield{scope}{bark$'\mid_{\mathfrak{F}(\text{dog}')}$}{\textit{Ppty}}\\
    \tfield{e}{few$_p$(restr, scope)}}$\urcorner$
 
\end{subex} 
\label{ex:cont-few-dogs-bark}    
\end{ex} 
Following the particular witness conditions in
(\ref{ex:fewaPQwitcond-part}) and \ref{ex:fewpPQwitcond-part}, we
obtain \nexteg{a} and \nexteg{b} respectively.
\begin{ex} 
\begin{subex} 
 
\item
  $s:\text{few}_a(\text{dog}',\text{bark}'|_{\mathcal{F}(\text{dog}')})$
  iff 
\begin{quote}
$s$ :
  \record{\tfield{X}{$\overline{\text{few}_a^w(\text{dog}')}$}\\
          \tfield{f}{$((x:\mathfrak{T}(X))\rightarrow\neg\mathfrak{P}(\text{bark}'|_{\mathcal{F}(\text{dog}')})\{x\})$}} 
\end{quote}
 
\item
  $s:\text{few}_p(\text{dog}',\text{bark}'|_{\mathcal{F}(\text{dog}')})$
  iff 
\begin{quote}
$s$ :
  \record{\tfield{X}{$\overline{\text{few}_p^w(\text{dog}')}$}\\
          \tfield{f}{$((x:\mathfrak{T}(X))\rightarrow\neg\mathfrak{P}(\text{bark}'|_{\mathcal{F}(\text{dog}')})\{x\})$}} 
\end{quote}
 
\end{subex} 
   
\end{ex} 
As with our treatment of \textit{no} these can be unpacked as
\nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item
  $s:\text{few}_a(\text{dog}',\text{bark}'|_{\mathcal{F}(\text{dog}')})$
  iff 
\begin{quote}
$s$ :
  \record{\tfield{X}{$\overline{\text{few}_a^w(\text{dog}')}$}\\
          \tfield{f}{$((x:\mathfrak{T}(X))\rightarrow\neg$\record{\tfield{$\mathfrak{c}$}{\record{\mfield{x}{$\Uparrow^2$x}{\textit{Ind}}\\
                                        \tfield{e}{dog(x)}}}\\
        \tfield{e}{bark($\mathfrak{c}$.x)}}$)$}} 
\end{quote}
 
\item
  $s:\text{few}_p(\text{dog}',\text{bark}'|_{\mathcal{F}(\text{dog}')})$
  iff 
\begin{quote}
$s$ :
  \record{\tfield{X}{$\overline{\text{few}_p^w(\text{dog}')}$}\\
          \tfield{f}{$((x:\mathfrak{T}(X))\rightarrow\neg$\record{\tfield{$\mathfrak{c}$}{\record{\mfield{x}{$\Uparrow^2$x}{\textit{Ind}}\\
                                        \tfield{e}{dog(x)}}}\\
        \tfield{e}{bark($\mathfrak{c}$.x)}}$)$}} 
\end{quote}
 
\end{subex} 
  
\end{ex}
Anything of the type resulting from applying the functions in
(\ref{ex:cont-few-dogs-bark}) to a context will also be of the types
in 
\nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item \record{
    \mfield{restr}{dog$'$}{\textit{Ppty}}\\
    \mfield{scope}{bark$'\mid_{\mathfrak{F}(\text{dog}')}$}{\textit{Ppty}}\\
    \tfield{e}{\record{\tfield{X}{$\overline{\text{few}_a^w(\text{dog}')}$}\\
          \tfield{f}{$((x:\mathfrak{T}(X))\rightarrow\neg$\record{\tfield{$\mathfrak{c}$}{\record{\mfield{x}{$\Uparrow^2$x}{\textit{Ind}}\\
                                        \tfield{e}{dog(x)}}}\\
        \tfield{e}{bark($\mathfrak{c}$.x)}}$)$}} }} 
 
\item \record{
    \mfield{restr}{dog$'$}{\textit{Ppty}}\\
    \mfield{scope}{bark$'\mid_{\mathfrak{F}(\text{dog}')}$}{\textit{Ppty}}\\
    \tfield{e}{\record{\tfield{X}{$\overline{\text{few}_p^w(\text{dog}')}$}\\
          \tfield{f}{$((x:\mathfrak{T}(X))\rightarrow\neg$\record{\tfield{$\mathfrak{c}$}{\record{\mfield{x}{$\Uparrow^2$x}{\textit{Ind}}\\
                                        \tfield{e}{dog(x)}}}\\
        \tfield{e}{bark($\mathfrak{c}$.x)}}$)$}}}} 
 
\end{subex} 
   
\end{ex} 
This suggests that we could potentially have the anaphora in
\nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item Few dogs barked.  They (dogs in general, $s$.restr, MAXSET)
  normally do when they notice an
  intruder.

\item Few dogs barked.  They (dogs in general which bark, $s$.scope)
  normally make such
  a racket.

  
\item Few dogs barked.  That (an event of few dogs barking, $s$.e, event
  anaphora) made it easier for the intruder.

\item Few dogs barked.  They (the dogs which didn't bark, $s$.e.X, 
   COMPSET anaphora) did not hear the intruder. 
 
\end{subex} 
   
\end{ex}   

% This, then yields a set up for COMPSET anaphora by providing the set
% in the `X'-field.

% \section{Binding and anaphora}
% \label{sec:binding-anaph}

\section{Long distance dependencies}
\label{sec:long-distance}

Let us consider how to derive the content of \textit{who Sam hugged}
as a relative clause.  We use \textbf{hug}$_V$ to represent the
foreground of the content of \textit{hug} as a transitive verb,
characterized as in \nexteg{}.

\begin{ex} 
\textbf{hug}$_V$ = $\ulcorner\lambda c$:\textit{Cntxt} . $\lambda
\mathcal{Q}$:\textit{Quant} . $\ulcorner\lambda
r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
. \smallrecord{\smalltfield{e}{hug($r$.x, $\mathcal{Q}$)}}$\urcorner\urcorner$ 
\end{ex} 
Our theory of syntax in terms of event types means that what have been
called ``gaps'' or ``traces'' in other theories of syntax would
somehow have to correspond to non-events in which nothing happens and
do not have any temporal extent.  This strongly suggests that they do
not exist.  Instead we will take a strategy similar to that pursued,
for example, in combinatory categorial grammar (see, for example,
\citealp{Steedman2012}) where \textit{hug} can also be interpreted as
a verb phrase whose content is ``looking for'' a \textit{wh}-phrase
content.  We will add a third component to our contexts with label
`$\mathfrak{g}$' for assignments associated with
gaps.  Thus we will redefine the type
\textit{Cntxt} as \nexteg{}.
\begin{ex} 
  \record{
    \tfield{$\mathfrak{s}$}{\textit{Assgnmnt}}\\
    \tfield{$\mathfrak{g}$}{\textit{Assgnmnt}}\\
    \tfield{$\mathfrak{c}$}{\textit{PropCntxt}}} 
\end{ex}   
We will represent this content as
\textbf{hug}$_{\mathit{VP}}$ and characterize it in terms of
\textbf{hug}$_V$ as in \nexteg{a} which is identical with \nexteg{b}.
\begin{ex} 
\begin{subex}
\item \textbf{hug}$_{\mathit{VP}}$ = $\ulcorner\lambda
  c$:\smallrecord{
\footnotesize{\textit{Cntxt}}\\
    \smalltfield{$\mathfrak{g}$}{\smallrecord{
        \smalltfield{x$_0$}{\textit{Ind}}}}}
. \textbf{hug}$_V$($c$)($\lambda P$:\textit{Ppty}
. $P$(\smallrecord{\field{x}{$c.\mathfrak{g}$.x$_0$}}))$\urcorner$ 

\item
  $\ulcorner\lambda c$:\smallrecord{
\footnotesize{\textit{Cntxt}}\\
    \smalltfield{$\mathfrak{g}$}{\smallrecord{
        \smalltfield{x$_0$}{\textit{Ind}}}}}
  . $\ulcorner\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
  . \smallrecord{\smalltfield{e}{hug($r$.x, $\lambda P$:\textit{Ppty}
. $P$(\smallrecord{\field{x}{$c.\mathfrak{g}$.x$_0$}}))}}$\urcorner\urcorner$
\end{subex}
\end{ex}

Let us now consider the content of \textit{Sam hugged}.  % In order to
% avoid the additional complexity of combining different kinds of
% context which we will undertake in Section~\ref{sec:struc-cntxt} we
% will go back to the treatment of proper names in Chapter~\ref{ch:gram}
% rather than the treatment in Chapter~\ref{ch:propnames} where proper
% names introduce a constraint on the context. Thus we will consider the
% foreground of
The parametric content of \textit{Sam}, which we will
represent as \textbf{Sam}, is \nexteg{}
% where `sam' is a particular individual named Sam
.
\begin{ex} 
  \textbf{Sam} = $\ulcorner\lambda c$:\smallrecord{
\footnotesize{\textit{Cntxt}}\\
      \smalltfield{$\mathfrak{c}$}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
          \smalltfield{e}{named(x, ``Sam'')}}}} . $\lambda
    P$:\textit{Ppty} . $P(c.\mathfrak{c})\urcorner$

  % $\lambda\mathfrak{s}$:\textit{Rec} . $\lambda P$:\textit{Ppty} . $P$(\smallrecord{\field{x}{sam}})

\end{ex}
In order to combine \textbf{Sam} with \textbf{hug}$_{\mathit{VP}}$ we
will need to adjust the combination of parametric contents based on
functional application so that it takes account of incrementation of
the context path $\mathfrak{w}.\text{x}$ in addition to
$\mathfrak{s}.\text{x}$ to allow for more than one
\textit{wh}-dependency. This uses the operation `$\mathrm{incr}$' defined in
Chapter~\ref{ch:propnames}, p.~\pageref{pg:incr}.  We will use
\nexteg{a} to represent \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item $\mathrm{incr}_{\pi_1,\ldots,\pi_n}(\varphi, T)$ 
 
\item
  $\mathrm{incr}_{\pi_1}(\ldots\mathrm{incr}_{\pi_n}(\varphi,T),\ldots, T)$ 
 
\end{subex} 
   
\end{ex}
We now modify the definition of the combination of $\alpha$ and
$\beta$, $\alpha\text{@}\beta$, given in Chapter~\ref{ch:propnames},
p.~\pageref{ex:s-combination} to \nexteg{}.
\begin{ex}
If $\alpha$ : \smallrecord{\smalltfield{bg}{\textit{CntxtType}}\\
                           \smalltfield{fg}{(bg$\rightarrow$($T_1\rightarrow
                             T_2$))}} 
and $\beta$ : \smallrecord{\smalltfield{bg}{\textit{CntxtType}}\\
                           \smalltfield{fg}{(bg$\rightarrow T_1$)}}
                         then the \textit{combination of $\alpha$ and
    $\beta$  based on functional application}, $\alpha\text{@}\beta$, is
  \begin{quote}
   $\ulcorner\lambda c$:$[\alpha.\text{bg}]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{f}}$
      \d{$\wedge$}$\mathrm{incr}_{\mathfrak{s}.\text{x},\mathfrak{g}.\text{x}}([\beta.\text{bg}]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{a}},\alpha.\text{bg})$
      . \\
      \hspace*{2em}$[\alpha]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{f}}(c)(\mathrm{incr}_{\mathfrak{s}.\text{x},\mathfrak{g}.\text{x}}([\beta.\text{fg}]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{a}},\alpha.\text{bg})(c))\urcorner$

      
\end{quote}

 
\end{ex}

  

The content of \textit{Sam hugged}, which we will
represent as \textbf{Sam$^\frown$hugged}, is
\textbf{Sam}@\textbf{hug}$_{\mathit{VP}}$, that is \nexteg{a} which is
identical with \nexteg{b}.



\begin{ex} 
\begin{subex} 
 
\item \textbf{Sam$^\frown$hugged} = \\
  $\ulcorner\lambda c$:\smallrecord{
    \footnotesize{\textit{Cntxt}}\\
    \smalltfield{$\mathfrak{g}$}{\smallrecord{
        \smalltfield{x$_0$}{\textit{Ind}}}}\\
    \smalltfield{$\mathfrak{c}$}{\smallrecord{
        \smalltfield{f}{\smallrecord{
            \footnotesize{\textit{PropCntxt}}\\
            \smalltfield{x}{\textit{Ind}}\\
            \smalltfield{e}{named(x, ``Sam'')}}}\\
      \smalltfield{a}{\textit{PropCntxt}}}}}
  . \textbf{Sam}$_{\mathfrak{c}\leadsto\mathfrak{c}.\text{f}}$($c$)(\textbf{hug}$_{\mathit{VP},\mathfrak{c}\leadsto\mathfrak{c}.\text{a}}$($c$))$\urcorner$ 
 
\item
  $\ulcorner\lambda c$:\smallrecord{
    \footnotesize{\textit{Cntxt}}\\
    \smalltfield{$\mathfrak{g}$}{\smallrecord{
        \smalltfield{x$_0$}{\textit{Ind}}}}\\
    \smalltfield{$\mathfrak{c}$}{\smallrecord{
        \smalltfield{f}{\smallrecord{
            \footnotesize{\textit{PropCntxt}}\\
            \smalltfield{x}{\textit{Ind}}\\
            \smalltfield{e}{named(x, ``Sam'')}}}\\
      \smalltfield{a}{\textit{PropCntxt}}}}}
  .
  \smallrecord{\smalltfield{e}{hug($c$.f.x, $\lambda P$:\textit{Ppty} . $P$(\smallrecord{\field{x}{$c.\mathfrak{g}$.x$_0$}}))}}$\urcorner$
 
\end{subex} 
   
\end{ex}

In order to treat \textit{wh}-phrases we will add a fourth component
to contexts labelled with `$\mathfrak{w}$' for an assignment.  Thus we
revise \textit{Cntxt} to \nexteg{}.
\begin{ex} 
  \record{
    \tfield{$\mathfrak{s}$}{\textit{Assgnmnt}}\\
    \tfield{$\mathfrak{w}$}{\textit{Assgnmnt}}\\
    \tfield{$\mathfrak{g}$}{\textit{Assgnmnt}}\\
    \tfield{$\mathfrak{c}$}{\textit{PropCntxt}}} 
\end{ex}
We also modify the definition of combination to increment the
$\mathfrak{w}$-assignment as in \nexteg{}.
\begin{ex}
If $\alpha$ : \smallrecord{\smalltfield{bg}{\textit{CntxtType}}\\
                           \smalltfield{fg}{(bg$\rightarrow$($T_1\rightarrow
                             T_2$))}} 
and $\beta$ : \smallrecord{\smalltfield{bg}{\textit{CntxtType}}\\
                           \smalltfield{fg}{(bg$\rightarrow T_1$)}}
                         then the \textit{combination of $\alpha$ and
    $\beta$  based on functional application}, $\alpha\text{@}\beta$, is
  \begin{quote}
   $\ulcorner\lambda c$:$[\alpha.\text{bg}]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{f}}$
      \d{$\wedge$}$\mathrm{incr}_{\mathfrak{s}.\text{x},\mathfrak{w}.\text{x},\mathfrak{g}.\text{x}}([\beta.\text{bg}]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{a}},\alpha.\text{bg})$
      . \\
      \hspace*{2em}$[\alpha]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{f}}(c)(\mathrm{incr}_{\mathfrak{s}.\text{x},\mathfrak{w}.\text{x},\mathfrak{g}.\text{x}}([\beta.\text{fg}]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{a}},\alpha.\text{bg})(c))\urcorner$

      
\end{quote}

 
\end{ex}



The content of \textit{who}, which we will represent
as \textbf{who}, is given in \nexteg{}.
\begin{ex} 
\textbf{who} =
$\ulcorner\lambda c$:\smallrecord{
  \footnotesize{\textit{Cntxt}}\\
  \smalltfield{$\mathfrak{w}$}{\smallrecord{
      \smalltfield{x$_0$}{\textit{Ind}}}}}
. $\lambda P$:\textit{Ppty} . $P$(\smallrecord{\field{x}{$c.\mathfrak{w}.\text{x}_0$}})$\urcorner$ 
\end{ex}
This content is identical with the universal resource `SemWhPron' and
is exactly parallel to `SemPron' but using the context label
`$\mathfrak{w}$' rather than `$\mathfrak{s}$'.  There will also be a
universal lexical resource `LexWhPron' parallel to `LexPron',
characterized in \nexteg{}.
\begin{ex} 
If $T_{\text{phon}}$ is a phonological type, then
LexWhPron($T_{\text{phon}}$) is
\begin{quote}
Lex($T_{\mathrm{phon}}$, \textit{NP}) \d{$\wedge$}
\smallrecord{\smallmfield{cont}{SemWhPron}{\textit{PQuant}}}
\end{quote} 
\end{ex} 
\preveg{} makes a \textit{wh}-word such as \textit{who} into a noun
phrase and this is important, for instance, if it occurs in a noun
phrase position such as the subject or object of a sentence.  However,
these phrases also have a role as complementizers as \textit{who} does
in relative clauses, that is in a fronted position in the sentence and
not in a argument position to a verb or preposition.  It is important
in this case to recognize that this is a \textit{wh}-NP, that is, an
NP with a \textit{wh}-content.  For this we have the type in \nexteg{}
which we can abbreviate as \textit{WhNP}.
\begin{ex} 
  \record{
    \footnotesize{\textit{NP}}\\
    \mfield{cont}{SemWhPron}{\textit{PQuant}}}
\end{ex} 
A more general way of characterizing the type \textit{WhNP} is to
treat it as a basic type with the witness condition in \nexteg{}.
\begin{ex} 
$u$ : \textit{WhNP} iff $u$ : \textit{NP}, $u$.cont is $\mathcal{Q}$ and
$\mathcal{Q}.\text{bg}\sqsubseteq$\smallrecord{
  \smalltfield{$\mathfrak{w}$}{\smallrecord{
      \smalltfield{x$_i$}{\textit{Ind}}}}}, for some natural number $i$.

\end{ex} 
  


% In order to be able to characterize the kind of binding involved in
% combining \textit{who} with \textit{Sam hugged} we will define an
% operation, $\oplus$, which adds a field to a record or, if the label
% of the field being added
% is already present in the record, will replace that field with the new
% field.  This operation is characterized in \nexteg{}.
% \begin{ex} 
% If $r$ is a record, $\ell$ is a label and $v$ is some TTR object, then
% \\
% \hspace*{1em} $r\oplus[\ell=v]$ is \\
% \hspace*{2em} $r\cup\{\langle\ell,v\rangle\}$, if there is no $v'$
% such that $\langle\ell,v'\rangle\in r$\\
% \hspace*{2em}
% $(r-\{\langle\ell,r.\ell\rangle\})\cup\{\langle\ell,v\rangle\}$, otherwise 
% \end{ex} 
% We are using records here to do the work of partial variable
% assignments in logic and the $\oplus$-operation carries out the kind
% of modification which is performed on variable assignments when
% defining binding in the logical treatment.

In order to be able to characterize the kind of binding involved in
combining \textit{who} with \textit{Sam hugged} we will use the
notation $r[\pi=v]$ for a record, $r$, path, $\pi$, and value $v$.
This notation is characterized in \nexteg{}.
\begin{ex} 
If $r$ is a record, $\pi$ is $\ell_0.\ell_1.\ldots.\ell_n$ where
$\ell_0,\ell_1,\ldots,\ell_n$ are labels and $v$ is an object of some
type, then
\begin{quote}
  $r[\pi=v]$ is the record, $r'$, exactly like $r$ except for the
  possible difference that $r'.\pi=v$.
\end{quote}

\end{ex}
\begin{shaded}
  We can make \preveg{} more explicit as in \nexteg{}.
  \begin{ex} 
    If $r$ is a record, $\pi$ is $\ell_0.\ell_1.\ldots.\ell_n$ where
    $\ell_0,\ell_1,\ldots,\ell_n$ are labels and $v$ is an object of some
    type, then
    \begin{quote}
      if $\pi\not\in\mathrm{paths}(r)$, then $r[\pi=v]$ is the
      smallest record, $r'$, such that
      \begin{enumerate} 
        
      \item $\pi\in\mathrm{paths}(r')$ 
        
      \item $r'.\pi=v$
        
      \item for any $\pi'\in\mathrm{paths}(r)$,
        $\pi'\in\mathrm{paths}(r')$ and $r'.\pi'=r.\pi'$
        
      \end{enumerate} 

      if $\pi\in\mathrm{paths}(r)$, then $r[\pi=v]$ is the
      smallest record, $r'$, such that
      \begin{enumerate} 
        
      \item  $\pi\in\mathrm{paths}(r')$ and $r'.\pi=v$
        
      \item  for any $\pi'\in(\mathrm{paths}(r)-\{\pi''\mid
        \pi''\leq\pi\})$, $\pi'\in\mathrm{paths}(r')$ and $r'.\pi'=r.\pi'$
        
      \end{enumerate}
    \end{quote}
    
  

  \end{ex} 
  
Recall that $\pi_1\leq\pi_2$ as used in \preveg{} means that $\pi_1$
is an initial subpath of $\pi_2$ (see Chapter~\ref{ch:propnames}, p.~\pageref{ex:subpath}).

\end{shaded}

We generalize this notation so that we can use a record to modify
another record.  This is characterized in \nexteg{}, where
$\mathrm{tpaths}(r)$ represents the set of total paths in $r$ (Chapter~\ref{ch:percint},p.~\pageref{pg:record-paths}).
\begin{ex} 
If $r_1$ is a record and $r_2$ is a record such
$\mathrm{tpaths}(r_2)=\{\pi_1,\ldots,\pi_n\}$, then $r_1[r_2]$ is
$r_1[\pi_1=r_2.\pi_1]\ldots[\pi_n=r_2.\pi_n]$ 
\end{ex} 
  
  

This now gives us what we
need to characterize the content of the relative
clause \textit{who Sam hugged}, which we will represent as
\textbf{who}$^\frown$\textbf{Sam}$^\frown$\textbf{hugged}, as in
\nexteg{a} which is identical with \nexteg{b}.  \nexteg{b} is in turn
equivalent to \nexteg{c} because of the constraint on the extensional
predicate `hug' similar to that for `find' given in  (\ref{ex:mp-find})
on p.~\pageref{ex:mp-find}. 
\begin{ex} 
\begin{subex} 
 
\item \textbf{who}$^\frown$\textbf{Sam}$^\frown$\textbf{hugged} = \\
  $\ulcorner\lambda c$:\smallrecord{
    \footnotesize{\textit{Cntxt}}\\
    \smalltfield{$\mathfrak{c}$}{\smallrecord{
        \smalltfield{f}{\textit{PropCntxt}}\\
        \smalltfield{a}{\smallrecord{
        \smalltfield{f}{\smallrecord{
            \footnotesize{\textit{PropCntxt}}\\
            \smalltfield{x}{\textit{Ind}}\\
            \smalltfield{e}{named(x, ``Sam'')}}}\\
      \smalltfield{a}{\textit{PropCntxt}}}}}}} . \\
\hspace*{1em}$\ulcorner\lambda
  r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
  . \\
\hspace*{2em}\textbf{who}$_{\mathfrak{c}\leadsto\mathfrak{c}.\text{f}}$($c[\mathfrak{w}.\text{x}_0=r_1.\text{x}]$)
($\ulcorner\lambda
  r_2$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . \textbf{Sam}$^\frown$\textbf{hugged}$_{\mathfrak{c}\leadsto\mathfrak{c}.\text{a}}$($c[\mathfrak{g}.\text{x}_0=r_2.\text{x}]$)$\urcorner$)$\urcorner\urcorner$ 
 
\item $\ulcorner\lambda c$:\smallrecord{
    \footnotesize{\textit{Cntxt}}\\
    \smalltfield{$\mathfrak{c}$}{\smallrecord{
        \smalltfield{f}{\textit{PropCntxt}}\\
        \smalltfield{a}{\smallrecord{
        \smalltfield{f}{\smallrecord{
            \footnotesize{\textit{PropCntxt}}\\
            \smalltfield{x}{\textit{Ind}}\\
            \smalltfield{e}{named(x, ``Sam'')}}}\\
        \smalltfield{a}{\textit{PropCntxt}}}}}}} . \\
\hspace*{1em}$\ulcorner\lambda
  r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
  . \smallrecord{\smalltfield{e}{hug($c.\mathfrak{c}.$a.f.x, $\lambda P$:\textit{Ppty}
      . $P$(\smallrecord{\field{x}{$r_1$.x}}))}}$\urcorner\urcorner$

\item $\ulcorner\lambda c$:\smallrecord{
    \footnotesize{\textit{Cntxt}}\\
    \smalltfield{$\mathfrak{c}$}{\smallrecord{
        \smalltfield{f}{\textit{PropCntxt}}\\
        \smalltfield{a}{\smallrecord{
        \smalltfield{f}{\smallrecord{
            \footnotesize{\textit{PropCntxt}}\\
            \smalltfield{x}{\textit{Ind}}\\
            \smalltfield{e}{named(x, ``Sam'')}}}\\
      \smalltfield{a}{\textit{PropCntxt}}}}}}} . $\ulcorner\lambda
  r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
  . \smallrecord{\smalltfield{e}{hug$^\dagger$($c.\mathfrak{c}.$a.f.x, $r_1$.x))}}$\urcorner\urcorner$ 
 
\end{subex} 
   
\end{ex}

In order to achieve this we need a general operation of
\textit{wh}-combination which will pass whatever context restrictions
are associated with the \textit{wh}-phrase and those that are
associated with the phrase with which it is being combined up to
context restrictions associated with the whole phrase except for those
associated with the paths `$\mathfrak{w}.\text{x}_i$' (for the
\textit{wh}-phrase which is binding the gap) and
`$\mathfrak{g}.\text{x}_j$' (for the gap being bound).  The
discharging of the requirements associated with these two paths will
involve subtracting them from the types which are passed up to the
context type for the combined phrase.

As record types are labelled
sets (Chapter~\ref{ch:percint}, p.~\pageref{ex:ndrectypes}ff.), this
subtraction is based on set-theoretic subtraction.  % We will limit what
% can be subtracted to total paths (Chapter~\ref{ch:percint},
% p.~\pageref{ex:paths-rectype}).  In \nexteg{} we give a preliminary
% characterization of what it means to subtract a total path, $\pi$,
% from a record type, $T$ which we represent as $T\ominus\pi$.
% \begin{ex} 
% (preliminary) If $T$ is a record type and $\pi\in\mathrm{tpaths}(T)$, then
% $T\ominus\pi$ is the type $T'$ exactly like $T$ except that $\mathrm{tpaths}(T')=\mathrm{tpaths}(T)-\{\pi\}$. 
% \end{ex}

We first define what it means to subtract the field labelled $\ell$
from an assignment type, $T$, in \nexteg{}.
\begin{ex} 
  If $T$ is $\textit{Assgnmnt}\wedge T'$ and
  $\ell\in\mathrm{labels}(T')$, then
  \begin{enumerate} 
    
  \item if $\mathrm{labels}(T')=\{\ell\}$, $T\ominus\ell=\textit{Assgnmnt}$ 
    
  \item otherwise, $T\ominus\ell=\textit{Assgnmnt}\wedge (T'-\{\langle\ell,T'.\ell\rangle\})$ 
    
  \end{enumerate} 
    
\end{ex} 
Based on \preveg{} we can define the subtraction of a path to an
assignment in a context type given in \nexteg{}.
\begin{ex} (preliminary)
  
  If $T\sqsubseteq$ \smallrecord{
    \footnotesize{\textit{Cntxt}}\\
    \smalltfield{$\ell_1$}{\smallrecord{
        \footnotesize{\textit{Assgnmnt}}\\
        \smalltfield{$\ell_2$}{\textit{Ind}}}}}, then
  $T\ominus\ell_1.\ell_2$ is $T$\fbox{\d{$\wedge$}}\smallrecord{
    \smalltfield{$\ell_1$}{$(T.\ell_1\ominus\ell_2)$}}
\end{ex} 
  
\begin{shaded}
  
This is a preliminary definition because it does not take account of
what happens if the path that is being removed has dependent fields
associated with it.  Suppose, for example, that the context type
associated with \textit{who} were \nexteg{} where we represent the
presupposition that what is associated with \textit{who} is a person.
\begin{ex} 
  \record{
    \footnotesize{\textit{Cntxt}}\\
    \tfield{$\mathfrak{w}$}{\record{
        \tfield{x$_0$}{\textit{Ind}}}}\\
    \tfield{$\mathfrak{c}$}{\record{
        \tfield{e}{person($\Uparrow$$\mathfrak{w}$.x$_0$)}}}}
\end{ex}
Suppose that $T$ is \preveg{}. Then $T\ominus\mathfrak{w}.\text{x}_0$
according to our present definition would be \nexteg{} which is not a
record type since there is a dependence on `$\mathfrak{w}.\text{x}_0$'
but there is no such path.
\begin{ex} 
 \record{
    \footnotesize{\textit{Cntxt}}\\
    \tfield{$\mathfrak{w}$}{\textit{Assgnmnt}}\\
    \tfield{$\mathfrak{c}$}{\record{
        \tfield{e}{person($\Uparrow$$\mathfrak{w}$.x$_0$)}}}}
\label{ex:who-person}
\end{ex} 
The solution to this is to extend the definition of subtraction so
that it removes not only the path referred to but also those paths
that depend on it.  Thus the result of
$T\ominus\mathfrak{w}.\text{x}_0$ should rather be \nexteg{}.
\begin{ex} 
\record{
    \footnotesize{\textit{Cntxt}}\\
    \tfield{$\mathfrak{w}$}{\textit{Assgnmnt}}\\
    \tfield{$\mathfrak{c}$}{\textit{PropCntxt}}} 
\end{ex} 
In this particular case, the resulting type, \preveg{}, is actually
identical with \textit{Cntxt}.


Actually, things are more complicated that this.  For any path we
remove by this method we must recursively remove all the dependencies
on that path.  Thus if something had depended on
`$\mathfrak{c}.\text{e}$' in the above example we would have had to
remove that and so on. In our context types, as defined here, all the
dependencies on assignments will occur under the label
`$\mathfrak{c}$', that is, in the propositional context.  It is
perhaps most straightforward to use the unique identifier notation
introduced in Chapter~\ref{ch:infex},
p.~\pageref{pg:unique-identifier-notation}, in order to identify paths
which depend on another path.  Consider again
(\ref{ex:who-person}). In unique identifier notation this is
\nexteg{}.
\begin{ex}
  \record{
    \footnotesize{\textit{Cntxt}}\\
    \tfield{$\mathfrak{w}$}{\record{
        \tfield{x$_{0_\text{\fbox{0}}}$}{\textit{Ind}}}}\\
    \tfield{$\mathfrak{c}$}{\record{
        \tfield{e}{person(\fbox{0})}}}}
\end{ex}
In \preveg{}, the path `$\mathfrak{c}$.e' depends on
`$\mathfrak{w}$.x$_0$'  because the representation of the type at the
former contains the unique identifier which indexes the latter.  We
give a general characterization of dependency between paths in a
record type in \nexteg{}.
\begin{ex} 
If $T$ is a record type, $\pi_1\in\mathrm{paths}(T)$ and
$\pi_2\in\mathrm{tpaths}(T)$, then $\pi_2$ \textit{depends on} $\pi_1$
iff, in unique identifier notation, $\pi_1$ is indexed with \fbox{$i$}
and the representation of $T.\pi_2$ contains \fbox{$i$}, for some
natural number $i$.
\end{ex} 
Given this notion of dependency it is then possible to define the set
of paths in a record type, $T$, which constitute a dependency family on some
particular path, $\pi$, which we will represent as
$\mathrm{paths}_{\pi}(T)$.  This is given in \nexteg{}.
\begin{ex} 
If $T$ is a record type and $\pi\in\mathrm{paths}(T)$ then \textit{the
  dependenvy family of $\pi$ in $T$},
$\mathrm{paths}_\pi(T)$, is that subset, $\Pi$, of $\mathrm{paths}(T)$
such that
\begin{enumerate} 
 
\item $\pi\in\Pi$ 
 
\item for any $\pi'\in\Pi$ and $\pi''\in\mathrm{tpaths}(T)$, if
  $\pi''$ depends on $\pi'$, then $\pi''\in\Pi$

\item for and $\pi'\in\Pi$ and $\pi''\in\mathrm{paths}(T)$, if $\pi'$
  depends on $\pi''$, then $\pi''\in\Pi$
 
\end{enumerate} 
  
\end{ex}
That is, the dependency family of $\pi$ includes $\pi$ itself,
anything that depends on anything in the dependency family and
anything on which something in the dependency family depends.  This
dependency family gives rise to a generalization of the original type,
$T$, which we will call \textit{$T$ generalized to $\pi$}, $T^\pi$.
We define this in \nexteg{}.
\begin{ex} 
If $T$ is a record type and $\pi\in\mathrm{paths}(T)$, then $T$
\textit{generalized to} $\pi$, $T^\pi$, is the smallest labelled set $T'$ such
that $\mathrm{paths}_\pi(T)\subseteq\mathrm{paths}(T')$ and for all
$\pi'\in\mathrm{tpaths}(T')$, $T'.\pi=T.\pi$ 
\end{ex}
We give a definition of a more general version of \preveg{} in
\nexteg{} where we generalize to several paths in a type
simultaneously.
\begin{ex} 
If $T$ is a record type and $\{\pi_1,\ldots,\pi_n\}\subset\mathrm{paths}(T)$, then $T$
\textit{generalized to} $\pi_1,\ldots,\pi_n$, $T^{\pi_1,\ldots,\pi_n}$, is the smallest labelled set $T'$ such
that for all $\pi_i\in\{\pi_1,\ldots,\pi_n\}$, $\mathrm{paths}_{\pi_i}(T)\subseteq\mathrm{paths}(T')$ and for all
$\pi'\in\mathrm{tpaths}(T')$, $T'.\pi=T.\pi$ 
\end{ex}
This notion of generalization is important if we wish to associate
presuppositions with \textit{wh}-phrases and extract them from the
context type for local accommodation at the point at which the
\textit{wh}-phrase binds a gap.

We can now generalize the subtraction operation, $\ominus$, as in
\nexteg{}.
\begin{ex} 
  \begin{enumerate}
    
  \item If $T$ is a record type and
    $\{\pi_1,\ldots,\pi_n\}\subset\mathrm{paths}(T)$, then
    $T\ominus\pi_1,\ldots,\pi_n$ is $T\ominus\pi_1\ldots\ominus\pi_n$
 
\item If $T$ is a record type, $\pi\in\mathrm{paths}(T)$ and
  $\mathrm{paths}_\pi(T)=\{\pi,\pi_1,\ldots,\pi_n\}$, then
  \begin{quote}
    we normally write $T\ominus\pi$ for
    $T\ominus\pi,\pi_1,\ldots,\pi_n$
  \end{quote}
  
 
\item If $T$ is $\textit{Assgnmnt}\wedge T'$ and
  $\ell\in\mathrm{labels}(T')$, then
  \begin{enumerate} 
    
  \item if $\mathrm{labels}(T')=\{\ell\}$, $T\ominus\ell=\textit{Assgnmnt}$ 
    
  \item otherwise, $T\ominus\ell=\textit{Assgnmnt}\wedge (T'-\{\langle\ell,T'.\ell\rangle\})$ 
    
  \end{enumerate}
  
\item If $T$ is $\textit{PropCntxt}\wedge T'$ and
  $\ell\in\mathrm{labels}(T')$, then
  \begin{enumerate} 
    
  \item if $\mathrm{labels}(T')=\{\ell\}$, $T\ominus\ell=\textit{PropCntxt}$
    
  \item otherwise, $T\ominus\ell=\textit{PropCntxt}\wedge(T'-\{\langle\ell,T'.\ell\rangle\})$ 
    
  \end{enumerate} 

\item If $T$ is $\textit{PropCntxt}\wedge T'$ and
  $\ell.\pi\in\mathrm{tpaths}(T')$ then
  \begin{quote}
    $T\ominus\ell.\pi=\textit{PropCntxt}\wedge T'$\fbox{\d{$\wedge$}}\smallrecord{
      \smalltfield{$\ell$}{$T'.\ell\ominus\pi$}}
  \end{quote}

\item Otherwise, if $T$ is a labelled set, then
  \begin{enumerate}
  \item if $\ell.\pi\in\mathrm{tpaths}(T)$, $T\ominus\ell.\pi=T'$\fbox{\d{$\wedge$}}\smallrecord{
      \smalltfield{$\ell$}{$T.\ell\ominus\pi$}}
  \item otherwise, $T\ominus\pi$ is $T$
  \end{enumerate}

  
 
\end{enumerate} 
\label{ex:ominus}   
\end{ex} 


  
  
\end{shaded}

We can now create a preliminary definition of combination based on
functional application for \textit{wh}-phrases and sentences with
gaps, `@$_{\mathrm{wh}}$', characterized in \nexteg{}.
\begin{ex} 
  (preliminary)

  If
  \begin{enumerate}
  \item $\alpha$ : \smallrecord{
      \smalltfield{bg}{\textit{CntxtType}}\\
      \smalltfield{fg}{(bg$\rightarrow$\textit{Quant})}},
    
  \item $\beta$ : \smallrecord{
      \smalltfield{bg}{\textit{CntxtType}}\\
      \smalltfield{fg}{(bg$\rightarrow$\textit{RecType})}},
    
  \item $\alpha$.bg $\sqsubseteq$ \smallrecord{
      \smalltfield{$\mathfrak{w}$}{\smallrecord{
          \smalltfield{x$_i$}{\textit{Ind}}}}} for some natural number,
    $i$, and
    
  \item $\beta$.bg $\sqsubseteq$ \smallrecord{
      \smalltfield{$\mathfrak{g}$}{\smallrecord{
          \smalltfield{x$_j$}{\textit{Ind}}}}} for some natural number,
    $j$,
  \end{enumerate}
  then \textit{the \textit{wh}$_{i,j}$-combination of $\alpha$ and
    $\beta$}, $\alpha\text{@}_{\mathrm{wh}_{i,j}}\beta$, is
  \begin{quote}
    $\ulcorner\lambda
    c$:([$\alpha$.bg$\ominus\mathfrak{w}.\text{x}_i$]$_{\mathfrak{c}\leadsto\mathfrak{c}.\text{f}}$\d{$\wedge$}$\mathrm{incr}_{\mathfrak{s}.\text{x},\mathfrak{w}.\text{x},\mathfrak{g}.\text{x}}([\beta.\text{bg}\ominus\mathfrak{g}.\text{x}_j]_{\mathfrak{c}\leadsto\mathfrak{c}.a},\alpha.\text{bg})$)
    .
    \hspace*{1em} $\mathfrak{P}(\ulcorner\lambda r_1$:\smallrecord{
      \smalltfield{x}{\textit{Ind}}\\
      \smalltfield{$\mathfrak{w}$}{\smallrecord{
          \smallmfield{x$_i$}{$\Uparrow$x}{\textit{Ind}}}}} . \\
    \hspace*{4em}$\alpha_{\mathfrak{c}\leadsto\mathfrak{c}.\text{f}}(c[r_1])$
    ($\mathfrak{P}(\ulcorner\lambda r_2$:\smallrecord{
      \smalltfield{x}{\textit{Ind}}\\
      \smalltfield{$\mathfrak{g}$}{\smallrecord{
          \smallmfield{x$_j$}{$\Uparrow$x}{\textit{Ind}}}}} . \\
    \hspace*{13em}$\mathrm{incr}_{\mathfrak{s}.\text{x},\mathfrak{w}.\text{x},\mathfrak{g}.\text{x}}(\beta_{\mathfrak{c}\leadsto\mathfrak{c}.\text{a}},\alpha.\text{bg})(c[r_2])\urcorner)$)$\urcorner)\urcorner$
  \end{quote}
  
\end{ex}
Recall that $\mathfrak{P}(P)$ represents the purification of the
property $P$ defined in (\ref{ex:purification}) on p.~\pageref{ex:purification}.
 
\begin{shaded}
We can adjust \preveg{} to take account of any presuppositions
introduced by the \textit{wh} and gap interpretations as in \nexteg{}.
\begin{ex} 
  If
  \begin{enumerate}
  \item $\alpha$ : \smallrecord{
      \smalltfield{bg}{\textit{CntxtType}}\\
      \smalltfield{fg}{(bg$\rightarrow$\textit{Quant})}},
    
  \item $\beta$ : \smallrecord{
      \smalltfield{bg}{\textit{CntxtType}}\\
      \smalltfield{fg}{(bg$\rightarrow$\textit{RecType})}},
    
  \item $\alpha$.bg $\sqsubseteq$ \smallrecord{
      \smalltfield{$\mathfrak{w}$}{\smallrecord{
          \smalltfield{x$_i$}{\textit{Ind}}}}} for some natural number,
    $i$, and
    
  \item $\beta$.bg $\sqsubseteq$ \smallrecord{
      \smalltfield{$\mathfrak{g}$}{\smallrecord{
          \smalltfield{x$_j$}{\textit{Ind}}}}} for some natural number,
    $j$,
  \end{enumerate}
  then \textit{the \textit{wh}$_{i,j}$-combination of $\alpha$ and
    $\beta$}, $\alpha\text{@}_{\mathrm{wh}_{i,j}}\beta$, is
  \begin{quote}
    $\ulcorner\lambda
    c$:([$\alpha$.bg$\ominus\mathrm{paths}_{\mathfrak{w}.\text{x}_i}(\alpha.\text{bg})]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{f}}$\d{$\wedge$}\\
    \hspace*{5em}$\mathrm{incr}_{\mathfrak{s}.\text{x},\mathfrak{w}.\text{x},\mathfrak{g}.\text{x}}([\beta.\text{bg}\ominus\mathrm{paths}_{\mathfrak{g}.\text{x}_j}(\beta.\text{bg})]_{\mathfrak{c}\leadsto\mathfrak{c}.a},\alpha.\text{bg})$)
    . \\
    \hspace*{1em} $\mathfrak{P}(\ulcorner\lambda r_1$:$[\alpha.\text{bg}^{\mathfrak{w}.\text{x}_i}]_{\mathfrak{w}.\text{x}_i\leadsto\text{x}}$ . \\
    \hspace*{4em}$\alpha_{\mathfrak{c}\leadsto\mathfrak{c}.\text{f},\mathfrak{w}.\text{x}_i\leadsto\text{x}}(c[r_1])$
    ($\mathfrak{P}(\ulcorner\lambda r_2$:$[\beta.\text{bg}^{\mathfrak{g}.\text{x}_j}]_{\mathfrak{g}.\text{x}_j\leadsto\text{x}}$ . \\
    \hspace*{15em}$\mathrm{incr}_{\mathfrak{s}.\text{x},\mathfrak{w}.\text{x},\mathfrak{g}.\text{x}}(\beta_{\mathfrak{c}\leadsto\mathfrak{c}.\text{a},\mathfrak{g}.\text{x}_j\leadsto\text{x}},\alpha.\text{bg})(c[r_2])\urcorner)$)$\urcorner)\urcorner$
  \end{quote} 
\end{ex}
The effect of the property purification here will be to locally
accommodate whatever presuppositions are associated
`$\mathfrak{w}.\text{x}_i$' or `$\mathfrak{g}.\text{x}_j$' at the
level at which the \textit{wh}-binding takes place.
  
We leave the treatment of contraints on long distance dependencies
like \textit{wh}-constructions (such as \textit{island constraints})
to future work.  The strategy for handling these would be to elaborate
on the conditions 1.--4. in \preveg{} or as conditions associated with
constituent structure rules.
\end{shaded}
We can then define a version of `ContForwardApp' (forward application
of contents) based on wh$_{i,j}$-combination as given in \nexteg{}.
\begin{ex} 
If $T_{\text{fun}}$, $T_{\text{arg}}$ and $T_{\text{res}}$ are types
such that if $\alpha:T_{\text{fun}}$ and $\beta:T_{\text{arg}}$, then
$\alpha\text{@}_{\text{wh}_{i,j}}\beta$ is defined and of type
$T_{\text{res}}$, then
\begin{quote}
  ContForwardApp$_{\text{@}_{\text{wh}_{i,j}}}$($T_{\text{fun}},T_{\text{arg}},T_{\text{res}}$)
\end{quote}
is
\begin{quote}
  $\lambda u$:\smallrecord{
    \smalltfield{cont}{$T_{\text{fun}}$}}$^\frown$\smallrecord{
    \smalltfield{cont}{$T_{\text{arg}}$}} . \smallrecord{
    \smallmfield{cont}{$u[0]$.cont@$_{\text{wh}_{i,j}}u[1]$.cont}{$T_{\text{res}}$}}
\end{quote}
  
\end{ex}
We can then characterize a notation for phrase structure rules which
use `ContForwardApp$_{\text{@}_{\text{wh}_{i,j}}}$' as in \nexteg{}.
\begin{ex} 
If $T_{\text{mother}}$, $T_{\text{daughter}_1}$ and
  $T_{\text{daughter}_2}$ are sign
  types, $T_{\text{daughter}_1}\sqsubseteq$\smallrecord{
    \smallmfield{cont}{$c_1$}{\textit{Cont}}} where
  $c_1.\text{bg}\sqsubseteq$\smallrecord{
    \smalltfield{$\mathfrak{w}$}{\smallrecord{
        \smalltfield{x$_i$}{\textit{Ind}}}}}, $T_{\text{daughter}_2}\sqsubseteq$\smallrecord{
    \smallmfield{cont}{$c_2$}{\textit{Cont}}} where
  $c_2.\text{bg}\sqsubseteq$\smallrecord{
    \smalltfield{$\mathfrak{g}$}{\smallrecord{
        \smalltfield{x$_j$}{\textit{Ind}}}}} and $T_{\text{arg}}$ and
  $T_{\text{res}}$ are content types, then
  \begin{quote}
    $T_{\text{mother}}\longrightarrow
    T_{\text{daughter}_1}\ T_{\text{daughter}_2}\ \mid\
T_{\text{daughter}_1}'(_{\text{@}_{\text{wh}_{i,j}}}T_{\text{daughter}_2}':T_{\text{arg}}):T_{\text{res}}$
  \end{quote}
  is
  \begin{quote}
  $T_{\text{mother}}\longrightarrow
    T_{\text{daughter}_1}\ T_{\text{daughter}_2}$ \d{\d{$\wedge$}}
    ContForwardApp$_{\text{@}_{\text{wh}_{i,j}}}$($T_{\text{arg}}$, $T_{\text{res}}$)
  \end{quote}  
 
\end{ex} 
We introduce a sign type \textit{Rel} which
requires the category to be `rel' for relative clause  and types
\textit{NP}$_{\text{wh}_i}$ and \textit{S}/$j$ whose witness
conditions are given in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item $\alpha:\textit{NP}_{\text{wh}_i}$ iff $\alpha:\textit{NP}$ and
  $\alpha.\text{cont}.\text{bg}\sqsubseteq$\smallrecord{
    \smalltfield{$\mathfrak{w}$}{\smallrecord{
        \smalltfield{x$_i$}{\textit{Ind}}}}}
 
\item $\alpha:\textit{S}/j$ iff $\alpha:\textit{S}$ and $\alpha.\text{cont}.\text{bg}\sqsubseteq$\smallrecord{
    \smalltfield{$\mathfrak{g}$}{\smallrecord{
        \smalltfield{x$_j$}{\textit{Ind}}}}} 
 
\end{subex} 
   
\end{ex} 
The slash notation `$\textit{S}/j$' is derived from the use of slash
categories to represent constituents containing gaps in Generalized
Phrase Structure Grammar \citep{GazdarKleinPullumSag1985}  and Head
Driven Phrase Structure Grammar \citep{Sag:Wasow:ea:03}.

We can now add the rule in \nexteg{} to the language specific
resources for English.
\begin{ex} 
\textit{Rel} $\longrightarrow$ \textit{NP}$_{\text{wh}_i}$
\textit{S}/$j$ $\mid$
   \textit{NP}$_{\text{wh}_i}'$($_{\text{@}_{\text{wh}_{i,j}}}$\textit{S}/$j'$:\textit{PRecType}):\textit{PPpty} 
\end{ex} 
  
  



To form the content of a noun modified by a relative clause such as
\textit{child who Sam hugged} we use a record type which requires of
an individual that it has both the property of being a child and being
hugged by Sam as given in \nexteg{}.
\begin{ex} 
  $\ulcorner\lambda c$: \smallrecord{
    \footnotesize{\textit{Cntxt}}\\
    \smalltfield{$\mathfrak{c}$}{\smallrecord{
        \smalltfield{f}{\textit{PropCntxt}}\\
        \smalltfield{a}{\smallrecord{
            \smalltfield{f}{\textit{PropCntxt}}\\
            \smalltfield{a}{\smallrecord{
                \smalltfield{f}{\smallrecord{
                    \footnotesize{\textit{PropCntxt}}\\
                    \smalltfield{x}{\textit{Ind}}\\
                    \smalltfield{e}{named(x, ``Sam'')}}}\\
                \smalltfield{a}{\textit{PropCntxt}}}}}}}}} .  \\
  \hspace*{1em}$\ulcorner\lambda
  r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
  . \\
  \hspace*{2em}\record{
    \tfield{e$_1$}{child$'$\{$r$.x\}}\\
    \tfield{e$_2$}{\textbf{who$^\frown$Sam$^\frown$hugged$_{\mathfrak{c}\leadsto\mathfrak{c}.\text{a}}$}($c$)\{$r$.x\}}}$\urcorner\urcorner$  
\end{ex}

In order to achieve this we will first introduce an operation of
property conjunction in \nexteg{}.  As a preliminary, we introduce
types for properties and parametric properties of particular types of
objects.  This is done in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item If $T$ is a type, then $^T\textit{Ppty}$ is a type -- ``the type
  of properties of objects of type $T$'' 
 
\item $P:{^T\textit{Ppty}}$ iff $P:\textit{Ppty}$ and
  $P.\text{bg}\sqsubseteq$ \smallrecord{
    \smalltfield{x}{$T$}}
  
\item If $T$ is a type, then $^T\textit{PPpty}$ is a type -- ``the type
  of parametric properties of objects of type $T$''
  
\item $\mathcal{P}:{^T\textit{PPpty}}$ iff
  $\mathcal{P}:\textit{PPpty}$ and for any $c:\mathcal{P}.\text{bg}$, $\mathcal{P}(c):{^T\textit{Ppty}}$
 
\end{subex} 
   
\end{ex}
We can now characterize property conjunction as in \nexteg{}.
\begin{ex} 
If $T$ is a type, $P_1:{^T\textit{Ppty}}$ and $P_2:{^T\textit{Ppty}}$,
then \textit{the conjunction of $P_1$ and
  $P_2$}, $P_1\&P_2$, is
\begin{quote}
  $\ulcorner\lambda r$:\smallrecord{
    \smalltfield{x}{$T$}} .
  \record{
    \tfield{e$_1$}{$P_1\{r.\text{x}\}$}\\
    \tfield{e$_2$}{$P_2\{r.\text{x}\}$}}$\urcorner$
\end{quote}

\end{ex}
We can now characterize a combination operation, @$_{\&}$, in
\nexteg{}.
\begin{ex}
  
  If $T$ is a type, $\alpha:{^T\textit{PPpty}}$ and
  $\beta:{^T\textit{PPpty}}$ 
  then \textit{the property conjunction
    combination of $\alpha$ and $\beta$}, $\alpha\text{@}_{\&}\beta$,
  is
\begin{quote}
  $\lambda
  c$:$[\alpha.\text{bg}]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{f}}$\d{$\wedge$}$\mathrm{incr}_{\mathfrak{s}.\text{x}}([\beta.\text{bg}]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{a}},\alpha.\text{bg})$
        . $\alpha_{\mathfrak{c}\leadsto\mathfrak{c}.\text{f}}(c)\&\mathrm{incr}_{\mathfrak{s}.\text{x}}([\beta]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{a}},\alpha.\text{bg})(c)$
\end{quote}
\end{ex}

We introduce a version of `ContForwardApp' for `@$_{\text{\&}}$' in
\nexteg{}.
\begin{ex} 
  If $T$ is a type, then ContForwardApp$_{\text{@}_{\&}}$($T$) is
  \begin{quote}
    $\lambda u$:\record{
      \tfield{cont}{${^T\textit{PPpty}}$}}$^\frown$\record{
      \tfield{cont}{${^T\textit{PPpty}}$}} .\\
    \hspace*{1em}\record{
      \mfield{cont}{$u[0].\text{cont}\text{@}_{\&}u[1].\text{cont}$}{${^T\textit{PPpty}}$}}
  \end{quote}
  
\end{ex} 
We can then introduce a notation of constituent structure rules which
use `ContForwardApp$_{\text{@}_{\&}}$' in \nexteg{}.
\begin{ex} 
If $T$ is a type, $T_{\text{mother}}$, $T_{\text{daughter}_1}$ and
$T_{\text{daughter}_2}$ are sign types,
$T_{\text{daughter}_1}\sqsubseteq$ \record{
  \tfield{cont}{$^T\textit{PPpty}$}} and $T_{\text{daughter}_2}\sqsubseteq$ \record{
  \tfield{cont}{$^T\textit{PPpty}$}}, then
  \begin{quote}
    $T_{\text{mother}}\longrightarrow T_{\text{daughter}_1}\
    T_{\text{daughter}_2}\ \mid\
    T_{\text{daughter}_1}'(_{\text{@}_{\&}}T_{\text{daughter}_2}':{^T\textit{PPpty}}):{^T\textit{PPpty}}$
  \end{quote}
  is
  \begin{quote}
    $T_{\text{mother}}\longrightarrow T_{\text{daughter}_1}\
    T_{\text{daughter}_2}$ \d{\d{$\wedge$}}
    ContForwardApp$_{\text{@}_{\&}}$($T$)
  \end{quote}
  
\end{ex} 
Finally, we introduce the English rules for combining common nouns
with relative clauses. First we introduce types $^T\textit{N}$ and
$^T\textit{Rel}$ in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item If $T$ is a type, then $^T\textit{N}$ and $^T\textit{Rel}$ are types. 
 
\item $u:{^T\textit{N}}\text{ or }{^T\textit{Rel}}$ iff
  $u:\textit{N}\text{ or }\textit{Rel}$ and $u.\text{cont}:{^T\textit{PPpty}}$ 
 
\end{subex} 
   
\end{ex} 
For any type, $T$, we introduce the constituent structure rule in
\nexteg{}.
\begin{ex} 
$\textit{N}\longrightarrow{^T\textit{N}}\ {^T\textit{Rel}}\ \mid\ {^T\textit{N}}'(_{\text{@}_\&}{^T\textit{Rel}}':{^T\textit{PPpty}}):{^T\textit{PPpty}}$
\end{ex}
  
        



  
\section{Quantifier scope and underspecification}
\label{sec:qscope-underspec}

Given the kind of interpretation rules we have so far we can obtain a
reading for \nexteg{a} which corresponds to the 
content 
in \nexteg{b}, using the abbreviations `boy$'$' as
introduced in Chapter~\ref{ch:commonnouns}, example
(\ref{ex:dogprime}), \textbf{hug} for the parametric content of
\textit{hug} and \textbf{every}$^\frown$\textbf{dog} for the
parametric content of \textit{every dog}.
\begin{ex} 
\begin{subex} 
 
\item a boy hugged every dog 
 
\item % $\lambda \mathfrak{s}$:\textit{Rec} . \smallrecord{\smalltfield{e}{exist(boy$'$, $\lambda
%       r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . 
% \smallrecord{\smalltfield{e}{every(dog$'$, 
% $\lambda r_2$: \smallrecord{\smalltfield{x}{\textit{Ind}}} . 
% \smallrecord{\smalltfield{e}{hug($r_1$.x, $r_2$.x)}})}})}}
  $\ulcorner\lambda c$:\textit{Cntxt} .
  \record{
    \mfield{restr}{boy$'$}{\textit{Ppty}}\\
    \mfield{scope}{\textbf{hug}($c$)(\textbf{every}$^\frown$\textbf{dog}($c$))$\mid_{\mathcal{F}(\text{boy}')}$}{\textit{Ppty}}\\
    \tfield{e}{exist(restr, scope)}}$\urcorner$
 
\end{subex} 
   
\end{ex} 
This, of course, represents the reading where there is a boy such that
he hugs every dog.  % Notice that here we have vacuous abstraction over
% pronominal contexts and the constraint on them is that they are a record of
% some kind without requiring any particular fields.
In order to obtain the reading where \textit{every dog} has wide
scope, we follow Montague and pretty much everybody else in basing our
treatment of quantifier scope on the treatment of free pronouns,
though without the contribution of any gender information.  Let us
imagine just for a moment that such a pronoun existed in English and
is written as \textit{it$^*$} with the kind of pronoun interpretations
given in Chapter~\ref{ch:propnames}, Section~\ref{sec:unbound}.  Then the content for \nexteg{a} could be
\nexteg{b}.



\begin{ex} 
\begin{subex} 
 
\item a boy hugged it$^*$
 
\item % $\lambda \mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}} . 
% \smallrecord{\smalltfield{e}{exist(boy$'$, $\lambda
%     r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
%     . \smallrecord{\smalltfield{e}{hug($r$.x,
%     $\mathfrak{s}$.x$_0$)}})}}
  $\lambda c$:\smallrecord{
    \footnotesize{\textit{Cntxt}}\\
    \smalltfield{$\mathfrak{s}$}{\smallrecord{
        \smalltfield{x$_0$}{\textit{Ind}}}}} . \\
  \hspace*{1em}\record{
    \mfield{restr}{boy$'$}{\textit{Ppty}}\\
    \mfield{scope}{\textbf{hug}($c$)($\lambda P$:\textit{Ppty}
      . $P\{c.\mathfrak{s}.\text{x}_0\}$)$\mid_{\mathcal{F}(\text{boy}')}$}{\textit{Ppty}}\\
    \tfield{e}{exist(restr, scope)}}
 
\end{subex} 
 \label{ex:it-star}  
\end{ex}
We will refer to \preveg{b} as
`\textbf{a}$^\frown$\textbf{boy}$^\frown$\textbf{hugged}$^\frown$\textbf{it$^*$}'.
Let
us further imagine, contrary to fact, that English represented the fact
that a noun phrase has wide scope over a sentence by placing it at the
beginning of a sentence as in \nexteg{a} and giving it an
interpretation where the interpretation of \textit{it$^*$} gets bound
as in \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item every dog, a boy hugged it$^*$ 
 
\item % $\lambda\mathfrak{s}$:\textit{Rec} . 
% \smallrecord{\smalltfield{e}{every(dog$'$,
% $\lambda r_1$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}} . 
% \smallrecord{\smalltfield{e}{exist(boy$'$, $\lambda
%     r_2$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
%     . \smallrecord{\smalltfield{e}{hug($r_2$.x, $r_1$.x$_0$)}})}})}}
  $\lambda c$:\textit{Cntxt} . \\
  \hspace*{1em}\record{
    \mfield{restr}{dog$'$}{\textit{Ppty}}\\
    \mfield{scope}{$\lambda r$:\smallrecord{
        \smalltfield{x}{\textit{Ind}}}
      . \textbf{a}$^\frown$\textbf{boy}$^\frown$\textbf{hugged}$^\frown$\textbf{it$^*$}
      ($c[\mathfrak{s}.\text{x}_0=r.\text{x}]$)$\mid_{\mathcal{F}(\text{dog}')}$}{\textit{Ppty}}\\
    \tfield{e}{every(restr, scope)}}

 
\end{subex} 
\label{ex:edabhi}   
\end{ex} 
The imaginary English expression \preveg{a} corresponds quite closely
to the kind of representation for wide scope readings that are used in
various theories of logical form.  A major difference is that in
logical form there is an index corresponding to the label `x$_0$' that
we use in the interpretation which shows that \textit{every dog} binds
\textit{it$^*$}.  This might be represented something like in
\nexteg{}.
\begin{ex} 
every dog$_{x_0}$, a boy hugged it$^*_{x_0}$ 
\end{ex} 
The imaginary sentence (\ref{ex:edabhi}a) also corresponds closely to
Montague's (\citeyear{Montague1973}) treatment of scope phenomena.
Montague would also index the pronoun and use a quantification rule
with the same index which would replace the pronoun with the
noun-phrase being quantified in.

Neither of these options are open to us since our syntax is defined in
terms of types of utterance situations and signs which relate
utterance situations to contents.  Our realistic strategy does not
allow for the use of additional imaginary utterance structures.  For this reason
we will adapt the kind of storage technique used in \cite{Cooper1983}.
In the original version of storage we moved from assigning a
single content to a syntactic structure to assigning a set of contents
in order to allow for the ambiguous interpretation of a single
syntactic structure.  In our sign-based approach using types the
corresponding move is not such a major change and the result yields a
theory involving underspecified content rather than a set of contents.

To see this consider the type \textit{Sign} introduced in
Chapter~\ref{ch:gram}.  Any object of type \textit{Sign} will be of
the type in \nexteg{}.
\begin{ex} 
\record{\tfield{s-event}{\textit{SEvent}} \\
         \tfield{syn}{\textit{Syn}} \\
        \tfield{cont}{\textit{Cont}}}  
\end{ex} 
The type in \preveg{} is completely underspecified.  Any sign will be
of this type.  We could specify it with respect to content by making
the `cont'-field be a manifest field as in \nexteg{}, where $\varphi$
is a particular content.
\begin{ex} 
\record{\tfield{s-event}{\textit{SEvent}} \\
         \tfield{syn}{\textit{Syn}} \\
        \mfield{cont}{$\varphi$}{\textit{Cont}}}  
 
\end{ex} 
Now recall that the manifest field
\smallrecord{\smallmfield{cont}{$\varphi$}{\textit{Cont}}} is just a
convenient way of writing
\smallrecord{\smalltfield{cont}{\textit{Cont}$_\varphi$}} where
\textit{Cont}$_\varphi$ is a singleton type whose only witness is $\varphi$.  It
is in this sense that the content has been specified to be $\varphi$.
Suppose now that we do not have enough information to fully specify
the content, that is, tie it down to be one particular content, but we
know that it has to be one of either $\varphi$ or $\psi$.  This could be represented by using a join type of two
singleton types, \textit{Cont}$_\varphi$$\vee$\textit{Cont}$_\psi$, as in
\nexteg{}.
\begin{ex} 
\record{\tfield{s-event}{\textit{SEvent}} \\
         \tfield{syn}{\textit{Syn}} \\
        \tfield{cont}{\textit{Cont}$_\varphi$$\vee$\textit{Cont}$_\psi$}}  
 
\label{ex:underspec-join}
   
\end{ex} 
\preveg{} is the type of signs whose contents are either $\varphi$ or $\psi$.
This is, then, a single type, which corresponds to an ``underspecified
content''.  Of course, the set of witnesses of the join type,
$\{\varphi,\psi\}$, corresponds to the set of contents that could be generated
by a storage algorithm.  Another way to achieve this is to use the
operator, $\mathfrak{T}$, introduced in (\ref{ex:mathfrakT}) on
p.~\pageref{ex:mathfrakT} which takes a set and returns a type whose
witnesses are exactly the members of the set.  We could thus use
\nexteg{} instead of \preveg{} with the same effect.
\begin{ex} 
\record{\tfield{s-event}{\textit{SEvent}} \\
         \tfield{syn}{\textit{Syn}} \\
        \tfield{cont}{$\mathfrak{T}(\{\varphi,\psi\})$}} 
\end{ex} 

Our strategy is to devise a way of
computing such types on the basis of compositional interpretation
without having to enumerate the members of the set of contents in the
way that we did in (\ref{ex:underspec-join}) and \preveg{}.
 
% Notice that saying that the content is of type
% \textit{Cont}$_c$$\vee$\textit{Cont}$_{c'}$, that is, that it is
% either $c$ or $c'$ is distinct from saying that the content is the
% disjunction of $c$ and $c'$, that is, if $c$ and $c'$ are types, the
% type $c\vee c'$.  The witnesses for $c\vee c'$ will be situations $s$
% such that either $s:c$ or $s:c'$ whereas the witness for
% \textit{Cont}$_c$$\vee$\textit{Cont}$_{c'}$ will be the contents $c$
% and $c'$.  This will make an important different in compositional
% interpretation.  For example, if a sentence $S$ has a content of type     
% \textit{Cont}$_c$$\vee$\textit{Cont}$_{c'}$ we would want to say that
% the sentence \textit{Sam believes $S$} has a content of type
% \textit{Cont}$_{believe(sam,c)}$$\vee$\textit{Cont}$_{believe(sam,c')}$
% rather than that it has the content `believe(sam,$c\vee c'$)'.

% In order to make the relationship between sets of contents and join
% types smoother we will use generalized join types
% (Appendix~\ref{app:jointypes}).  Suppose we have computed a set of
% possible contents, $\{c_1,\ldots,c_n\}$, for a phrase, then the type
% of the content for that phrase is
% $\bigvee\{\textit{Cont}_{c_1},\ldots,\textit{Cont}_{c_n}\}$.  If
% $\mathbb{C}$ represents the set of contents we have computed, we can
% use the more convenient notation
% $\displaystyle{\bigvee_{c\in\mathbb{C}}}\textit{Cont}_c$ to mean
% $\bigvee\{\textit{Cont}_c\mid c\in\mathbb{C}\}$.

We will exploit our treatment of context to include a store of
parametric quantifiers that are to be given a wide scope
interpretation.  Thus our characterization of the type \textit{Cntxt}
will be extended to \nexteg{}.
\begin{ex} 
  \record{
    \tfield{$\mathfrak{q}$}{\textit{QStore}}\\
    \tfield{$\mathfrak{s}$}{\textit{Assgnmnt}}\\
    \tfield{$\mathfrak{w}$}{\textit{Assgnmnt}}\\
    \tfield{$\mathfrak{g}$}{\textit{Assgnmnt}}\\
    \tfield{$\mathfrak{c}$}{\textit{PropCntxt}}}
\end{ex} 
\textit{QStore} is the type of assignments all of whose values are
parametric quantifiers, that is, as characterized in \nexteg{}.
\begin{ex} 
\textit{QStore} is a basic type.  $r:\textit{QStore}$ iff $r:Assgnmnt$
and for any $\text{x}_i\in\mathrm{labels}(r)$, $r.\text{x}_i:\textit{PQuant}$ 
\end{ex} 
An example of a witness for \textit{QStore} would thus be \nexteg{}
where we have stored the basic parametric content of \textit{every
  dog} under the label `x$_0$'.
\begin{ex} 
  \record{
    \field{x$_0$}{$\ulcorner\lambda c$:\textit{Cntxt} . $\lambda
      P$:\textit{Ppty} . \smallrecord{
      \smallmfield{restr}{dog$'$}{\textit{Ppty}}\\
      \smallmfield{scope}{$P$}{\textit{Ppty}}\\
      \smalltfield{e}{every(restr, scope)}}$\urcorner$}}
        
\end{ex} 
The record in \preveg{} is, among other types, of the type in
\nexteg{}, which will be the kind of type we will be using in our
content types which will be underspecified for quantifier scope.
\begin{ex} 
  \record{
    \footnotesize{\textit{QStore}}\\
    \mfield{x$_0$}{$\ulcorner\lambda c$:\textit{Cntxt} . $\lambda
      P$:\textit{Ppty} . \smallrecord{
      \smallmfield{restr}{dog$'$}{\textit{Ppty}}\\
      \smallmfield{scope}{$P$}{\textit{Ppty}}\\
      \smalltfield{e}{every(restr, scope)}}$\urcorner$}{\textit{PQuant}}}
        
\end{ex}
Suppose that the basic parametric content associated with a
noun-phrase is $\mathcal{Q}$, that is, the type of the content as we
have been expressing it so far (using a manifest field) will be
\textit{Cont}$_{\mathcal{Q}}$.  Now we want to generalize this type so
that not only $\mathcal{Q}$ will be a witness for the type but also a
parametric content where $\mathcal{Q}$ is required in the qstore of
the context.  This parametric quantifier will be \nexteg{}.
\begin{ex} 
  $\ulcorner\lambda c$:\smallrecord{
    \footnotesize{\textit{Cntxt}}\\
    \smalltfield{$\mathfrak{q}$}{\smallrecord{
        \smallmfield{x$_0$}{$\mathcal{Q}$}{\textit{PQuant}}}}\\
    \smalltfield{$\mathfrak{s}$}{\smallrecord{
        \smalltfield{x$_0$}{\textit{Ind}}}}} . $\lambda
  P$:\textit{Ppty} . $P\{c.\mathfrak{s}.\text{x}_0\}\urcorner$
\label{ex:stored-Q}        
\end{ex} 
Note that \preveg{} is exactly like the pronoun content introduced in
Chapter~\ref{ch:propnames}, example~(\ref{ex:he-leave-abbrev}), except that we have a parametric quantifier required in the
qstore labelled with the same label `x$_0$' as is used in the pronoun
content.  Thus this corresponds to the content of \textit{it}$^*$ in
(\ref{ex:it-star}) and (\ref{ex:edabhi}).  Note that \preveg{} is of
type \textit{PQuant}.  It is distinguished from a parametric
quantifier like \nexteg{}, however, in that it requires the qstore in
the context to be non-empty.
\begin{ex} 
$\ulcorner\lambda c$:\textit{Cntxt} . $\lambda
      P$:\textit{Ppty} . \smallrecord{
      \smallmfield{restr}{dog$'$}{\textit{Ppty}}\\
      \smallmfield{scope}{$P$}{\textit{Ppty}}\\
      \smalltfield{e}{every(restr, scope)}}$\urcorner$ 
\end{ex} 
Using terminology that goes back to
\cite{Bos1996}, we will say that \preveg{} is \textit{plugged} (that
is, in our terms, does not require anything to be in the qstore)
whereas (\ref{ex:stored-Q}) is \textit{unplugged} (that is, in our
terms, \textit{does} require something to be in the qstore).  The
intuition is that when a quantifier has been placed in the qstore it
has been unplugged from the main interpretation and needs to be
plugged back in at some point in order to get a fully specified
interpretation.  We formally characterize the notion \textit{plugged}
in \nexteg{}.
\begin{ex} 
A parametric content, $\alpha$, is \textit{unplugged} iff $c:\alpha$.bg implies $c.\mathfrak{q}\not=\emptyset$
(that is, $c.\mathfrak{q}$ is not the empty record).  Otherwise $\alpha$
is \textit{plugged}. 
\end{ex} 
  

We can derive (\ref{ex:stored-Q}) from $\mathcal{Q}$ by an operation
`$\mathrm{store}$' characterized in \nexteg{}.
\begin{ex}
If $\mathcal{Q}:\textit{PQuant}$ and $\mathcal{Q}$ is plugged, then
$\mathrm{store}(\mathcal{Q})$ is
\begin{quote}
  $\ulcorner\lambda c$:\smallrecord{
    \footnotesize{\textit{Cntxt}}\\
    \smalltfield{$\mathfrak{q}$}{\smallrecord{
        \smallmfield{x$_0$}{$\mathcal{Q}$}{\textit{PQuant}}}}\\
    \smalltfield{$\mathfrak{s}$}{\smallrecord{
        \smalltfield{x$_0$}{\textit{Ind}}}}} . $\lambda
  P$:\textit{Ppty} . $P\{c.\mathfrak{s}.\text{x}_0\}\urcorner$
\end{quote}

\end{ex} 
  

% The `unplugged'-field contains a set of unplugged
% interpretations consisting of a set of parametric quantifiers
% (possibly empty) and a core interpretation consisting of a parametric
% content.  Thus we define a type \textit{UInterp} of unplugged
% interpretations as in \nexteg{}.
% \begin{ex} 
% \textit{UInterp} = \record{\tfield{quants}{\{\textit{PQuant}\}}\\
%                            \tfield{core}{\textit{PCont}}}
% \end{ex} 
% The `cont'-field in a sign will now be required to be of the type in
% \nexteg{}.
% \begin{ex} 
% \record{\tfield{unplugged}{\{\textit{UInterp}\}}\\
%         \tfield{plugged}{$\displaystyle{\bigvee_{c\in\mathrm{unplugged},\
%               c.\mathrm{quants}=\emptyset}\textit{Cont}_{c.\mathrm{core}}}$}}
% \end{ex} 
% That is, the `unplugged'-field in the content will contain a set of
% unplugged interpretations (consisting of a quantifier store, possibly empty, and a core
% interpretation) and the `plugged'-field will contain one of the cores
% of those unplugged interpretations whose quantifier store is
% empty.

% Let us consider what this will look like for the example \textit{every
%   boy wants a dog} using \textit{every}$'$, \textit{boy}$'$ etc. as
% abbreviations for non-parametric contents for these words.  We show
% the `cont'-field of the sign type associated with constituents of this
% sentence.
% \begin{ex} 
% \begin{subex} 
 
% \item a dog 
 
% \item
%   \smallrecord{\smallmfield{unplugged}{\{\smallrecord{\field{quants}{$\emptyset$}\\
%                                             \field{core}{\smallrecord{\field{bg}{\textit{Rec}}\\
%                                                                       \field{fg}{$\lambda\mathfrak{s}$:\textit{Rec}
%                                                                         . \textit{a}$'$(\textit{dog}$'$)}}}}, \\
%    \hspace*{5em}                            \smallrecord{\field{quants}{\{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}} \\
%                                                                           \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%                                                                             . \textit{a}$'$(\textit{dog}$'$)}}\}} \\
%                                             \field{core}{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}}
%                                                 \\
%                                                                       \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%                                                                         . $\lambda
%                                                                         P$:\textit{Ppty}
%                                                                         . $P(\mathfrak{s}.\textrm{x}_0)$}}}}\}} {\{\textit{UInterp}\}}
%                                                             \\
%           \smalltfield{plugged}{\textit{Cont}$_{\text{\smallrecord{\field{bg}{\textit{Rec}}\\
%                                                                       \field{fg}{$\lambda\mathfrak{s}$:\textit{Rec}
%                                                                         . \textit{a}$'$(\textit{dog}$'$)}}}}$}}
 
% \end{subex} 
   
% \end{ex} 
% \begin{ex} 
% \begin{subex} 
 
% \item want a dog 
 
% \item
%   \smallrecord{\smallmfield{unplugged}{\{\smallrecord{\field{quants}{$\emptyset$}\\
%                                             \field{core}{\smallrecord{\field{bg}{\textit{Rec}}\\
%                                                                       \field{fg}{$\lambda\mathfrak{s}$:\textit{Rec}
%                                                                         . \textit{want}$'$(\textit{a}$'$(\textit{dog}$'$))}}}}, \\
%    \hspace*{5em}                            \smallrecord{\field{quants}{\{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}} \\
%                                                                           \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%                                                                             . \textit{a}$'$(\textit{dog}$'$)}}\}} \\
%                                             \field{core}{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}}
%                                                 \\
%                                                                       \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%                                                                         . \textit{want}$'$($\lambda
%                                                                         P$:\textit{Ppty}
%                                                                         . $P(\mathfrak{s}.\textrm{x}_0)$)}}}}\}} {\{\textit{UInterp}\}}
%                                                             \\
%           \smalltfield{plugged}{\textit{Cont}$_{\text{\smallrecord{\field{bg}{\textit{Rec}}\\
%                                                                       \field{fg}{$\lambda\mathfrak{s}$:\textit{Rec}
%                                                                         . \textit{want}(\textit{a}$'$(\textit{dog}$'$))}}}}$}}
 
% \end{subex} 
   
% \end{ex} 

% \begin{ex} 
% \begin{subex} 
 
% \item every boy 
 
% \item
%   \smallrecord{\smallmfield{unplugged}{\{\smallrecord{\field{quants}{$\emptyset$}\\
%                                             \field{core}{\smallrecord{\field{bg}{\textit{Rec}}\\
%                                                                       \field{fg}{$\lambda\mathfrak{s}$:\textit{Rec}
%                                                                         . \textit{every}$'$(\textit{boy}$'$)}}}}, \\
%    \hspace*{5em}                            \smallrecord{\field{quants}{\{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}} \\
%                                                                           \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%                                                                             . \textit{every}$'$(\textit{boy}$'$)}}\}} \\
%                                             \field{core}{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}}
%                                                 \\
%                                                                       \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%                                                                         . $\lambda
%                                                                         P$:\textit{Ppty}
%                                                                         . $P(\mathfrak{s}.\textrm{x}_0)$}}}}\}} {\{\textit{UInterp}\}}
%                                                             \\
%           \smalltfield{plugged}{\textit{Cont}$_{\text{\smallrecord{\field{bg}{\textit{Rec}}\\
%                                                                       \field{fg}{$\lambda\mathfrak{s}$:\textit{Rec}
%                                                                         . \textit{every}$'$(\textit{boy}$'$)}}}}$}}
 
% \end{subex} 
   
% \end{ex} 
    
% \begin{ex} 
% \begin{subex} 
 
% \item every boy wants a dog 
 
% \item
% % \newsavebox{\test}
% % \sbox\test{\begin{tabular}{l}a,\\b\end{tabular}}
% % \usebox{\test}

% % \newsavebox{\unplugged}
% % \sbox\unplugged{$\left\{ \text{\begin{tabular}{l}\usebox{\unpluggeda},\\
% %                                     \usebox{\unpluggedb},\\
% %                                     \usebox{\unpluggedc},\\
% %                                     \usebox{\unpluggedd},\\
% %                                     \usebox{\unpluggede},\\
% %                                     \usebox{\unpluggedf},\\
% %                                     \usebox{\unpluggedg}
% %                   \end{tabular}}\right\}$}

% \newsavebox{\plugged}
% \sbox\plugged{$\displaystyle{\bigvee_{c\in\mathbb{C}_{\mathrm{plugged}}}\textit{Cont}_c}$}
                              

% \smallrecord{\smallmfield{unplugged}{$\mathbb{C}_{\mathrm{unplugged}}$}{\{\textit{UInterp}\}}\\
%              \smalltfield{plugged}{\usebox{\plugged}}}

 
% \end{subex} 
   
% \end{ex} 
% where $\mathbb{C}_{\mathrm{unplugged}}$ is the set whose members are
% listed in \nexteg{} and $\mathbb{C}_{\mathrm{plugged}}$ is the set
% whose members are listed in (\ref{ex:plugged}).
% \newsavebox{\unpluggeda}
% \sbox\unpluggeda{\smallrecord{\field{quants}{$\emptyset$}\\
%                                                        \field{core}{\smallrecord{\field{bg}{\textit{Rec}}\\
%                                                                                  \field{fg}{$\lambda\mathfrak{s}$:\textit{Rec}
%                                                                          . \textit{every}$'$(\textit{boy}$'$)(\textit{want}$'$(\textit{a}$'$(\textit{dog}$'$)))}}}}}

% \newsavebox{\unpluggedb}
% \sbox\unpluggedb{\smallrecord{\field{quants}{\{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}} \\
%                                                                            \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%                                                                             . \textit{every}$'$(\textit{boy}$'$)}}\}} \\
%                                             \field{core}{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}}
%                                                 \\
%                                                                       \field{fg}{\begin{tabular}{l}$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%                                                                         . \\
%                                                                                    \hspace*{1em}$\lambda
%                                                                         P$:\textit{Ppty}
%                                                                         . \\
%                                                                                    \hspace*{2em}$P(\mathfrak{s}.\textrm{x}_0)$(\textit{want}$'$(\textit{a}$'$(\textit{dog}$'$)))\end{tabular}}}}}}

% \newsavebox{\unpluggedc}
% \sbox\unpluggedc{\smallrecord{\field{quants}{\{\begin{tabular}{l}\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}} \\
%                                                                           \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%                                                                             . \textit{every}$'$(\textit{boy}$'$)}}, \\
%                                                                         \smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}} \\
%                                                                           \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
%                                                                             . \textit{a}$'$(\textit{dog}$'$)}}\end{tabular}\}} \\
%                                             \field{core}{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}\\
%                                                                                               \smalltfield{x$_1$}{\textit{Ind}}}}
%                                                 \\
%                                                                       \field{fg}{\begin{tabular}{l}$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}} \\
%                                                                                                                 \smalltfield{x$_1$}{\textit{Ind}}}
%                                                                         . \\
%                                                                                                        \hspace*{1em}$\lambda
%                                                                         P$:\textit{Ppty}
%                                                                         . \\
%                                                                                    \hspace*{2em}$P(\mathfrak{s}.\textrm{x}_0)$(\textit{want}$'$($\lambda
%                                                                                    P$:\textit{Ppty}
%                                                                                    .
%                                                                                    $P(\mathfrak{s}.\textrm{x}_1)$))\end{tabular}}}}}}

% \newsavebox{\unpluggedd}
% \sbox\unpluggedd{\smallrecord{\field{quants}{\{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}} \\
%                                                                           \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
%                                                                             . \textit{a}$'$(\textit{dog}$'$)}}\}} \\
%                                             \field{core}{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}}
%                                                 \\
%                                                                       \field{fg}{\begin{tabular}{l}$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
%                                                                         . \\
%                                                                                    \hspace*{1em}\textit{every}$'$(\textit{boy}$'$) \\ 
% \hspace*{2em}($\lambda
%    r$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}} . \\
%    \hspace*{3em}$\lambda P$:\textit{Ppty} .  $P$($r$.x$_0$)\\
%                                                                                    \hspace*{4em}(\textit{want}$'$\\ \hspace*{5em}($\lambda
%                                                                         P$:\textit{Ppty}
%                                                                         .
                                                                                
% $P(\mathfrak{s}.\textrm{x}_1)$)))\end{tabular}}}}}}

% \newsavebox{\unpluggede}
% \sbox\unpluggede{\smallrecord{\field{quants}{\{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}} \\
%                                                                           \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%                                                                             . \textit{every}$'$(\textit{boy}$'$)}}\}} \\
%                                             \field{core}{\smallrecord{\field{bg}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}}
%                                                 \\
%                                                                       \field{fg}{\begin{tabular}{l}$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%                                                                         . \\
%                                                                                    \hspace*{1em}\textit{a}$'$(\textit{dog}$'$)\\
%                                                                                    \hspace*{2em}($\lambda
%                                                                         r$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
%                                                                           . \\
%                                                                                    \hspace*{3em}$\lambda
%                                                                           P$:\textit{Ppty}
%                                                                           . \\
%                                                                                    \hspace*{4em}$P$($r$.x$_1$)\\
%                                                                                    \hspace*{5em}(\textit{want}$'$($\lambda
%                                                                         P$:\textit{Ppty}
%                                                                         . $P(\mathfrak{s}.\textrm{x}_0)$))})\end{tabular}}}}}

% \newsavebox{\unpluggedf}
% \sbox\unpluggedf{\smallrecord{\field{quants}{\{\}}\\
%                               \field{core}{\smallrecord{\field{bg}{\textit{Rec}}\\
%                                                         \field{fg}{\begin{tabular}{l}
%                                                                     $\lambda\mathfrak{s}$:\textit{Rec}
%                                                                      \\
%                                                                     \hspace*{1em}\textit{a}$'$(\textit{dog}$'$)
%                                                                       \\
%                                                                     \hspace*{2em}($\lambda
%                                                                      r_1$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
%                                                                      . \\
%                                                                     \hspace*{3em}\textit{every}$'$(\textit{boy}$'$)\\
%                                                                     \hspace*{4em}($\lambda
%                                                                      r_2$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%                                                                      . \\
%                                                                     \hspace*{5em}$\lambda
%                                                                      P$:\textit{Ppty}
%                                                                      . $P$($r_1$.x$_0$)\\
%                                                                     \hspace*{6em}\textit{wants}$'$($\lambda
%                                                                      P$:\textit{Ppty}
%                                                                      . $P$($r_1$.x$_1$))))\end{tabular}}}}}}

% \newsavebox{\unpluggedg}
% \sbox\unpluggedg{\smallrecord{\field{quants}{\{\}}\\
%                               \field{core}{\smallrecord{\field{bg}{\textit{Rec}}\\
%                                                         \field{fg}{\begin{tabular}{l}
%                                                                     $\lambda\mathfrak{s}$:\textit{Rec}
%                                                                      \\
%                                                                     \hspace*{1em}\textit{every}$'$(\textit{boy}$'$)
%                                                                       \\
%                                                                     \hspace*{2em}($\lambda
%                                                                      r_1$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%                                                                      . \\
%                                                                     \hspace*{3em}\textit{a}$'$(\textit{dog}$'$)\\
%                                                                     \hspace*{4em}($\lambda
%                                                                      r_2$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
%                                                                      . \\
%                                                                     \hspace*{5em}$\lambda
%                                                                      P$:\textit{Ppty}
%                                                                      . $P$($r_1$.x$_0$)\\
%                                                                     \hspace*{6em}\textit{wants}$'$($\lambda
%                                                                      P$:\textit{Ppty}
%                                                                      . $P$($r_1$.x$_1$))))\end{tabular}}}}}}



% \begin{ex} 
% \begin{subex} 
 
% \item \usebox{\unpluggeda} 
 
% \item \usebox{\unpluggedb}

% \item \usebox{\unpluggedc}

% \item \usebox{\unpluggedd}

% \item \usebox{\unpluggede}

% \item \usebox{\unpluggedf}

% \item \usebox{\unpluggedg} 
 
% \end{subex} 
   
% \end{ex} 

% \begin{ex} 
% \begin{subex} 
 
% \item \smallrecord{\field{bg}{\textit{Rec}}\\
%                    \field{fg}{$\lambda\mathfrak{s}$:\textit{Rec} . \textit{every}$'$(\textit{boy}$'$)(\textit{want}$'$(\textit{a}$'$(\textit{dog}$'$)))}}
                               
% \item  \smallrecord{\field{bg}{\textit{Rec}}\\
%                     \field{fg}{\begin{tabular}{l}
%                                     $\lambda\mathfrak{s}$:\textit{Rec}
%                                                                      \\
%                                       \hspace*{1em}\textit{a}$'$(\textit{dog}$'$)
%                                                                       \\
%                                       \hspace*{2em}($\lambda
%                                                            r_1$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
%                                                                      . \\
%                                       \hspace*{3em}\textit{every}$'$(\textit{boy}$'$)\\
%                                       \hspace*{4em}($\lambda
%                                                           r_2$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%                                                                      . \\
%                                       \hspace*{5em}$\lambda
%                                                         P$:\textit{Ppty}
%                                                                      . $P$($r_1$.x$_0$)\\
%                                        \hspace*{6em}\textit{wants}$'$($\lambda
%                                                                      P$:\textit{Ppty}
%                                                                      . $P$($r_1$.x$_1$))))\end{tabular}}}
 
% \item  \smallrecord{\field{bg}{\textit{Rec}}\\
%                                                         \field{fg}{\begin{tabular}{l}
%                                                                     $\lambda\mathfrak{s}$:\textit{Rec}
%                                                                      \\
%                                                                     \hspace*{1em}\textit{every}$'$(\textit{boy}$'$)
%                                                                       \\
%                                                                     \hspace*{2em}($\lambda
%                                                                      r_1$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%                                                                      . \\
%                                                                     \hspace*{3em}\textit{a}$'$(\textit{dog}$'$)\\
%                                                                     \hspace*{4em}($\lambda
%                                                                      r_2$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
%                                                                      . \\
%                                                                     \hspace*{5em}$\lambda
%                                                                      P$:\textit{Ppty}
%                                                                      . $P$($r_1$.x$_0$)\\
%                                                                     \hspace*{6em}\textit{wants}$'$($\lambda
%                                                                      P$:\textit{Ppty}
%                                                                      . $P$($r_1$.x$_1$))))\end{tabular}}}
 
% \end{subex} 
% \label{ex:plugged}   
% \end{ex} 
  
% We now take a look at what is needed in order achieve the analysis we
% have discussed above.  We will express storage and retrieval as
% constraints on linguistically allowable sign types.  As a preliminary
% we will define a bookkeeping function, max$_x$, which enables us to determine
% the maximum $i$ such that `x$_i$' is used as a label in a set of
% records, $R$.  This will enable us to store quantifiers using labels
% `x$_0$', `x$_1$' and so on in order as in the examples discussed
% above. `max$_x$' is defined as in \nexteg{} where $R$ is an arbitrary
% set of records.
% \begin{ex} 
% max$_x$($R$) = 
% \begin{quote}
% max($\{i\mid\exists r\in R\ \exists v\ \langle \mathrm{x}_i,v\rangle\in r.\mathrm{bg}\}$), if
% defined

% otherwise: -1 
% \end{quote}
% \end{ex}
% That is, max$_x$($R$) is the maximum $i$ such that `x$_i$' is a label
% in the `bg'-field of one of the records in $R$.  If there is no such label max$_x$($R$)
% returns -1. Thus in adding to a quantifier store, $R$, (as in the
% `quants'-fields in the examples above) we will always add a new
% quantifier indexed by max$_x$($R$)+1.  For brevity we will denote this by
% incr$_x$($R$), that is, the result of incrementing the maximal x in $R$. 

% It will also be useful to define an operation that adds a field
% \smallrecord{\field{$\ell$}{$v$}} to a record $r$ if there is no field
% with the label $\ell$ or replaces the $\ell$-field in $r$ with
% \smallrecord{\field{$\ell$}{$v$}}.  We will represent the new record
% thus derived as $r\oplus$\smallrecord{\field{$\ell$}{$v$}}.  This
% is defined in \nexteg{}.
% \begin{ex} 
% $r\oplus$\smallrecord{\field{$\ell$}{$v$}} is \\
% \hspace*{1em}$r\cup\{\langle\ell,v\rangle\}$, if there is no $v'$ such
% that $\langle\ell,v'\rangle\in\mathfrak{s}$\\
% \hspace*{1em}$(r-\{\langle\ell,r.l\rangle\})\cup\{\langle\ell,v\rangle\}$, otherwise 
% \end{ex} 
% Similarly we define $T\ominus$\smallrecord{\smalltfield{$\ell$}{$v$}}
% for record types, $T$, in
% \nexteg{}.
% \begin{ex} 
% $T\ominus$\smallrecord{\smalltfield{$\ell$}{$v$}} is \\ 
% \hspace*{1em}$T-\{\langle\ell,v\rangle\}$ 
% \end{ex} 
% Note that this version of subtraction for record types will only
% result in a well-formed record type if there are not fields in $T$
% which depend on $\ell$.  In order to rectify this we need to make
% $T\ominus$\smallrecord{\smalltfield{$\ell$}{$v$}} remove in addition
% all fields which depend on $\ell$.  A field, $f$, is dependent on $\ell$
% just in case it is of the form
% $\langle\ell',\langle\mathcal{F},\pi\rangle\rangle$ where $\pi$ is a
% sequence of paths containing $\ell$. Therefore we can refine the
% definition in \preveg{} as that in \nexteg{}.
% \begin{ex} 
% $T\ominus$\smallrecord{\smalltfield{$\ell$}{$v$}} is \\ 
% \hspace*{1em}$T-(\{\langle\ell,v\rangle\}\cup\{f\in T\mid f\
% \text{dependent on}\ \ell\})$ 
% \end{ex} 
% This is technically not enough, since there may still be fields left
% which are dependent on the dependent fields we have removed.
% Therefore we need to make the definition recursive as in \nexteg{}.
% \begin{ex} 
% $T\ominus$\smallrecord{\smalltfield{$\ell$}{$v$}} is \\ 
% \hspace*{1em}$(\ldots(T-\{\langle\ell,v\rangle\}\ominus
% f_0)\ldots)\ominus f_n$ where $\{f_0,\ldots,f_n\}$ is $\{f\in T\mid f\
% \text{dependent on}\ \ell\}$ 
% \end{ex}   

% [Is this enough to cover paths which contain $\ell$?]

% We will also for convenience use the notation $T\ominus\ell$ to mean
% $T\ominus[\ell:v]$ if $\langle\ell,v\rangle\in T$ or $T$ if there is
% no field labelled $\ell$ in $T$.

% We can now define storage as in
% \nexteg{}, where $\sigma$ is an arbitrary sign.
% \begin{ex} 
% \textbf{Storage}

% If $\alpha\in\sigma$.cont.unplugged, $\alpha$.core : \textit{PQuant}
% and \\ $\alpha$.core.fg $\not=$
% $\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_i$}{\textit{Ind}}}
%   . $\lambda P$:\textit{Ppty} . $P$($\mathfrak{s}$.x$_i$) for any $i$, \\then

% \hspace*{1em}\record{\field{quants}{$\alpha$.quants $\cup$ \{
%                               \record{\field{bg}{\smallrecord{\smalltfield{x$_{\mathrm{incr}_x(\alpha.\mathrm{quants})}$}{\textit{Ind}}}}\\
%         \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_{\mathrm{incr}_x(\alpha.\mathrm{quants})}$}{\textit{Ind}}}
%           . $\alpha$.core.fg($\mathfrak{s}$)}}\}}\\
% \field{core}{\record{\field{bg}{\smallrecord{\smalltfield{x$_{\mathrm{incr}_x(\alpha.\mathrm{quants})}$}{\textit{Ind}}}}\\
%                      \field{fg}{$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_{\mathrm{incr}_x(\alpha.\mathrm{quants})}$}{\textit{Ind}}}
%                        . $\lambda P$:\textit{Ppty}
%                        . $P$($\mathfrak{s}$.x$_{\mathrm{incr}_x(\alpha.\mathrm{quants})}$)}}}}

% \hspace*{4em}$\in$ $\sigma$.cont.unplugged
                                 
% \end{ex} 
% If $\sigma$ is a sign, $\sigma$.cont.unplugged is a set of unplugged interpretations.
% \preveg{} says that if any
% of those is a noun-phrase interpretation, that is, its core is of type
% \textit{PQuant}, and is not the result of applying storage, that is,
% the foreground of its core is not an interpretation depending on a
% context, $\mathfrak{s}$, as introduced by storage, then
% $\sigma$.cont.unplugged also contains an unplugged interpretation
% where the core has been stored. 

We will now turn our attention to retrieval which removes a quantifier
from the qstore and quantifies over the virtual pronoun created by
storage.


\begin{shaded}
In order to do this we need to generalize our
characterization of `$\ominus$' in (\ref{ex:ominus}) to include
\textit{QStore} as a special case exactly similar to
\textit{Assgnmnt}.  This is done in \nexteg{}.
\begin{ex} 
  \begin{enumerate}
    
  \item If $T$ is a record type and
    $\{\pi_1,\ldots,\pi_n\}\subset\mathrm{paths}(T)$, then
    $T\ominus\pi_1,\ldots,\pi_n$ is $T\ominus\pi_1\ldots\ominus\pi_n$
 
\item If $T$ is a record type, $\pi\in\mathrm{paths}(T)$ and
  $\mathrm{paths}_\pi(T)=\{\pi,\pi_1,\ldots,\pi_n\}$, then
  \begin{quote}
    we normally write $T\ominus\pi$ for
    $T\ominus\pi,\pi_1,\ldots,\pi_n$
  \end{quote}
  
 
\item If $T$ is $\textit{Assgnmnt}\wedge T'$ and
  $\ell\in\mathrm{labels}(T')$, then
  \begin{enumerate} 
    
  \item if $\mathrm{labels}(T')=\{\ell\}$, $T\ominus\ell=\textit{Assgnmnt}$ 
    
  \item otherwise, $T\ominus\ell=\textit{Assgnmnt}\wedge (T'-\{\langle\ell,T'.\ell\rangle\})$ 
    
  \end{enumerate}

\item If $T$ is $\textit{QStore}\wedge T'$ and
  $\ell\in\mathrm{labels}(T')$, then
  \begin{enumerate} 
    
  \item if $\mathrm{labels}(T')=\{\ell\}$, $T\ominus\ell=\textit{QStore}$ 
    
  \item otherwise, $T\ominus\ell=\textit{QStore}\wedge (T'-\{\langle\ell,T'.\ell\rangle\})$ 
    
  \end{enumerate}
  
\item If $T$ is $\textit{PropCntxt}\wedge T'$ and
  $\ell\in\mathrm{labels}(T')$, then
  \begin{enumerate} 
    
  \item if $\mathrm{labels}(T')=\{\ell\}$, $T\ominus\ell=\textit{PropCntxt}$
    
  \item otherwise, $T\ominus\ell=\textit{PropCntxt}\wedge(T'-\{\langle\ell,T'.\ell\rangle\})$ 
    
  \end{enumerate} 

\item If $T$ is $\textit{PropCntxt}\wedge T'$ and
  $\ell.\pi\in\mathrm{tpaths}(T')$ then
  \begin{quote}
    $T\ominus\ell.\pi=\textit{PropCntxt}\wedge T'$\fbox{\d{$\wedge$}}\smallrecord{
      \smalltfield{$\ell$}{$T'.\ell\ominus\pi$}}
  \end{quote}

\item Otherwise, if $T$ is a labelled set, then
  \begin{enumerate}
  \item if $\ell.\pi\in\mathrm{tpaths}(T)$, $T\ominus\ell.\pi=T'$\fbox{\d{$\wedge$}}\smallrecord{
      \smalltfield{$\ell$}{$T.\ell\ominus\pi$}}
  \item otherwise, $T\ominus\pi$ is $T$
  \end{enumerate}

  
 
\end{enumerate} 
\label{ex:ominus-with-qstore}   
\end{ex}

\end{shaded}

We now characterize retrieval in a version corresponding to
quantification with scope over sentences.  In a more complete
treatment we would at least add quantification with scope over verb phrases
and common nouns corresponding to Montague's (\citeyear{Montague1973})
treatment.  In \nexteg{}, we characterize an operation
`$\mathrm{retrieve}$' which maps a parametric record type with a
quantifier in store to one where the quantifier is removed from the
store and given scope over the non-parametric content.

\begin{ex} 
% \textbf{Retrieval (S)} 

% If $\alpha\in\sigma$.cont.unplugged, for some $i$,
% $\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_i$}{\textit{Ind}}}
% . $Q$ $\in$ $\alpha$.quants and $\alpha$.core : ($T$ $\rightarrow$
% \textit{Type}), where $T$ $\sqsubseteq$
% \smallrecord{\smalltfield{x$_i$}{\textit{Ind}}}, then \\

% \hspace*{1em}\record{\field{quants}{$\alpha$.quants $-$
%     $\{\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_i$}{\textit{Ind}}}
%     . $Q\}$} \\
%         \field{core}{$\lambda\mathfrak{s}$:$T-$\{\smallrecord{\smalltfield{x$_i$}{\textit{Ind}}}\}
%           . $Q$($\lambda
%           r$:\smallrecord{\smalltfield{x$_i$}{\textit{Ind}}}
%           . $\alpha$.core($\mathfrak{s}\oplus$\smallrecord{\field{x$_i$}{$r$.x$_i$}}))}}

%           \hspace*{4em}$\in$ $\sigma$.cont.unplugged

  If $\alpha:\textit{PRecType}$, $\mathcal{Q}:\textit{PQuant}$ and
  $\alpha.\text{bg}\sqsubseteq$ \smallrecord{
    \tfield{$\mathfrak{q}$}{\smallrecord{
          \smallmfield{x$_i$}{$\mathcal{Q}$}{\textit{Ind}}}}}, then
  $\mathrm{retrieve}(\text{x}_i,\alpha)$ is
  \begin{quote}
    $\lambda
    c$:$([\mathcal{Q}.\text{bg}]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{f}}$\d{$\wedge$}$\mathrm{incr}_{\mathfrak{q}.\text{x},\mathfrak{s}.\text{x},\mathfrak{w}.\text{x},\mathfrak{g}.\text{x}}([\alpha.\text{bg}\ominus\mathfrak{q}.\text{x}_i,\mathfrak{s}.\text{x}_i]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{a}},\mathcal{Q}.\text{bg}))$
    . \\ \hspace*{2em}$\mathcal{Q}(\mathfrak{P}(\ulcorner\lambda
    r$:\smallrecord{
      \smalltfield{x}{\textit{Ind}}\\
      \smalltfield{$\mathfrak{s}$}{\smallrecord{
          \smallmfield{x$_i$}{$\Uparrow$x}{\textit{Ind}}}}}\d{$\wedge$}$\alpha.\text{bg}^{\mathfrak{q}.\text{x}_i,\mathfrak{s}.\text{x}_i}$
    . $\alpha(c[r])\urcorner))$
  \end{quote}
  
\end{ex} 
% \preveg{} says that if any of the unplugged interpretations in a sign
% contains a quantifier indexed by $i$, that is, it is a parametric
% quantifier whose domain type is
% \smallrecord{\smalltfield{x$_i$}{\textit{Ind}}}, and the core of this
% unplugged interpretation is a function from contexts to a type, that
% is, it corresponds to a (declarative) sentence interpretation, where
% the context is required to provide a value for `x$_i$', that is, the
% domain type is a subtype of
% \smallrecord{\smalltfield{x$_i$}{\textit{Ind}}},\footnote{Note that
%   this requirement will prevent the kind of vacuous binding that
%   Keller storage \citep{Keller1988} avoided.} then the quantifier is
% removed from the store and given scope over the sentence
% interpretation in the core binding `x$_i$'.  The dependence on `x$_i$'
% in the context is removed from the core interpretation.

`$\mathrm{retrieve}$' applies to a label, `x$_i$' and a parametric
record type, $\alpha$, which contains a parametric quantifier,
$\mathcal{Q}$, in its qstore labelled by `x$_i$'.  It returns a
parametric record type where the context type is an appropriate
combination of the context types (labelled `bg') associated with
$\mathcal{Q}$ and $\alpha$ including path adjustment and
incrementation but with fields labelled `$\mathfrak{q}.\text{x}_i$'
and `$\mathfrak{s}.\text{x}_i$' removed together with any fields
depending on them.  The fields that are removed are added to the
domain type of the property to which $\mathcal{Q}$ is applied and
purification ($\mathfrak{P}$) is applied to the property so that the
additional fields are ``moved down'' into $\alpha$ giving the effect
of what in Discourse Representation Theory would be called local
accommodation of any presuppositions \citep{VanderSandt1992}.  This
means that any presuppositions associated with the quantifier will
apply at the level at which it is quantified in.

Now we have two ways, storage and retrieval, in which we can derive parametric contents from
other parametric contents.  How can we, then, characterize the type of
parametric contents associated with some particular phrase?  We will introduce a type \textit{ContType}
characterized in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item \textit{ContType}, ``the type of types of contents'', is a basic type 
 
\item $T:\textit{ContType}$ iff $T\sqsubseteq\textit{Cont}$ 
 
\end{subex} 
   
\end{ex}
Suppose
that $T:\textit{ContType}$.  Then we define a new type
$\mathfrak{S}(T)$ whose witnesses are the closure of the set of
witnesses of $T$ under `$\mathrm{store}$' and `$\mathrm{retrieve}$'.
We give a precise characterization of this in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item If $T:\textit{ContType}$, then $\mathfrak{S}(T)$ is a type 
 
\item The witnesses of $\mathfrak{S}(T)$ are characterized by
  \begin{enumerate} 
 
  \item if $\varphi:T$ then $\varphi:\mathfrak{S}(T)$ 
 
  \item if $\varphi:T$ and $\varphi$ is in the range of `$\mathrm{storage}$', then
    $\mathrm{storage}(\varphi):\mathfrak{S}(T)$

  \item if $\varphi:T$ and `x$_i$' and $\varphi$ are appropriate
    arguments to `$\mathrm{retrieve}$', then
    $\mathrm{retrieve}(\text{x}_i,\varphi):\mathfrak{S}(T)$
    
  \item nothing is a witness for $\mathfrak{S}(T)$ except as required above.
 
  \end{enumerate} 
  
 
\end{subex} 
\label{ex:storage-type}   
\end{ex}

If $\varphi$ is a parametric content, that is,
$\varphi:\textit{Cont}$, we use the notation $\varphi^{\mathfrak{S}}$
to represent $\mathfrak{S}(\textit{Cont}_{\varphi})$, that is, the type
whose witnesses are the closure of $\{\varphi\}$ under
`$\mathrm{store}$' and `$\mathrm{retrieve}$'.

How should such types of parametric contents be combined in
compositional semantics? First, the value in the `cont'-field in a
sign will now not be a parametric content as previously but a type of
parametric contents, that is, it will be of type \textit{ContType}.
Thus we redefine the type \textit{Sign} as in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item \textit{Sign}, ``the type of signs'', is a basic type 
 
\item $\sigma$ : \textit{Sign} iff $\sigma$ :
      \record{\tfield{s-event}{\textit{SEvent}} \\
         \tfield{syn}{\textit{Syn}} \\
        \tfield{cont}{\textit{ContType}}}  
 
\end{subex} 
   
\end{ex} 
  
  
Suppose that $T_1$ and
$T_2$ are of type \textit{ContType} and that $\mathcal{O}$ is a combination
operation such as @, @@, @$_{\text{wh}_{i,j}}$, then we say $T_1\mathcal{O}^{\mathfrak{S}}T_2$
is also a type with the witness condition in \nexteg{}.
\begin{ex} 
If $\alpha:T_1$, $\beta:T_2$ and $\alpha\mathcal{O}\beta$ is defined,
then $\alpha\mathcal{O}\beta:T_1\mathcal{O}^{\mathfrak{S}}T_2$.
Nothing else is a witness for $T_1\mathcal{O}^{\mathfrak{S}}T_2$. 
\end{ex} 
What we need then for the type of parametric contents for the combined
constituents is
$\mathfrak{S}(T_1\mathcal{O}^{\mathfrak{S}}T_2)$, that
is, the type of the closure of the set of all combinations under
`$\mathrm{store}$' and `$\mathrm{retrieve}$'.  Note that \preveg{} has
the consequence that if `$\alpha\mathcal{O}\beta$' is undefined for all
witnesses, $\alpha$ and $\beta$ of $T_1$ and $T_2$ respectively we
will still obtain a result for $T_1\mathcal{O}^{\mathfrak{S}}T_2$, albeit a
type which has no witnesses.  This will mean that we do not have to be
as careful in keeping track of typing when interpreting syntactic
constructions, though with the consequence that some phrases will not
have any content.

In \nexteg{} we introduce versions of `ContForwardApp' operations which
apply at the content type level.
\begin{ex} 
If $\mathcal{O}$ is one of @, @@, @$_{\text{wh}_{i,j}}$ (for some
natural numbers $i$ and $j$) or @$_{\&}$, then
ContForwardApp$_{\mathfrak{S},\mathcal{O}}$ is
\begin{quote}
  $\lambda u$:\smallrecord{
    \smalltfield{cont}{\textit{ContType}}}$^\frown$\smallrecord{
    \smalltfield{cont}{\textit{ContType}}} . \smallrecord{
    \smalltfield{cont}{$\mathfrak{S}(u[0].\text{cont}\mathcal{O}^{\mathfrak{S}}u[1].\text{cont})$}}
\end{quote}

\end{ex} 
Note that we now no longer have to keep track of the arguments to
ContForwardApp that we had in some of the variants since the
combination of the types will always return a result, though if the
types of contents do not match for the particular combination
operation the combined type will have no witnesses.  This means that
we can simplify our notation for constituent structure rules as in
\nexteg{}.
\begin{ex} 
If $T_{\text{mother}}$, $T_{\text{daughter}_1}$ and
  $T_{\text{daughter}_2}$ are sign types and $\mathcal{O}$ is a
  combination operation, then
  \begin{quote}
    $T_{\text{mother}}\longrightarrow
    T_{\text{daughter}_1}\ T_{\text{daughter}_2}\ \mid\
    T_{\text{daughter}_1}'(_{\mathcal{O}}T_{\text{daughter}_2}')$
  \end{quote}
  is
  \begin{quote}
  $T_{\text{mother}}\longrightarrow
    T_{\text{daughter}_1}\ T_{\text{daughter}_2}$ \d{\d{$\wedge$}}
    ContForwardApp$_{\mathfrak{S},\mathcal{O}}$
  \end{quote}
  
\end{ex} 
  
  
% @@

% Finally, we show one way in which stored quantifiers can be
% ``percolated'' to higher constituents by showing in \nexteg{} how to
% construct an unplugged content from two constituent unplugged contents
% when the basic semantic composition involves function application.  To
% facilitate this we first define the `x'-incrementation of an object
% (such as a set or a function) with respect to a set of records $R$.

% \begin{ex} 
% The `x'\textit{-incrementation of an object $O$ with respect
%   to a set of records $R$}, $[O]_{\mathrm{incr}_x(R)}$, is the result of
% replacing each instance of x$_i$ in $O$, for any natural number $i$,
% with x$_{\mathrm{incr}_x(R)+i}$.  
% \end{ex} 
% Now application for unplugged contents (that is, objects of type
% \textit{UInterp}) can be characterized as in \nexteg{}.

% \begin{ex} 
% \textbf{Application}

% If $\alpha$ and $\beta$ are of type \textit{UInterp} and $\beta$.core
% is in the domain of $\alpha$.core, then the \textit{application of
%   $\alpha$ to $\beta$}, $\alpha @@\beta$, is
% \begin{quote}

% \record{\field{quants}{$\alpha$.quants$\cup$[$\beta$.quants]$_{\mathrm{incr}(\alpha\mathrm{.quants})}$}\\
%         \field{core}{$\alpha$.core@[$\beta$.core]$_{\mathrm{incr}(\alpha\mathrm{.quants})}$}}
% \end{quote}
% \end{ex} 
% \preveg{} says that the application of an unplugged content, $\alpha$,
% to another unplugged content, $\beta$, involves first changing the
% quantifier indices in $\beta$ so that they increment the quantifier
% indices in $\alpha$ in the way that is illustrated in the examples
% discussed above.  For example, if both $\alpha$ and $\beta$ contain
% the quantifier index `x$_0$' and this is the maximum in $\alpha$, then
% `x$_0$' will be changed to `x$_1$' in $\beta$.  Now the result of
% application is an unplugged content whose `quants' are the union of
% $\alpha$'s `quants' and the incremented `quants' of $\beta$.  The core
% is the result of applying $\alpha$'s core to $\beta$'s core using the
% same incrementation. 
  
\section{Anaphora}
\label{sec:anaph}

We will treat anaphora by adding to the storage mechanism we have just
introduced.  In informal terms the idea is that if the content type of
an utterance has something corresponding to \nexteg{a} as a witness
then it will also have something corresponding to \nexteg{b} as a
witness where $x_1$ has been anaphorically related to $x_0$.
\begin{ex} 
\begin{subex} 
 
\item $x_0$ thinks that $x_1$ has succeeded 
 
\item $x_0$ thinks that $x_0$ has succeeded 
 
\end{subex} 
   
\end{ex} 
Thus in general the content type yielded by the grammatical resources
will be underspecified as to whether there is anaphora or not but will
nevertheless delimit what the anaphoric possibilities are.  Anaphora
will be accounted for at the point of combination.  This is
illustrated schematically in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item $x_o$ + thinks that $x_1$ has succeeded = $x_0$ thinks that
  $x_1$ has succeeded 
 
\item If `$x_o$ + thinks that $x_1$ has succeeded' is an
  interpretation, then `$x_o$ + (thinks that $x_1$ has
  succeeded)[$x_1\leadsto x_0$]' is an interpretation
 
\end{subex} 
   
\end{ex} 
We will, of course, not be implementing this in terms of replacing
variables as in \preveg{} but rather in adjusting the contexts of
interpretation associated with pronoun utterances.  For example, we
will define a variant of the combination operation `@', `@$_{i,j}$' which
anaphorically relates a pronoun associated with the context path
`$\mathfrak{s}.j$' to one associated with the context path
`$\mathfrak{s}.i$'.  This is given in \nexteg{}, which is the same as
the characterization of `@' except for the addition of the boxed material.
\begin{ex} 
If $\alpha$ : \smallrecord{\smalltfield{bg}{\textit{CntxtType}}\\
                           \smalltfield{fg}{(bg$\rightarrow$($T_1\rightarrow
                             T_2$))}} 
and $\beta$ : \smallrecord{\smalltfield{bg}{\textit{CntxtType}}\\
  \smalltfield{fg}{(bg$\rightarrow T_1$)}}
\fbox{and $\alpha.\text{bg}\sqsubseteq$ \smallrecord{
    \smalltfield{$\mathfrak{s}$}{\smallrecord{
        \smalltfield{x$_i$}{\textit{Ind}}}}} and
  $\mathrm{incr}_{\mathfrak{s}.\text{x}}(\beta.\text{bg},\alpha.\text{bg})\sqsubseteq$
  \smallrecord{
    \smalltfield{$\mathfrak{s}$}{\smallrecord{
        \smalltfield{x$_j$}{\textit{Ind}}}}}},
                         then the \textit{combination of $\alpha$ and
    $\beta$  based on functional application \fbox{and anaphoric
      relation of $j$ to $i$}}, $\alpha\text{@}_{\fbox{i,j}}\beta$, is
  \begin{quote}
    $\ulcorner\lambda c$:$[\alpha.\text{bg}]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{f}}$
      \d{$\wedge$}$\mathrm{incr}_{\mathfrak{s}.\text{x}}([\beta.\text{bg}]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{a}},\alpha.\text{bg})\boxed{\ominus\mathfrak{s}.\text{x}_j}$
      . \\ \hspace*{2em}$[\alpha]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{f}}(c)(\mathrm{incr}_{\mathfrak{s}.\text{x}}([\beta.\text{fg}]_{\mathfrak{c}\leadsto\mathfrak{c}.\text{a}},\alpha.\text{bg})(c\boxed{[\mathfrak{s}.\text{x}_j=\mathfrak{s}.\text{x}_i]}))\urcorner$
\end{quote}


\end{ex} 
We can define similar modifications, $\mathcal{O}_{i,j}$ for the other combination
operators, $\mathcal{O}$.  Note that these additional combination
operations as currently formulated will only allow one anaphoric
relation to be introduced with each combination.  A more complete
treatment will probably need a generalized formulation in which there
are several pairs, $\langle i,j\rangle$, which are related simultaneously.

We can now add contents with anaphora to
our characterization of $\mathfrak{S}(T)$ given in
(\ref{ex:storage-type}) as in \nexteg{} where we again use boxing to
indicate the new material.
\begin{ex} 
\begin{subex} 
 
\item If $T:\textit{ContType}$, then $\mathfrak{S}(T)$ is a type 
 
\item The witnesses of $\mathfrak{S}(T)$ are characterized by
  \begin{enumerate} 
 
  \item if $\varphi:T$ then $\varphi:\mathfrak{S}(T)$

    
  \item \fbox{\begin{minipage}[t]{.85\linewidth}if $\alpha\mathcal{O}\beta:T$, (for
      some combination operation, $\mathcal{O}$) and
      $\alpha\mathcal{O}_{i,j}\beta$ is defined (for some natural
      numbers, $i$ and $j$), then $\alpha\mathcal{O}_{i,j}\beta:\mathfrak{S}(T)$\end{minipage}}
 
  \item if $\varphi:T$ and $\varphi$ is in the range of `$\mathrm{storage}$', then
    $\mathrm{storage}(\varphi):\mathfrak{S}(T)$

  \item if $\varphi:T$ and `x$_i$' and $\varphi$ are appropriate
    arguments to `$\mathrm{retrieve}$', then
    $\mathrm{retrieve}(\text{x}_i,\varphi):\mathfrak{S}(T)$
    
  \item nothing is a witness for $\mathfrak{S}(T)$ except as required above.
 
  \end{enumerate} 
  
 
\end{subex} 
\label{ex:storage-anaph-type}   
\end{ex}
% \todo{This doesn't allow for more than one anaphoric relation
%   introduced with some combination.  Problem with some interpretation
%   just happening to be identical with $\alpha\mathcal{O}\beta$
%   although obtained differently.}

We will now take some examples of key anaphoric phenomena and discuss
how we could use these tools to account for them.



\paragraph{\textit{No girl thinks she failed}}
\label{sec:direct-binding}

Given the strategy we suggested in Section~\ref{sec:unbound} for
interpreting unbound pronouns  the foreground of a content for
\textit{she failed} would be parallel to example
(\ref{ex:he-leave-abbrev}c) as in \nexteg{}, where we in addition
express this as the content type obtained by $\mathfrak{S}$.
\begin{ex}
  

$\ulcorner\lambda c$:\smallrecord{\footnotesize{\textit{Cntxt}}\\
                \smalltfield{$\mathfrak{s}$}{\smallrecord{
                    \smalltfield{x$_0$}{\textit{Ind}}}}}
  . 
         \record{\tfield{e}{fail($c.\mathfrak{s}$.x$_0$)}}$\urcorner^{\mathfrak{S}}$
% $\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}} . \record{\tfield{e}{fail($\mathfrak{s}$.x$_0$)}}

\end{ex} 
Call this \textbf{she$^\frown$failed}.  Then the 
content type for \textit{thinks she failed} is \nexteg{}.
\begin{ex}
  $\ulcorner\lambda c$:\smallrecord{\footnotesize{\textit{Cntxt}}\\
                \smalltfield{$\mathfrak{s}$}{\smallrecord{
                    \smalltfield{x$_0$}{\textit{Ind}}}}}
              . $\lambda r$:\smallrecord{
                \smalltfield{x}{\textit{Ind}}} . 
         \record{\tfield{e}{think($r$.x, fail($c.\mathfrak{s}$.x$_0$)}}$\urcorner^{\mathfrak{S}}$
% $\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%   . $\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
%     . \record{\tfield{e}{think($r$.x,
%         \textbf{she$^\frown$failed}($\mathfrak{s}$))}}
\label{ex:thinks-she-failed-x0} 
\end{ex} 
Call this \textbf{thinks$^\frown$she$^\frown$failed}. Here
\textit{she} is still a free occurrence of a pronoun dependent on the
context for resolution.  % An alternative interpretation is \nexteg{},
% where the pronoun has become bound as the subject of the property.
% \begin{ex} 
% $\lambda\mathfrak{s}$:\textit{Rec} . $\lambda
% r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
% . \record{\tfield{e}{think($r$.x, \textbf{she$^\frown$failed}($\mathfrak{s}\oplus$\smallrecord{\field{x$_0$}{$r$.x}}))}} 
% \end{ex} 
% We will call this a logophoric interpretation of the verb phrase,
% \textbf{thinks$^\frown$she$^\frown$failed$_{\mathrm{lg}}$}. These two
% readings for the verb-phrase yields two alternatives for the complete
% sentence, one where the pronoun remains unbound as in \nexteg{a} and
% one where it is bound as in \nexteg{b}.
% \begin{ex} 
% \begin{subex} 
 
% \item
%   $\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
%     . \record{\tfield{e}{no(girl$'$, \textbf{thinks$^\frown$she$^\frown$failed$_{x_0}$}($\mathfrak{s}$))}} 
 
% \item $\lambda\mathfrak{s}$:\textit{Rec}
%   . \record{\tfield{e}{no(girl$'$, \textbf{thinks$^\frown$she$^\frown$failed$_{\mathrm{lg}}$}($\mathfrak{s}$))}} 
 
% \end{subex} 
   
% \end{ex} 

% Let us now consider an option where we store the interpretation of
% \textit{no girl}.  For this we ill use the abbreviatory notation
% \nexteg{b} for \nexteg{a}
% \begin{ex} 
% \begin{subex} 
 
% \item \record{\field{bg}{$T_1$}\\
%               \field{fg}{$\lambda\mathfrak{v}$:$T_1$ . $T_2(\mathfrak{v})$}} 
 
% \item $\ulcorner\lambda\mathfrak{v}$:$T_1$ . $T_2(\mathfrak{v})\urcorner$
 
% \end{subex} 
   
% \end{ex} 
% [????We should introduce this notation from the beginning, starting
% p. 121 ``Parametric contents as we have presented them so far are
% problematic...''] If $\frec{f}$ is a record as
% characterized in \preveg{} then we use the notation $\frec{f}(a)$ to
% represent $\frec{f}.\text{fg}(a)$, that is, $f(a)$.

The content type associated with \textit{no girl} will be \nexteg{}.
\begin{ex} 
  $\ulcorner\lambda c$:\textit{Cntxt} . $\lambda
  P$:\textit{Ppty} . \smallrecord{
    \smallmfield{restr}{girl$'$}{\textit{Ppty}}\\
    \smallmfield{scope}{$P$}{\textit{Ppty}}\\
    \smalltfield{e}{no(restr, scope)}}$\urcorner^{\mathfrak{S}}$
  \label{ex:no-girl-cont-type}
\end{ex}
Let us represent the \textit{generator} of this type, that is,
\nexteg{}, by `no$'$(girl$'$)'.
\begin{ex} 
  $\ulcorner\lambda c$:\textit{Cntxt} . $\lambda
  P$:\textit{Ppty} . \smallrecord{
    \smallmfield{restr}{girl$'$}{\textit{Ppty}}\\
    \smallmfield{scope}{$P$}{\textit{Ppty}}\\
    \smalltfield{e}{no(restr, scope)}}$\urcorner$ 
\end{ex}
This means that one witness for the type (\ref{ex:no-girl-cont-type})
is \nexteg{} where `no$'$(girl$'$)' has been stored.
\begin{ex} 
$\ulcorner\lambda c$:\smallrecord{
    \footnotesize{\textit{Cntxt}}\\
    \smalltfield{$\mathfrak{q}$}{\smallrecord{
        \smallmfield{x$_0$}{no$'$(girl$'$)}{\textit{PQuant}}}}\\
    \smalltfield{$\mathfrak{s}$}{\smallrecord{
        \smalltfield{x$_0$}{\textit{Ind}}}}} . $\lambda
  P$:\textit{Ppty} . $P\{c.\mathfrak{s}.\text{x}_0\}\urcorner$ 
\end{ex} 
Note that the context type for this parametric content has the path
`$\mathfrak{s}$.x$_0$' which means that it is available for anaphoric
version of combination operations, thus enabling \textit{she} in
\textit{thinks she failed} to be related to `$\mathfrak{s}$.x$_0$'.
Application of `retrieve' to this content will obtain a content where
\textit{she} is bound by \textit{no girl}.   

% Interpreting \textit{no girl} with storage yields \nexteg{}.
% \begin{ex} 
% \record{\field{quants}{\{$\ulcorner\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
%       . $\lambda P$:\textit{Ppty} . \record{\tfield{e}{no(girl$'$,
%           $P$(\smallrecord{\field{x}{$\mathfrak{s}$.x$_1$}}))}}$\urcorner$\}}\\
% \field{core}{$\ulcorner\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
%   . $\lambda P$:\textit{Ppty} . $P$(\smallrecord{\smalltfield{x}{$\mathfrak{s}$.x$_1$}})$\urcorner$}} 
% \end{ex} 
% Then \textit{no girl thinks she failed} yields \nexteg{}.
% \begin{ex} 
%  \record{\field{quants}{\{$\ulcorner\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
%       . $\lambda P$:\textit{Ppty} . \record{\tfield{e}{no(girl$'$,
%           $P$(\smallrecord{\field{x}{$\mathfrak{s}$.x$_1$}})$|_{\mathcal{F}(\text{girl}')}$)}}$\urcorner$\}}\\
% \field{core}{$\ulcorner\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}}
%       . \record{\tfield{e}{\textbf{thinks$^\frown$she$^\frown$failed$_{x_0}$}($\mathfrak{s}\oplus$\smallrecord{\field{x$_0$}{$\mathfrak{s}$.x$_1$}})}}$\urcorner$}}
% \end{ex} 
% \preveg{} uses the definition of
% \textbf{thinks$^\frown$she$^\frown$failed$_{x_0}$} given in
% (\ref{ex:thinks-she-failed-x0}).  Let us call the value of the
% `core'-field in \preveg{}
% \textbf{thinks$^\frown$she$^\frown$failed$_{x_1}$}.  Then the result
% of applying retrieval to \preveg{} is \nexteg{}.
% \begin{ex} 
% \record{\field{quants}{\{\}}\\
%         \field{core}{$\ulcorner\lambda\mathfrak{s}$:\textit{Rec}
%           . \smallrecord{\smalltfield{e}{no(girl$'$, $\lambda
%               r$:\smallrecord{\smalltfield{x$_1$}{\textit{Ind}}\\
%                               \smalltfield{e}{girl(x$_1$)}} .  \textbf{thinks$^\frown$she$^\frown$failed$_{x_1}$}($\mathfrak{s}\oplus$\smallrecord{\field{x$_1$}{$r$.x$_1$}})})}$\urcorner$}}
% \end{ex} 
     
\paragraph{\textit{A man walked. He whistled.} }
\label{sec:discourse-anaph}
Given our strategy for defining the content of quantified sentences in
terms of generalized quantifiers a witness for the content type of \textit{a man walked}
will be \nexteg{}.
\begin{ex} 
  $\ulcorner\lambda c$:\textit{Cntxt} . \record{
    \mfield{restr}{man$'$}{\textit{Ppty}}\\
    \mfield{scope}{walk$'|_{\mathcal{F}(\text{restr})}$}{\textit{Ppty}}\\
    \tfield{e}{exist(restr, scope)}}$\urcorner$ 
\end{ex}
We know from our treatment of the witness conditions associated with
`exist' that \preveg{} is equivalent to \nexteg{}.
\begin{ex} 
  $\ulcorner\lambda c$:\textit{Cntxt} . \record{
    \mfield{restr}{man$'$}{\textit{Ppty}}\\
    \mfield{scope}{walk$'|_{\mathcal{F}(\text{restr})}$}{\textit{Ppty}}\\
    \tfield{e}{\record{
        \tfield{x}{$\mathfrak{T}$($\Uparrow$restr)}\\
        \tfield{e}{$\mathfrak{P}$($\Uparrow$scope)\{x\}}}}}$\urcorner$
  \label{ex:a-man-walked-derived}
\end{ex} 
Using our previous treatment for free pronouns, \textit{he whistled}
will have \nexteg{} as a witness of its content type.
\begin{ex}
  $\ulcorner\lambda c$:\smallrecord{\footnotesize{\textit{Cntxt}}\\
                \smalltfield{$\mathfrak{s}$}{\smallrecord{
                    \smalltfield{x$_0$}{\textit{Ind}}}}}
  . 
         \record{\tfield{e}{whistle($c.\mathfrak{s}$.x$_0$)}}$\urcorner$
         % $\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}} . \record{\tfield{e}{whistle($\mathfrak{s}$.x$_0$)}}

\label{ex:he-whistled-parametric}
\end{ex} 
We will represent \preveg{} as \textbf{he$^{\frown}$whistled}.

The utterance of \textit{He whistled} is to be interpreted in the
context of the previous utterance of \textit{a man walked}.
We will achieve this by merging the quasi-fixed point type (see
Chapter~\ref{ch:commonnouns}, p.~\pageref{ex:quasifixedpointtype}) of
the foreground of the parametric content of the previous utterance with the context type
of the current utterance.  The quasi-fixed point type for the
foreground of 
(\ref{ex:a-man-walked-derived}) is \nexteg{}.
\begin{ex} 
  \record{
    \tfield{$\mathfrak{c}^*$}{\textit{Cntxt}}\\
    \mfield{restr}{man$'$}{\textit{Ppty}}\\
    \mfield{scope}{walk$'|_{\mathcal{F}(\text{restr})}$}{\textit{Ppty}}\\
    \tfield{e}{\record{
        \tfield{x}{$\mathfrak{T}$($\Uparrow$restr)}\\
        \tfield{e}{$\mathfrak{P}$($\Uparrow$scope)\{x\}}}}} 
\end{ex} 
We will merge this under the label `$\mathfrak{p}$' (``previous'')
into the context type in (\ref{ex:he-whistled-parametric}) yielding \nexteg{}.
\begin{ex} 
  $\ulcorner\lambda c$:\smallrecord{
    \footnotesize{\textit{Cntxt}}\\
    \smallrecord{
      \smalltfield{$\mathfrak{p}$}{\smallrecord{
          \smalltfield{$\mathfrak{c}^*$}{\textit{Cntxt}}\\
          \smallmfield{restr}{man$'$}{\textit{Ppty}}\\
          \smallmfield{scope}{walk$'|_{\mathcal{F}(\text{restr})}$}{\textit{Ppty}}\\
          \smalltfield{e}{\smallrecord{
              \smalltfield{x}{$\mathfrak{T}$($\Uparrow$restr)}\\
              \smalltfield{e}{$\mathfrak{P}$($\Uparrow$scope)\{x\}}}}}}\\
      \smalltfield{$\mathfrak{s}$}{\smallrecord{
          \smalltfield{x$_0$}{\textit{Ind}}}}}}
    . \record{\tfield{e}{whistle($c.\mathfrak{s}$.x$_0$)}}$\urcorner$
\end{ex} 
\preveg{} makes the content of the previous utterance be part of the
context for content of the current utterance.  It does not, however,
express the anaphoric relation between \textit{he} and \textit{a man}.
In order to do this we need to require that $\mathfrak{s}.\text{x}_0$
in the context is identical with $\mathfrak{p}.\text{e}.\text{s}$.
This can be done by introducing a manifest field under the
`$\mathfrak{s}$'-label as in \nexteg{}.
\begin{ex} 
  $\ulcorner\lambda c$:\smallrecord{
    \footnotesize{\textit{Cntxt}}\\
    \smallrecord{
      \smalltfield{$\mathfrak{p}$}{\smallrecord{
          \smalltfield{$\mathfrak{c}^*$}{\textit{Cntxt}}\\
          \smallmfield{restr}{man$'$}{\textit{Ppty}}\\
          \smallmfield{scope}{walk$'|_{\mathcal{F}(\text{restr})}$}{\textit{Ppty}}\\
          \smalltfield{e}{\smallrecord{
              \smalltfield{x}{$\mathfrak{T}$($\Uparrow$restr)}\\
              \smalltfield{e}{$\mathfrak{P}$($\Uparrow$scope)\{x\}}}}}}\\
      \smalltfield{$\mathfrak{s}$}{\smallrecord{
          \smallmfield{x$_0$}{$\Uparrow\!\!\mathfrak{p}$.e.x}{\textit{Ind}}}}}}
  . \record{\tfield{e}{whistle($c.\mathfrak{s}$.x$_0$)}}$\urcorner$
\end{ex}

\begin{shaded}
\label{pg:path-alignment-types}Suppose that $T$ is a record type and that $\pi_1$ and $\pi_2$ are
paths in $T$.  Then we use $T_{\pi_1=\pi_2}$ to represent the type
exactly like $T$ except that $T_{\pi_1=\pi_2}.\pi_1=
(T.\pi_1)_{\pi_2}$, that is, whatever type, $T'$, is at the end of the path
$\pi_1$, is replaced by the singleton type $T'_{\pi_2}$, or if
$T.\pi_1$ is
\begin{quote}
$\langle\lambda v_1\!:\!T_1\ldots \lambda v_n\!:\!T_n\
.\ T'\dep{v_1,\ldots,v_n}, \Pi\rangle$
\end{quote}
then it is replaced by
\begin{quote}
$\langle\lambda v_1\!:\!T_1\ldots \lambda v_n\!:\!T_n\ 
.\ (T'\dep{v_1,\ldots,v_n})_{\pi_2}, \Pi\rangle$
\end{quote}
We use $T_{\pi_{11}=\pi_{21},\ldots,\pi_{1n}=\pi_{2n}}$ to
represent $(\ldots(T_{\pi_{11}=\pi_{21}})\ldots)_{\pi_{1n}=\pi_{2n}}$.

Suppose that $\varphi_1$ and $\varphi_2$ and parametric contents,
$\pi_{11}\ldots\pi_{1n}\in\mathrm{paths}(\varphi_1.\text{bg})$ and \\
$\pi_{21}\ldots\pi_{2n}\in\mathrm{paths}(\mathcal{F}_{\text{quasi}^*}(\varphi_2.\text{fg})$,
then the \textit{content $\varphi_1$ given $\varphi_2$ with
  alignment of $\pi_{11}$ and $\pi_{21}$;\ldots;$\pi_{1n}$ and $\pi_{2n}$},
$\varphi_1|_{\pi_{11},\pi_{21};\ldots;\pi_{1n},\pi_{2n}}\varphi_2$, is
\begin{quote}
  \record{
    \field{bg}{($\varphi_1$.bg \d{$\wedge$} \smallrecord{
        \smalltfield{$\mathfrak{p}$}{$\mathcal{F}_{\text{quasi}^*}(\varphi_2.\text{fg})$}})$_{\pi_{11}=\mathfrak{p}.\pi_{21},\ldots,\pi_{1n}=\mathfrak{p}.\pi_{2n}}$}\\
    \field{fg}{$\lambda c$:bg . $\varphi_1(c)$}}
\end{quote}

This gives us a way of combining two parametric contents.  Now we need
a way of combining the kinds of parametric content types that we are
using for underspecified interpretation.  If $T_1$ and $T_2$ are types
of parametric contents, then there is a combined type,
$\mathfrak{C}(T_1,T_2)$, whose witnesses include witnesses for $T_1$
given a witness for $T_2$ with some possible alignment between the
two.  The witnesses of $\mathfrak{C}(T_1,T_2)$ are characterized
recursively by:
\begin{enumerate} 
 
\item if $\varphi:T_1$, then $\varphi:\mathfrak{C}(T_1,T_2)$ 
 
\item \begin{tabbing}
    if \=$\varphi_1:\mathfrak{C}(T_1,T_2)$,\\
  \>$\pi_{11},\ldots,\pi_{1n}\in\mathrm{paths}(\varphi_1.\text{bg})$,\\ \>$\varphi_2:T_2$ and\\
\>$\pi_{21},\ldots,\pi_{2n}\in\mathrm{paths}(\mathcal{F}_{\text{quasi}^*}(\varphi_2.\text{fg}))$,
  \end{tabbing}
  then
  \begin{quote}
    $\varphi_1|_{\pi_{11},\pi_{21};\ldots;\pi_{1n},\pi_{2n}}\varphi_2:\mathfrak{C}(T_1,T_2)$
  \end{quote}
  
 
\end{enumerate} 
What we need then for the content type of the utterance is
$\mathfrak{S}(\mathfrak{C}(T_1,T_2))$.  We can express this by means
of the action rule in \nexteg{}.
\end{shaded}
\begin{sidewaysfigure}
\begin{ex}
  
  \begin{prooftree}
    \hypo{s_{i,A}:_A\text{\smallrecord{
          \smalltfield{shared}{\smallrecord{
              \smalltfield{latest-utterance}{\smallrecord{
                  \smalltfield{cont}{\textit{ContType}}}}}}}}}
    \hypo{u^*:_A\text{\smallrecord{
          \smalltfield{cont}{\textit{ContType}}}}}
    \infer[enth]2{s_{i+1,A}:_A\text{\smallrecord{
          \smalltfield{shared}{\smallrecord{
              \smalltfield{latest-utterance}{\smallrecord{
                  \smallmfield{cont}{$\mathfrak{S}(\mathfrak{C}(u^*.\text{cont},s_{i,A}.\text{shared}.\text{latest-utterance}.\text{cont}))$}{\textit{ContType}}}}}}}}}
  \end{prooftree}
  
\end{ex} 
\end{sidewaysfigure}  
  



  




% In
% order to obtain the content of the whole discourse, we will embed the
% content of the first sentence below the label `prev' (meaning
% ``previous'') and embed \textbf{he$^{\frown}$whistled} under `e'.
% This is the same technique we used to encode order (and salience) and
% to avoid unwanted label clash in our representation of attitudinal
% states in Chapter~\ref{ch:intensional}.  At the same time we need to
% ensure that the resulting content (on the anaphoric reading of the
% pronoun) does not depend on the context and that the `x$_0$' in
% \textbf{he$^{\frown}$whistled} gets bound to the path `e.x' in the
% content of the first sentence.  The result we obtain is \nexteg{a}
% which, spelling out the function application in the `e'-field, is
% identical with \nexteg{b}.
% \begin{ex}
% \begin{subex} 
 
% \item $\lambda\mathfrak{s}$:\textit{Rec} . 
% \record{\tfield{prev}{\record{\tfield{e}{\record{\tfield{x}{$\mathfrak{T}$(man$'$)}\\
%                                                  \tfield{e}{$\mathfrak{P}$(walk$'_{\mathcal{F}(\text{man}')}$)\{x\}}}}}}\\
%          \tfield{e}{\textbf{he$^{\frown}$whistled}($\mathfrak{s}\oplus$\smallrecord{\field{x$_0$}{$\Uparrow$prev.e.x}})}}   
 
% \item $\lambda\mathfrak{s}$:\textit{Rec} . 
% \record{\tfield{prev}{\record{\tfield{e}{\record{\tfield{x}{$\mathfrak{T}$(man$'$)}\\
%                                                  \tfield{e}{$\mathfrak{P}$(walk$'_{\mathcal{F}(\text{man}')}$)\{x\}}}}}}\\
%          \tfield{e}{\record{\tfield{e}{whistle($\Uparrow$prev.e.x)}}}} 
 
% \end{subex} 
   
 
% \end{ex} 

% Now we must consider how we would construct general rules that would
% combine the parametric content of the discourse so far with the
% parametric content of a new declarative sentence added to the
% discourse.  We will first consider the simple case where no anaphora
% occurs (for example, an interpretation of \textit{A man walked.  He
%   whistled} here \textit{he} is refers deictically and is not
% anaphorically related to \textit{a man}).  We will use
% $\mathcal{T}_{\text{curr}}$ to refer to the current parametric
% content of the discourse so far.  (We are making the simplifying
% assumption that the discourse consists of a string of declarative
% sentence utterances.) We will use $\mathcal{T}_{\text{new}}$ to refer
% to the paramtric content of the new (declarative) sentence with which
% we are updating the content of the discourse.  We will use
% $\mathcal{T}_{\text{curr}}+\mathcal{T}_{\text{new}}$ to represent the
% result of updating $\mathcal{T}_{\text{curr}}$ with
% $\mathcal{T}_{\text{new}}$.  The non-anaphoric update is then defined
% as in \nexteg{}.
% \begin{ex} 
% If $\mathcal{T}_{\text{curr}}$ : $(T_1\rightarrow\textit{Type})$ and
% $\mathcal{T}_{\text{new}}$ : $(T_2\rightarrow\textit{Type})$, then
% $\mathcal{T}_{\text{curr}}+\mathcal{T}_{\text{new}}$ is
% \begin{quote}
% $\lambda\mathfrak{s}$:$(T_1$\d{$\wedge$}$[T_2]_{\text{incr}_x(T_1)})$
% . \record{\tfield{prev}{$\mathcal{T}_{\text{curr}}(\mathfrak{s})$}\\
%           \tfield{e}{$[\mathcal{T}_{\text{new}}]_{\text{incr}_x(T_1)}(\mathfrak{s})$}}
% \end{quote}
% \end{ex} 
% This method of combination is similar to the S-combinator in
% combinatory logic, in that it applies both parametric contents to a
% context, $\mathfrak{s}$.  It abstracts over $\mathfrak{s}$ and makes
% sure that it is of an appropriate type to be an argument to both
% parametric contents.  Rather than applying the first result of
% application to $\mathfrak{s}$ to the second it
% creates a record type involving both the contents.  In addition it
% increments the `x'-labels in the second content so that there will no
% be unintended label clash between the two.

% In the case of making a discourse anaphoric connection two additional things
% have to happen.  The pronoun content within $\mathcal{T}_{\text{new}}$
% has to be connected to some path in $\mathcal{T}_{\text{curr}}$ and
% the updated parametric content
% $\mathcal{T}_{\text{curr}}+\mathcal{T}_{\text{new}}$ must be made not
% to depend on the context to determine the pronoun content.  We first
% give a definition which will allow one discourse anaphoric connection
% and we will then generalize this to a set of anaphoric connections.
% The definition given in \preveg{} will be a specific case of this
% general definition, where the set of anaphoric connections is empty.
% The case of a single anaphoric connection is given in \nexteg{}.
% \begin{ex} 
% If $\mathcal{T}_{\text{curr}}$ : $(T_1\rightarrow\textit{Type})$,
% $\mathcal{T}_{\text{new}}$ : $(T_2\rightarrow\textit{Type})$, for any
% $s:T_1$, $\pi\in\text{paths}(\mathcal{T}_{\text{curr}}(s))$ and
% $[\ell:v]\in[T_2]_{\text{incr}_x(T_1)}$, then
% $\mathcal{T}_{\text{curr}}+_{\pi,\ell}\mathcal{T}_{\text{new}}$ is
% \begin{quote}
% $\lambda\mathfrak{s}$:$(T_1$\d{$\wedge$}$[T_2]_{\text{incr}_x(T_1)}\ominus[\ell,v])$
% . \record{\tfield{prev}{$\mathcal{T}_{\text{curr}}(\mathfrak{s})$}\\
%           \tfield{e}{$[\mathcal{T}_{\text{new}}]_{\text{incr}_x(T_1)}(\mathfrak{s}\oplus[\ell=\text{prev}.\pi])$}}
% \end{quote} 
% \end{ex} 
% Here the dependence of $\mathcal{T}_{\text{new}}$ on $\ell$ is
% discharged locally by requiring that the $\ell$-field contains the
% same as the $\pi$-field from $\mathcal{T}_{\text{curr}}$.  The
% dependence on $\ell$ is thus removed from the domain of the function
% representing the parametric content for the whole discourse.

% Now let us consider how we can upgrade \preveg{} to allow for more
% than one pronoun resolution at a time as in an example like \textit{A
%   dog chased a cat.  She didn't catch him.} In order to facilitate
% this we introduce two new operators, $\ominus_{\text{set}}$ and
% $\oplus_{\text{set}}$, which perform $\ominus$ and $\oplus$
% respectively for each member of a set in their second arguments.  Thus
% $\ominus_{\text{set}}$ will subtract a set of fields from a record
% type and $\oplus_{\text{set}}$ will add a set of fields to a record.
% We present the upgraded version of \preveg{} in \nexteg{} where if
% $\pi$ is an ordered pair we use $\pi_1$ and $\pi_2$ to represent the
% first and second members of $\pi$ respectively and if $f$ is a field
% then we use label($f$) to represent the label in the field, that is
% the first member of the ordered pair which is the field.
% \begin{ex} 
% If $\mathcal{T}_{\text{curr}}$ : $(T_1\rightarrow\textit{Type})$,
% $\mathcal{T}_{\text{new}}$ : $(T_2\rightarrow\textit{Type})$ and\\
% \hspace*{2em}$\vec{\Pi}\subseteq[T_2]_{\text{incr}_x(T_1)}\times\{\pi\mid$ for any
% $s:T_1$, $\pi\in\text{paths}(\mathcal{T}_{\text{curr}}(s))\}$ such
% that $\vec{\Pi}$ is the graph of a one-one function,\\ then
% $\mathcal{T}_{\text{curr}}+_{\vec{\Pi}}\mathcal{T}_{\text{new}}$ is
% \begin{quote}
% $\lambda\mathfrak{s}$:$(T_1$\d{$\wedge$}$[T_2]_{\text{incr}_x(T_1)})\ominus_{\text{set}}\vec{\Pi}_1$
% .\\ \hspace*{2em} \record{\tfield{prev}{$\mathcal{T}_{\text{curr}}(\mathfrak{s})$}\\
%           \tfield{e}{$[\mathcal{T}_{\text{new}}]_{\text{incr}_x(T_1)}(\mathfrak{s}\oplus_{\text{set}}\{[\text{label}(\vec{\pi}_1)=\text{prev}.\vec{\pi}_2]\mid\vec{\pi}\in\vec{\Pi}\})$}}
% \end{quote} 
% \end{ex} 
% If $\vec{\Pi}$ is
% $\{\langle\langle\ell_1,v_1\rangle,\pi_1\rangle,\ldots,\langle\langle\ell_n,v_n\rangle,\pi_n\rangle\}$
% then for convenience we represent
% $\mathcal{T}_{\text{curr}}+_{\vec{\Pi}}\mathcal{T}_{\text{new}}$ as $\mathcal{T}_{\text{curr}}+_{\ell_1\leadsto\pi_1,\ldots,\ell_n\leadsto\pi_n}\mathcal{T}_{\text{new}}$.

This does not express any of the linguistic constraints concerning
what anaphors can be related to what antecedents.  % This will be
% addressed in Section~\ref{sec:struc-cntxt}.
  
  
% This does not give us a field which \textit{he} could pick up on to
% obtain the anaphoric reference.  However, we can show that the type
% in \nexteg{a} and \nexteg{b} are truth-conditionally equivalent, that is,  \nexteg{a}
% has a witness just in case \nexteg{b} has a witness.
% \begin{ex} 
% \begin{subex} 
 
% \item exist(man$'$, walk$'$) 
 
% \item \record{\tfield{x}{\textit{Ind}}\\
%               \tfield{c}{man(x)}\\
%               \tfield{e}{walk(x)}}
 
% \end{subex} 
% \label{ex:amw-drt}  
% \end{ex} 
% The argument for this goes as follows.  By an argument parallel to
% that in (\ref{ex:witnessconds-edr}c) we can show that \nexteg{a} and
% \nexteg{b} are equivalent.
% \begin{ex} 
% \begin{subex} 
 
% \item $s$ : exist(man$'$, walk$'$) 
 
% \item $\{a\mid\exists s'[s':\text{man}(a)]\}\cap\{a\mid\exists
%   s'[s':\text{man}(a)]\wedge\exists s'[s'\underline{\varepsilon}s\wedge s':\text{walk}(a)]\}\not=\emptyset$ 
 
% \end{subex} 
% \label{ex:amw-wit}   
% \end{ex} 
% This entails \nexteg{a} which, because of the arity of `man' and
% `walk', is equivalent to \nexteg{b}.
% \begin{ex} 
% \begin{subex} 
 
% \item $\exists a[\exists s'[s':\text{man}(a)]\wedge\exists s'[s':\text{walk}(a)]]$
 
% \item $\exists a[a:\textit{Ind}\wedge\exists s'[s':\text{man}(a)]\wedge\exists s'[s':\text{walk}(a)]]$ 
 
% \end{subex} 
   
% \end{ex} 
% If \preveg{b} is true, then it will be possible to construct a witness
% for (\ref{ex:amw-drt}b).  On the other hand, if $s$ is of type
% (\ref{ex:amw-drt}b), then (\ref{ex:amw-wit}b) will be true so there
% will be a witness for (\ref{ex:amw-drt}a), for example, $s$ itself.
% Thus if it has been asserted that there is a situation of type
% (\ref{ex:amw-drt}a), it is safe to assume that there is a situation of
% type (\ref{ex:amw-drt}b) (assuming that the assertion was true).
% (\ref{ex:amw-drt}b) gives us a field which can be picked up by anaphora.  

  

\paragraph{\textit{no dog which chases a cat catches it}}
\label{sec:donkey-anaph}
This example is an instance of what is known in the literature as
\textit{donkey anaphora}.  For a brief overview with references to a
large linguistic literature see \cite{KingLewis2018}.  
Our treatment of donkey anaphora will treat 
\textit{it} in \nexteg{a}  more like the kind of discourse
anaphora discussed in the previous example rather than
direct binding of a pronoun by a quantifier.  In this way it follows
the classic linguistic treatment of donkey anaphora in DRT, first
formulated in \cite{Kamp1981}.  Some evidence for this can be taken
from \nexteg{b}, where it is difficult to relate the singular pronoun
\textit{it} to \textit{every cat}, and \nexteg{c} where the plural
pronoun \textit{them} can be related \textit{every cat}.  This follows
the pattern of discourse anaphora illustrated in \nexteg{d} and
\nexteg{e}.
\begin{ex} 
\begin{subex} 
 
\item no dog which chases a cat catches it 
 
\item no dog which chases every cat catches it

\item no dog which chases every cat catches them

\item Every cat miaowed.  It wanted milk.

\item Every cat miaowed.  They wanted milk. 
 
\end{subex} 
   
\end{ex}

The key to the treatment of donkey anaphora is a process of local
accommodation of context in a parametric property.  Consider a
parametric content for the verb-phrase \textit{catches it} given in
\nexteg{}.
\begin{ex} 
  $\ulcorner\lambda c$:\smallrecord{
    \footnotesize{\textit{Cntxt}}\\
    \smalltfield{$\mathfrak{s}$}{\smallrecord{
        \footnotesize{\textit{Assgnmnt}}\\
        \smalltfield{x$_0$}{\textit{Ind}}}}} .
  $\ulcorner\lambda r$:\smallrecord{
    \smalltfield{x}{\textit{Ind}}} .
  \record{
    \tfield{e}{catch$^{\dagger}$($r$.x, $c.\mathfrak{s}.\text{x}_0$)}}$\urcorner\urcorner$
\end{ex} 
Local accommodation involves ``moving'' the type of the context into
the domain type of the property under the label `$\mathfrak{c}$' as in
\nexteg{}, adjusting any paths in $c$ addressed in the resulting
function to paths in $r$ beginning with `$\mathfrak{c}$'.
\begin{ex} 
 $\ulcorner\lambda c$:\textit{Cntxt} .
  $\ulcorner\lambda r$:\smallrecord{
    \smalltfield{x}{\textit{Ind}}\\
    \smalltfield{$\mathfrak{c}$}{\smallrecord{
    \footnotesize{\textit{Cntxt}}\\
    \smalltfield{$\mathfrak{s}$}{\smallrecord{
        \footnotesize{\textit{Assgnmnt}}\\
        \smalltfield{x$_0$}{\textit{Ind}}}}}}} .
  \record{
    \tfield{e}{catch$^{\dagger}$($r$.x, $r.\mathfrak{c}.\mathfrak{s}.\text{x}_0$)}}$\urcorner\urcorner$
\label{ex:catch-it-localized}
\end{ex}
In general we define a localization operation, $\mathcal{L}$, on
parametric properties characterized in \nexteg{}.
\begin{ex} 
  If $\mathcal{P}$ is a parametric property of the form
  \begin{quote}
    $\ulcorner\lambda c\!:\!T_1\ . \ulcorner\lambda r\!:\!T_2\ .\
    \varphi\urcorner\urcorner$
  \end{quote}
  then the \textit{localization of $\mathcal{P}$},
  $\mathcal{L}(\mathcal{P})$, is
  \begin{quote}
    $\ulcorner\lambda c\!:\!\textit{Cntxt}\ .\ \ulcorner\lambda
    r\!:\!T_2\text{\d{$\wedge$}\smallrecord{
        \smalltfield{$\mathfrak{c}$}{$T_1$}}}\ .\ 
    \varphi_{c.\pi\leadsto r.\mathfrak{c}.\pi}\urcorner\urcorner$
  \end{quote}
  
\end{ex} 
  
If we use the localized content (\ref{ex:catch-it-localized}) as the
content of the verb phrase, then, after combination with \textit{no
  dog which chases a cat}, the scope of the quantifier will become
\nexteg{}.
\begin{ex} 
  $\ulcorner\lambda r$:\smallrecord{
    \smalltfield{x}{\textit{Ind}}\\
    \smalltfield{$\mathfrak{c}$}{\smallrecord{
        \footnotesize{\textit{Cntxt}}\\
        \smalltfield{$\mathfrak{s}$}{\smallrecord{
            \footnotesize{\textit{Assgnmnt}}\\
            \smalltfield{x$_0$}{\textit{Ind}}}}}}\\
    \smalltfield{e$_1$}{dog(x)}\\
    \smalltfield{e$_2$}{\smallrecord{
        \smalltfield{x}{$\mathfrak{T}$(cat$'$)}\\
        \smalltfield{e}{chase$^\dagger$($r$.x, x)}}}}
   .
  \record{
    \tfield{e}{catch$^{\dagger}$($r$.x, $r.\mathfrak{c}.\mathfrak{s}.\text{x}_0$)}}$\urcorner$
\end{ex} 
We can paraphrase this as ``the property of being a dog which chases a
cat and there is something which it catches''.  In order to obtain the
anaphora we need to align the following two paths in the domain type
of this function: `$\mathfrak{c}.\mathfrak{s}.\text{x}_0$' and
`e$_2$.x'.  This we do in \nexteg{} by creating a manifest field on
the former path.
\begin{ex} 
  $\ulcorner\lambda r$:\smallrecord{
    \smalltfield{x}{\textit{Ind}}\\
    \smalltfield{$\mathfrak{c}$}{\smallrecord{
        \footnotesize{\textit{Cntxt}}\\
        \smalltfield{$\mathfrak{s}$}{\smallrecord{
            \footnotesize{\textit{Assgnmnt}}\\
            \smallmfield{x$_0$}{$\Uparrow^2$e$_2$.x}{\textit{Ind}}}}}}\\
    \smalltfield{e$_1$}{dog(x)}\\
    \smalltfield{e$_2$}{\smallrecord{
        \smalltfield{x}{$\mathfrak{T}$(cat$'$)}\\
        \smalltfield{e}{chase$^\dagger$($r$.x, x)}}}}
   .
  \record{
    \tfield{e}{catch$^{\dagger}$($r$.x, $r.\mathfrak{c}.\mathfrak{s}.\text{x}_0$)}}$\urcorner$
\end{ex}
We can paraphrase this as ``the property of being a dog which chases a
cat and catches that cat''.

In order to include such properties with aligned paths as the scope of
quantifiers in our interpretations, we will first generalize the
characterization of alignment of paths given on
p.~\pageref{pg:path-alignment-types}f to functions in \nexteg{}.
\begin{ex} 
  If $\varphi=\ulcorner\lambda r\!:\!T\ .\ \psi\urcorner$ and
  $\pi_1,\pi_2\in\mathrm{paths}(T)$, then
  \begin{quote}
    $\varphi_{\pi_1=\pi_2}=\ulcorner\lambda r\!:\!T_{\pi_1=\pi_2}\ .\
    \psi\urcorner$
  \end{quote}
\end{ex} 
We then add two further clauses to the characterization of witnesses
for $\mathfrak{S}(T)$ for content types, $T$. 

@@

The basic content related to \textit{no} is given in \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:\textit{Rec} $\lambda Q$:\textit{Ppty} $\lambda
P$:\textit{Ppty} . \record{\tfield{e}{no($Q$,$P|_{\mathcal{F}(Q)}$)}} 
\end{ex} 
As usual we abbreviate the content of \textit{dog} as `dog$'$'.  The
relative pronoun \textit{which} has the content specified for
\textit{who} in Section~\ref{sec:long-distance}.  (We are simplifying
by not accounting for the gender distinction between the two.)  We
repeat this in \nexteg{} and will refer to it here as \textbf{which}.
\begin{ex} 
$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{wh}{\textit{Ind}}}
  . $\lambda P$:\textit{Ppty} . $P$\{$\mathfrak{s}$.wh\} 
\end{ex} 
The basic content of an utterance of \textit{chase} is given in
\nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:\textit{Rec} $\lambda
r_2$:\smallrecord{\smalltfield{x}{\textit{Quant}}} $\lambda
r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
  . \record{\tfield{e}{chase($r_1$.x, $r_2$.x)}} 
\end{ex} 
The indefinite article $a$ will have the content in \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:\textit{Rec} $\lambda Q$:\textit{Ppty} $\lambda
P$:\textit{Ppty} . \record{\tfield{e}{exist($Q$, $P|_{\mathcal{F}(Q)}$)}} 
\end{ex} 
Thus the phrase \textit{a cat} will have the content in \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:\textit{Rec} $\lambda P$:\textit{Ppty}
. \record{\tfield{e}{exist(cat$'$, $P|_{\mathcal{F}(\text{cat}')}$)}} 
\end{ex} 
We will refer to \preveg{} as \textbf{a$^\frown$cat}.  Given this the
content of \textit{chase a cat} will be \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:\textit{Rec} $\lambda
r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
. \record{\tfield{e}{chase($r_1$.x,
    \textbf{a$^\frown$cat}($\mathfrak{s}$))}}
\label{ex:chaseacat-noexport} 
\end{ex} 
Given that \textit{chase} is an extensional verb it will obey a
constraint like (\ref{ex:mp-find}) on p.~\pageref{ex:mp-find}, as
given in \nexteg{}.
\begin{ex} 
$e$ : chase($a$, $Q$) iff $e$ : $Q$($\lambda
r$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . \smallrecord{\smalltfield{e}{chase$^{\dagger}$($a$,
$r$.x)}}) 
\end{ex} 
This means that we can construe the content to be a function which
returns an equivalent type to that returned in
(\ref{ex:chaseacat-noexport}).  This new content is given in
\nexteg{}.
\begin{ex} 
$\lambda s$:\textit{Rec} $\lambda
r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
  . \record{\tfield{e}{\textbf{a$^\frown$cat}($\mathfrak{s}$)($\lambda
      r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
      . \smallrecord{\smalltfield{e}{chase$^\dagger$($r_1$.x, $r$.x)}})}} 
\end{ex} 
\preveg{} is equivalent to \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:\textit{Rec} $\lambda
r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
. \record{\tfield{e}{exist(cat$'$, $\lambda
    r$:\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                    \smalltfield{e}{cat(x)}}
                  . \smallrecord{\smalltfield{e}{chase$^\dagger$($r_1$.x, $r$.x)}})}} 
\end{ex} 
In turn, \preveg{} is equivalent to \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:\textit{Rec} $\lambda
r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
  . \record{\tfield{e}{\record{\tfield{x}{$\mathfrak{T}$(cat$'$)}\\
                               \tfield{e}{\record{\tfield{$\mathfrak{c}$}{\smallrecord{\smallmfield{x}{$\Uparrow^2$x}{\textit{Ind}}\\
                                                   \smalltfield{e}{cat(x)}}}\\
                   \tfield{e}{\smallrecord{\smalltfield{e}{chase$^\dagger$($r_1$.x,
                         $\Uparrow\!\mathfrak{c}$.x)}}}}}}}}
\label{ex:chase-a-cat} 
\end{ex} 
We represent \preveg{} as \textbf{chase$^\frown$a$^\frown$cat}.  From
this we can form a ``sentence with a gap'' interpretation,
\textbf{chase$^\frown$a$^\frown$cat$_S$}, in the manner described in
Section~\ref{sec:long-distance}.  This is given in \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{wh$_0$}{\textit{Ind}}} . $\lambda
P$:\textit{Ppty} . $P$\{$\mathfrak{s}$.wh$_0$\}(\textbf{chase$^\frown$a$^\frown$cat}($\mathfrak{s}$)) 
\end{ex} 
Unpacking \preveg{} we obtain \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{wh$_0$}{\textit{Ind}}}
. \record{\tfield{e}{\record{\tfield{x}{$\mathfrak{T}$(cat$'$)}\\
                               \tfield{e}{\record{\tfield{$\mathfrak{c}$}{\smallrecord{\smallmfield{x}{$\Uparrow^2$x}{\textit{Ind}}\\
                                                   \smalltfield{e}{cat(x)}}}\\
                   \tfield{e}{\smallrecord{\smalltfield{e}{chase$^\dagger$($\mathfrak{s}$.wh$_0$, $\Uparrow\!\mathfrak{c}$.x)}}}}}}}} 
\end{ex} 
Again following the analysis of long-distance dependencies developed
in Section~\ref{sec:long-distance}, the content of \textit{which
  chased a cat} is given in \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:\textit{Rec} . \\
\hspace*{1em} $\lambda
r_1$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
. \textbf{which}($\mathfrak{s}\oplus[\text{wh}=r_1.\text{x}$)($\lambda
r_2$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . \textbf{chase$^\frown$a$^\frown$cat$_S$}($\mathfrak{s}\oplus[\text{wh}_0=r_2.\text{x}]$) 
\end{ex} 
Unpacking \preveg{} gives us (\ref{ex:chase-a-cat}).  That is, the content of
\textit{which chased a cat} is identical with the content of
\textit{chased a cat}.  For clarity we will represent this content
also as \textbf{which$^\frown$chase$^\frown$a$^\frown$cat}.
Again following the proposal in Section~\ref{sec:long-distance} the
content for \textit{dog which chases a cat} will be
\nexteg{}. 
\begin{ex} 
$\lambda\mathfrak{s}$:\textit{Rec} $\lambda
r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
. \record{\tfield{e$_1$}{dog$'$\{$r$.x\}}\\
          \tfield{e$_2$}{\textbf{which$^\frown$chase$^\frown$a$^\frown$cat}($\mathfrak{s}$)\{$r$.x\}}} 
\end{ex} 
We call this
\textbf{dog$^\frown$which$^\frown$chase$^\frown$a$^\frown$cat}. Now
\textit{no dog which chases a cat} will correspond to \nexteg{a} which
is equivalent to \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item $\lambda\mathfrak{s}$:\textit{Rec} $\lambda P$:\textit{Ppty}
  . \record{\tfield{e}{no(\textbf{dog$^\frown$which$^\frown$chase$^\frown$a$^\frown$cat}($\mathfrak{s}$),
      $P|_{\mathcal{F}(\textbf{dog}^\frown\textbf{which}^\frown\textbf{chase}^\frown
          \textbf{a}^\frown\textbf{cat}(\mathfrak{s}))}$)}} 
 
\item $\lambda\mathfrak{s}$:\textit{Rec} $\lambda P$:\textit{Ppty}
  . \record{\tfield{e}{\record{\tfield{X}{every$^w$(\textbf{dog$^\frown$which$^\frown$chase$^\frown$a$^\frown$cat}($\mathfrak{s}$))}\\
                           \tfield{f}{(($x:\mathfrak{T}(\text{X}))\rightarrow\neg\mathfrak{P}(P|_{\mathcal{F}(\textbf{dog$^\frown$which$^\frown$chase$^\frown$a$^\frown$cat}(\mathfrak{s}))})\{\text{x}\}$)}}}} 
 
\end{subex} 
\label{ex:no-dog-which-chases-a-cat}   
\end{ex} 
Call this
\textbf{no$^\frown$dog$^\frown$which$^\frown$chase$^\frown$a$^\frown$cat}.
This is to combine with the content of \textit{catches it}, given in
\nexteg{}. 
\begin{ex} 
$\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}
$\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
. \record{\tfield{e}{catch$^\dagger$($r$.x, $\mathfrak{s}$.x$_0$)}} 
\end{ex}
We will represent this as \textbf{catch$^\frown$it}. 
Using the S-combinator strategy to
(\ref{ex:no-dog-which-chases-a-cat}b) yields \nexteg{a}, equivalently
\nexteg{b}, which represents a reading of the sentence where
\textit{it} is not captured and refers to a particular object provided
by the context.
\begin{ex}
\begin{subex} 
 
\item $\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}} 
  . \smallrecord{\smalltfield{e}{\record{\tfield{X}{every$^w$(\textbf{dog$^\frown$which$^\frown$chase$^\frown$a$^\frown$cat}($\mathfrak{s}$))}\\
                           \tfield{f}{(($x:\mathfrak{T}(\text{X}))\rightarrow$\\
&&$\neg\mathfrak{P}(\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}}
. \record{\tfield{e}{catch$^\dagger$($r$.x, $\mathfrak{s}$.x$_0$)}}$|_{\mathcal{F}(\textbf{dog$^\frown$which$^\frown$chase$^\frown$a$^\frown$cat}(\mathfrak{s}))})\{\text{x}\}$)}}}} 
 
\item $\lambda\mathfrak{s}$:\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}} 
  . \smallrecord{\smalltfield{e}{\record{\tfield{X}{every$^w$(\textbf{dog$^\frown$which$^\frown$chase$^\frown$a$^\frown$cat}($\mathfrak{s}$))}\\
                           \tfield{f}{(($x:\mathfrak{T}(\text{X}))\rightarrow$\\
&&\hspace*{2em}$\neg$\smallrecord{\smalltfield{$\mathfrak{c}$}{\smallrecord{\smallmfield{x}{$x$}{\textit{Ind}}\\
                                                               \smalltfield{e$_1$}{dog$'$\{x\}}\\
                                                               \smalltfield{e$_2$}{\smallrecord{\smalltfield{e}{\smallrecord{\smalltfield{x}{$\mathfrak{T}$(cat$'$)}\\
                                                                                                \smalltfield{e}{\smallrecord{\smalltfield{$\mathfrak{c}$}{\smallrecord{\smallmfield{x}{$\Uparrow^2$x}{\textit{Ind}}\\
                                                                                                                                                                       \smalltfield{e}{cat(x)}}}\\
                                                                                                     \smalltfield{e}{\smallrecord{\smalltfield{e}{chase$^\dagger$($\Uparrow^4$x,
                                                                                                           $\Uparrow\!\mathfrak{c}$.x)}}}}}}}}}}}\\
               \smalltfield{e}{catch$^\dagger$($x$, $\mathfrak{s}$.x$_0$)}}
)}}}} 
 
\end{subex} 
   
 
\end{ex} 
In terms of the notation in \preveg{b}, it is simple enough to see
what needs to be done in order to change it to a case of donkey
anaphora.  The second argument to `catch$^\dagger$',
`$\mathfrak{s}$.x$_0$', has to be changed so that it presents a path
to the cat, that is, `$\mathfrak{c}$.e$_2$.e.x'.  Also the dependence
of this parametric content on `x$_0$' has to be removed.  Thus the
domain type for the $\lambda$-abstraction, currently
`\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}', should be replaced
by `\textit{Rec}'.  The result would be \nexteg{}.
\begin{ex} 
 $\lambda\mathfrak{s}$:\textit{Rec} 
  . \smallrecord{\smalltfield{e}{\record{\tfield{X}{every$^w$(\textbf{dog$^\frown$which$^\frown$chase$^\frown$a$^\frown$cat}($\mathfrak{s}$))}\\
                           \tfield{f}{(($x:\mathfrak{T}(\text{X}))\rightarrow$\\
&&\hspace*{2em}$\neg$\smallrecord{\smalltfield{$\mathfrak{c}$}{\smallrecord{\smallmfield{x}{$x$}{\textit{Ind}}\\
                                                               \smalltfield{e$_1$}{dog$'$\{x\}}\\
                                                               \smalltfield{e$_2$}{\smallrecord{\smalltfield{e}{\smallrecord{\smalltfield{x}{$\mathfrak{T}$(cat$'$)}\\
                                                                                                \smalltfield{e}{\smallrecord{\smalltfield{$\mathfrak{c}$}{\smallrecord{\smallmfield{x}{$\Uparrow^2$x}{\textit{Ind}}\\
                                                                                                                                                                       \smalltfield{e}{cat(x)}}}\\
                                                                                                     \smalltfield{e}{\smallrecord{\smalltfield{e}{chase$^\dagger$($\Uparrow^4$x,
                                                                                                           $\Uparrow\!\mathfrak{c}$.x)}}}}}}}}}}}\\
               \smalltfield{e}{catch$^\dagger$($x$, $\mathfrak{c}$.e$_2$.e.x)}}
)}}}}
\label{ex:no-dog-which-chases-a-cat-catches-it-captured} 
\end{ex} 
We will achieve this by introducing a notion of restriction on a
parametric property in which we will allow anaphora to take place.
Let us first consider a case without anaphora.  Suppose that
$\mathcal{P}$ is a parametric property of type
$(T_1\rightarrow(T_2\rightarrow \textit{Type}))$ and that $T$ is a
type then we define the restriction of $\mathcal{P}$ by $T$,
$\mathcal{P}|^p_T$, to be \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:$T_1$ $\lambda r$:$T_2$\d{$\wedge$}$T$ . $\mathcal{P}(\mathfrak{s})(r)$ 
\end{ex} 
Now suppose that $[\ell,v]$ is a field in $T_1$ and $\pi$ is a path in
$T_2$ and we want to make an anaphoric association between $\ell$ and
$\pi$.  We define such a restriction,
$\mathcal{P}|^p_{T,\ell\leadsto\pi}$ as \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:$T_1\ominus[\ell:v]$ $\lambda
r$:$T_2$\d{$\wedge$}$T$ . $\mathcal{P}(\mathfrak{s}\oplus[\ell=r.\pi])(r)$ 
\end{ex}
To enable the capture of several pronouns, we let $\vec\Pi\subseteq
T_1\times\text{paths}(T)$ such that $\vec\Pi$ is the graph of a one-one
function (whose domain is included in the fields of $T_1$ and whose
range is included in the paths of $T$).  We then define
$\mathcal{P}|^p_{T,\vec{\Pi}}$ to be \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:$T_1\ominus_{\text{set}}\vec{\Pi}_1$ $\lambda
r$:$T_2$\d{$\wedge$}$T$ . $\mathcal{P}(\mathfrak{s}\oplus_{\text{set}}\{[\text{label}(\vec{\pi}_1)=r.\vec{\pi}_2]\mid\vec{\pi}\in\vec{\Pi}\})$ 
\end{ex} 
If $\vec{\Pi}$ is
$\{\langle\langle\ell_1,v_1\rangle,\pi_1\rangle,\ldots,\langle\langle\ell_n,v_n\rangle,\pi_n\rangle\}$
then for convenience we represent $\mathcal{P}|^p_{T,\vec{\Pi}}$ as
$\mathcal{P}|^p_{T,\ell_1\leadsto\pi_1,\ldots,\ell_n\leadsto\pi_n}$. Using
this notation,  the content of \textit{no dog which chases a cat catches
  it} where the pronoun is captured is \nexteg{}.
\begin{ex} 
$\lambda\mathfrak{s}$:\textit{Rec}
  . \smallrecord{\smalltfield{e}{\record{\tfield{X}{every$^w$(\textbf{dog$^\frown$which$^\frown$chase$^\frown$a$^\frown$cat}($\mathfrak{s}$))}\\
                           \tfield{f}{(($x:\mathfrak{T}(\text{X}))\rightarrow$\\
&&$\neg\mathfrak{P}$(\textbf{catch$^\frown$it}$|^p_{\mathcal{F}(\textbf{dog$^\frown$which$^\frown$chase$^\frown$a$^\frown$cat}(\mathfrak{s})),\text{x}_0\leadsto\text{e}_2.\text{e}.\text{x}}(\mathfrak{s})$)\{x\})}}}} 
\end{ex} 
Unpacking \preveg{} yields
(\ref{ex:no-dog-which-chases-a-cat-catches-it-captured}).

Notice that (\ref{ex:no-dog-which-chases-a-cat-catches-it-captured})
forces what is known in the literature as a \textit{strong} reading
for the donkey anaphora.  That is, none of the dogs which chase a cat
catch \textit{any} of the cats which they chase.  That monotone
decreasing quantifiers force such strong readings was noted, for
example, by [Chierchia???? Pelletier????].  Monotone increasing
quantifiers, however, allow \textit{weak} readings.  Examples of
donkey sentences mentioned in the literature that have naturally weak
readings are given in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item Every person who has a dime should put it in the parking
  meter. (Pelletier ????) 
 
\item Every man who has a daughter thinks she is the most beautiful
  girl in the world \citep{Cooper1979} 
 
\end{subex} 
   
\end{ex} 
\preveg{a} does not seem to suggest that anybody who has several dimes
should put them all in the meter and \preveg{b} does not seem to
commit a man who has two daughters to believe the contradictory
proposition that they are both the one and only most beautiful girl in
the world. Let us consider the content for \textit{every person who
  had a dime put it in the parking meter} given in \nexteg{}.
\begin{ex} 
 $\lambda\mathfrak{s}$:\textit{Rec} 
  . \smallrecord{\smalltfield{e}{\record{\tfield{X}{every$^w$(\textbf{person$^\frown$who$^\frown$have$^\frown$a$^\frown$dime}($\mathfrak{s}$))}\\
                           \tfield{f}{(($x:\mathfrak{T}(\text{X}))\rightarrow$\\
&&\hspace*{2em}\smallrecord{\smalltfield{$\mathfrak{c}$}{\smallrecord{\smallmfield{x}{$x$}{\textit{Ind}}\\
                                                               \smalltfield{e$_1$}{person$'$\{x\}}\\
                                                               \smalltfield{e$_2$}{\smallrecord{\smalltfield{e}{\smallrecord{\smalltfield{x}{$\mathfrak{T}$(dime$'$)}\\
                                                                                                \smalltfield{e}{\smallrecord{\smalltfield{$\mathfrak{c}$}{\smallrecord{\smallmfield{x}{$\Uparrow^2$x}{\textit{Ind}}\\
                                                                                                                                                                       \smalltfield{e}{dime(x)}}}\\
                                                                                                     \smalltfield{e}{\smallrecord{\smalltfield{e}{have$^\dagger$($\Uparrow^4$x,
                                                                                                           $\Uparrow\!\mathfrak{c}$.x)}}}}}}}}}}}\\
               \smalltfield{e}{put\_in\_the\_meter$^\dagger$($x$, $\mathfrak{c}$.e$_2$.e.x)}}
)}}}} 
\end{ex} 
\preveg{} is exactly similar to
(\ref{ex:no-dog-which-chases-a-cat-catches-it-captured}) modulo the
properties and predicates involved except that there is no negation in
\preveg{}.  \preveg{} requires then that every person who had a dime
is a person who had a dime and put it in the meter, that is, a weak
reading which requires only that each relevant person put some dime in
the meter, not all of their dimes.  What then do we say about the
original donkey sentences like \textit{every farmer who owns a donkey
  likes it} which were analyzed by Geach and the classical analyses in
DRT and type theory as having a strong reading in which every farmer
who owns a donkey likes any donkey that he owns?  One option is to say
that we only need the weak reading for such sentences as given in
\nexteg{}.
\begin{ex} 
 $\lambda\mathfrak{s}$:\textit{Rec} 
  . \smallrecord{\smalltfield{e}{\record{\tfield{X}{every$^w$(\textbf{farmer$^\frown$who$^\frown$owns$^\frown$a$^\frown$donkey}($\mathfrak{s}$))}\\
                           \tfield{f}{(($x:\mathfrak{T}(\text{X}))\rightarrow$\\
&&\hspace*{2em}\smallrecord{\smalltfield{$\mathfrak{c}$}{\smallrecord{\smallmfield{x}{$x$}{\textit{Ind}}\\
                                                               \smalltfield{e$_1$}{farmer$'$\{x\}}\\
                                                               \smalltfield{e$_2$}{\smallrecord{\smalltfield{e}{\smallrecord{\smalltfield{x}{$\mathfrak{T}$(donkey$'$)}\\
                                                                                                \smalltfield{e}{\smallrecord{\smalltfield{$\mathfrak{c}$}{\smallrecord{\smallmfield{x}{$\Uparrow^2$x}{\textit{Ind}}\\
                                                                                                                                                                       \smalltfield{e}{donkey(x)}}}\\
                                                                                                     \smalltfield{e}{\smallrecord{\smalltfield{e}{have$^\dagger$($\Uparrow^4$x,
                                                                                                           $\Uparrow\!\mathfrak{c}$.x)}}}}}}}}}}}\\
               \smalltfield{e}{like$^\dagger$($x$, $\mathfrak{c}$.e$_2$.e.x)}}
)}}}} 
\label{ex:donkey-weak} 
\end{ex} 
That is,
\textit{every farmer who owns a donkey likes it} requires that for
every donkey owning farmer there is at least one donkey the farmer
owns such that she likes it.  This allows for the farmers to like all
their donkeys but does not require it.

Another option is to recreate the original Geach reading by
introducing a variant of the purification operation in
(\ref{ex:purification}) which introduces a function on local contexts
as in \nexteg{}. 
\begin{ex} 
If $P$ : \textit{Ppty}, then
\begin{quote}
if $P$.bg$^x$ = $P$.bg, then
\begin{quote}
$\mathfrak{P}(P)=P$
\end{quote}
otherwise:
\begin{quote}
$\mathfrak{P}(P)$ is $\ulcorner\lambda r_1$:$P$.bg$^{\text{x}}$
. ($(r_2\!:\!P.\text{bg}\!\parallel\!\!\text{\smallrecord{\field{x}{$r$.x}}})\rightarrow$
\record{
          \tfield{e}{$P(r_2)$}})$\urcorner$
\end{quote}
\end{quote}
%\label{ex:purification-classic}
\end{ex}
Using \preveg{} instead of (\ref{ex:purification}) will have the
consequence that the content of \textit{every farmer who owns a donkey
  likes it} will be \nexteg{} rather than (\ref{ex:donkey-weak}).
\begin{ex} 
$\lambda\mathfrak{s}$:\textit{Rec} 
  . \smallrecord{\smalltfield{e}{\record{\tfield{X}{every$^w$(\textbf{farmer$^\frown$who$^\frown$owns$^\frown$a$^\frown$donkey}($\mathfrak{s}$))}\\
                           \tfield{f}{(($x:\mathfrak{T}(\text{X}))\rightarrow$\\
&&\hspace*{2em}(($r$:\smallrecord{\smallmfield{x}{$x$}{\textit{Ind}}\\
                                                               \smalltfield{e$_1$}{farmer$'$\{x\}}\\
                                                               \smalltfield{e$_2$}{\smallrecord{\smalltfield{e}{\smallrecord{\smalltfield{x}{$\mathfrak{T}$(donkey$'$)}\\
                                                                                                \smalltfield{e}{\smallrecord{\smalltfield{$\mathfrak{c}$}{\smallrecord{\smallmfield{x}{$\Uparrow^2$x}{\textit{Ind}}\\
                                                                                                                                                                       \smalltfield{e}{donkey(x)}}}\\
                                                                                                     \smalltfield{e}{\smallrecord{\smalltfield{e}{have$^\dagger$($\Uparrow^4$x,
                                                                                                           $\Uparrow\!\mathfrak{c}$.x)}}}}}}}}}})
                                                                                       $\rightarrow$\\
               &&\hspace*{5em}\smallrecord{\smalltfield{e}{like$^\dagger$($x$, $r$.e$_2$.e.x)}}
))}}}}  
\end{ex} 
\preveg{} requires that the function labelled `f' maps any farmer who
owns a donkey to a function which maps any situation in which that
farmer owns a donkey to a situation in which the farmer likes the
donkey.  Since for any donkey the farmer owns there will be a
situation in which the farmer owns that donkey, this has the effect of
universal quantification over the farmer's donkeys.  The difference
between strong and weak readings is, however, cashed out in terms of
whether we map farmers to functions from ``donkey owning'' situations
to ``liking'' situations or to situations where there is ``donkey
owning'' and ``liking''.

It is not entirely obvious that strong readings are necessary since
weak readings are consistent with the strong readings.  One might
argue that the strong reading is necessary for interpreting sentences
such as \nexteg{}.
\begin{ex} 
It is not true that every farmer who owns a donkey likes it 
\end{ex} 
If there is a reading of \preveg{} on which it is true even if every
farmer likes at least one of her donkeys, but at least one farmer 
does not like all of them, then we need to analyze this a strong reading. [????Check
for discussion of this.]  

The domain of the function introduced is farmers who own a donkey in
our analysis of both the weak and the strong readings.  This is in
contrast to the classical treatment of the strong reading
\citep{Geach1962,KampReyle1993} which can be construed as 
quantification over pairs of farmers and donkeys.  This works in the
case of universal quantification. The sentence \textit{every farmer
  who owns a donkey likes it} can be construed as ``every
farmer-donkey pair such that the farmer owns the donkey is such that
the farmer likes the donkey''.  However, for other generalized
quantifiers, such as \textit{most} this represents an incorrect
paraphrase.  Thus \textit{most farmers who own a donkey like it}
cannot be construed as ``most farmer-donkey pairs such that the farmer
owns the donkey are such that the farmer likes the donkey''.
\cite{Chierchia1995} gives a good account of why this is so.  Suppose
we have five farmers four of which have exactly one donkey and do not
like it.  The fifth farmer has fifty donkeys and likes them all.
Clearly in this case most farmer-donkey pairs are such that the farmer
likes the donkey but it is not the case that most farmers who own a
donkey like it.  This problem is known in the literature as the
\textit{proportion problem}.  The treatment that we have proposed here
does not suffer from it since the quantification is over farmers who
own a donkey rather than farmer-donkey pairs. 
    
% In order to get this to work out in a compositional way we will use
% the kind of quantifier anatomy  that we introduced in
% Chapters~\ref{ch:gram} and~\ref{ch:commonnouns} except that we will
% use parametric properties instead of non-parametric properties.  Let
% us introduce some abbreviatory notation [should introduce from the
% beginning!].  Suppose that $q$ is a quantifier relation,
% $\mathcal{P}$ and $\mathcal{Q}$ are parametric properties and
% $\mathfrak{s}$ is a context of the kind we have been using in this
% chapter, then we use $\mathfrak{Q}(q,\mathcal{P},\mathcal{Q},\mathfrak{s})$ to represent
% \nexteg{}.
% \begin{ex} 
% \record{\mfield{restr}{$\mathcal{P}$}{\textit{PPpty}}\\
%         \mfield{scope}{$\mathcal{Q}$}{\textit{PPpty}}\\
%         \tfield{e}{$q$(restr($\mathfrak{s}$), scope($\mathfrak{s}$))}} 
% \end{ex} 
% Instead of (\ref{ex:no-dog-which-chases-a-cat}) we will have
% \nexteg{a}, which is identical with \nexteg{b}.
% \begin{ex} 
% \begin{subex} 
 
% \item $\lambda\mathfrak{s}$:\textit{Rec}
%   $\lambda\mathcal{P}$:\textit{PPpty}
%   . $\mathfrak{Q}$(no, \textbf{dog$^\frown$which$^\frown$chase$^\frown$a$^\frown$cat},
%   $\mathcal{P}$, $\mathfrak{s}$)

 
% \item $\lambda\mathfrak{s}$:\textit{Rec}
%   $\lambda\mathcal{P}$:\textit{PPpty}
%   . \record{\mfield{restr}{\textbf{dog$^\frown$which$^\frown$chase$^\frown$a$^\frown$cat}}{\textit{PPpty}}\\
%             \mfield{scope}{$\mathcal{P}$}{\textit{PPpty}}\\
%             \tfield{e}{no(restr($\mathfrak{s}$), scope($\mathfrak{s}$))}} 
% % \record{\mfield{restr}{\textbf{dog$^\frown$which$^\frown$chase$^\frown$a$^\frown$cat}}{\textit{PPpty}}\\
% %             \mfield{scope}{$\mathcal{P}$}{\textit{PPpty}}\\
% %             \tfield{e}{\record{\tfield{X}{every$^w$($\Uparrow$restr($\mathfrak{s}$))}\\
% %                                \tfield{f}{(($x:\mathfrak{T}(\text{X}))\rightarrow\neg\mathfrak{P}$($\Uparrow$scope($\mathfrak{s}$)))\{x\}}}}}
                         
 
% \end{subex} 
   
% \end{ex} 
% We will now use
% \textbf{no$^\frown$dog$^\frown$which$^\frown$chase$^\frown$a$^\frown$cat}
% to refer to \preveg{} rather than
% (\ref{ex:no-dog-which-chases-a-cat}).  Note that we have not
% restricted the scope (that is the second argument of the quantifier
% relation) by the fixed point type of the restriction (that is the
% first argument of the quantifier relation).  Now that we have put the
% parametric properties used to form the arguments to the quantifier
% relation in their own fields (`restr' and `scope') we can have access
% to them at the point at which we combine the noun-phrase
% interpretation with that of another constituent and can at that point
% make modifications to the second argument.  Since we have the
% arguments to the quantifier relation accessible via the labels `restr'
% and `scope' 

     
\paragraph{\textit{Sam likes him/himself}}

The parametric content for \textit{him} is given in \nexteg{}.

\begin{ex} 
$\lambda
c$:\smallrecord{\smalltfield{$\mathfrak{s}$}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}}\\
                \smallmfield{local}{$\mathfrak{T}$(\{$\mathfrak{s}$.x$_0$\})}{\textit{Type}}\\
\smallmfield{refl}{$\mathfrak{T}$($\emptyset$)}{\textit{Type}}} . 
$\lambda P$:\textit{Ppty} . $P$\{c.$\mathfrak{s}$.x$_0$\}
\end{ex} 

The parametric content of the reflexive pronoun \textit{himself} is
the same as \preveg{} except that the values associated with the
labels `local' and `refl' are switched, as shown in \nexteg{}.

\begin{ex} 
$\lambda
c$:\smallrecord{\smalltfield{$\mathfrak{s}$}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}}\\
                \smallmfield{local}{$\mathfrak{T}$($\emptyset$)}{\textit{Type}}\\
\smallmfield{refl}{$\mathfrak{T}$(\{$\mathfrak{s}$.x$_0$\})}{\textit{Type}}}
 . 
$\lambda P$:\textit{Ppty} . $P$\{c.$\mathfrak{s}$.x$_0$\}
\end{ex} 
We will refer to \preveg{} as \textbf{himself}.  The idea is that the `local'-field in the context must be passed up to
the VP unchanged, whereas the `refl'-field must be emptied
(discharged) at the VP-level.  Thus \textit{likes him} has the
parametric content in \nexteg{a} whereas \textit{likes himself} has
the parametric content in \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item $\lambda
c$:\smallrecord{\smalltfield{$\mathfrak{s}$}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}}\\
                \smallmfield{local}{$\mathfrak{T}$(\{$\mathfrak{s}$.x$_0$\})}{\textit{Type}}\\
\smallmfield{refl}{$\mathfrak{T}$($\emptyset$)}{\textit{Type}}} . 
$\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . \record{\tfield{e}{like($r$.x,
$\lambda P$:\textit{Ppty} . $P$\{$c$.$\mathfrak{s}$.x$_0$\})}} 
 
\item $\lambda
c$:\smallrecord{\smallmfield{local}{$\mathfrak{T}$($\emptyset$)}{\textit{Type}}\\
  \smallmfield{refl}{$\mathfrak{T}$($\emptyset$)}{\textit{Type}}} . 
$\lambda r$:\smallrecord{\smalltfield{x}{\textit{Ind}}} . \record{\tfield{e}{like($r$.x,
  \textbf{himself}(\smallrecord{\field{$\mathfrak{s}$}{\smallrecord{\field{x$_0$}{$r$.x}}}\\
                                \field{local}{$\mathfrak{T}$($\emptyset$)}\\
                                \field{refl}{$\mathfrak{T}$(\{$r$.x\})}}))}}
 
 
\end{subex} 
   
\end{ex}
The idea is that context parameters represented by `$\mathfrak{s}$'
are open for binding unless object supplying that parameter are
required to be of type `$c$.local'.  Reflexive parameters are, however,
required to be of type `$c$.refl' and these must be bound within the VP.
Note that since the reflexive is bound by `$r$.x' in \preveg{b} it is
not represented in `$c$.refl' in the context for the VP.  Thus
\textit{himself} on its own requires an individual to be supplied by
the context to give it a referent.  However, for the content of
\textit{likes himself} no such individual is required from the context
since the property which is the content of the VP is that of ``being
an $x$ such that $x$ likes $x$''.  [Better way to talk about this?].

[Possible revision of treatment of proper names:]
The content of an utterance of \textit{Sam} is given in \nexteg{}.
\begin{ex} 
$\lambda
c$:\smallrecord{\smalltfield{$\mathfrak{c}$}{\smallrecord{\smalltfield{id$_0$}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                                           \smalltfield{e}{named(x,
                                                                                             ``Sam'')}}}}}}
                                                                                 . $\lambda
                                                                                 P$:\textit{Ppty}
                                                                                 . $P$($c$.$\mathfrak{c}$.id$_0$) 
\end{ex} 
The content of \textit{Sam likes him} is given in \nexteg{a} and
\textit{Sam likes himself} in \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item $\lambda
  c$:\smallrecord{\smalltfield{$\mathfrak{s}$}{\smallrecord{\smalltfield{x$_0$}{\textit{Ind}}}}\\
                  \smallmfield{local}{$\mathfrak{T}$($\emptyset$)}{\textit{Type}}\\
\smallmfield{refl}{$\mathfrak{T}$($\emptyset$)}{\textit{Type}}\\
\smalltfield{$\mathfrak{c}$}{\smallrecord{\smalltfield{id$_0$}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                            \smalltfield{e}{named(x,
                                                                              ``Sam'')}}}}}}
                                                                  . 
\record{\tfield{e}{like($c$.$\mathfrak{c}$.id$_0$.x, $\lambda
    P$:\textit{Ppty} . $P$\{$c$.$\mathfrak{s}$.x$_0$\})}}
 
\item $\lambda
  c$:\smallrecord{
\smallmfield{local}{$\mathfrak{T}$($\emptyset$)}{\textit{Type}}\\
\smallmfield{refl}{$\mathfrak{T}$($\emptyset$)}{\textit{Type}}\\
\smalltfield{$\mathfrak{c}$}{\smallrecord{\smalltfield{id$_0$}{\smallrecord{\smalltfield{x}{\textit{Ind}}\\
                                                                            \smalltfield{e}{named(x,
                                                                              ``Sam'')}}}}}}
                                                                  . \\
\hspace*{3em}                                                                   
\record{\tfield{e}{like($c$.$\mathfrak{c}$.id$_0$.x, $\lambda
    P$:\textit{Ppty} . 
$P$\{$c$.$\mathfrak{c}$.id$_0$.x\})}} 
 
\end{subex} 
   
\end{ex} 
               
      


%[Grammar to be added.]
   

\section{Summary of resources introduced}

\section{Conclusion}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "ttl"
%%% End: 
