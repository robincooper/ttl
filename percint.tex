\chapter{From perception to intensionality}
\label{ch:percint}
\pagestyle{headings}

\section{Introduction}

When we perceive objects and events we classify them as belonging to
some type.  In this chapter we will explain this idea and introduce a
mathematical theory of some of the types we use.  Perception and the
use of natural language for communication are closely linked.  Types,
particularly types of events, are a good model for what are often
called ``propositions'', true if there is something of the type and
false if there is nothing of the type.  It seems that the origin
of linguistic meaning seems closely related to perception.  If you are
talking to a two year old child, you tend to point at physical objects
or observable events and utter the corresponding word or phrase.  You
do not talk about abstract concepts like `university', `democracy',
`thought' or `feeling'.  These come later.  We will argue in this
book, that humans have built on the basic perceptual apparatus in
terms of types in a way that allows them to reason about the types
themselves and that it is this ability which allows us to talk about
intensional notions like `belief' and `knowledge'.

In this chapter we will talk first about the notion of perception as
type assignment (Section~\ref{sec:perc}).  We will then lay the basis
for our mathematical modelling of types
(Section~\ref{sec:modelling}).  We introduce a notion of situation
type  (Section~\ref{sec:sittypes}) which will be important for the idea
that types are used to model propositions (discussed in
Section~\ref{sec:props-as-types}).  Included in the kinds of types we
use as situation types
are types constructed from predicates and their arguments
(\textit{ptypes}) and types which are collections of labelled fields
(\textit{record types}).


\section{Perception as type assignment}
\label{sec:perc}

Kim is out for a walk in the park and sees a tree.  She knows that it is a tree
immediately and does not really have to think anything particularly
linguistic, such as ``Aha, that's a tree''.  As a human being with
normal visual perception, Kim is pretty good at recognizing something
as a tree when she sees it, provided that it is a fairly standard
exemplar, and the conditions are right:  for example, there is enough
light and she is
not too far away or too close.  We shall say that Kim's perception of
a certain object, $a$, as a tree involves the ascription of a type
\textit{Tree} to $a$.  In terms of the kind of type theory discussed by
\cite{Martin-Loef1984,NordstromPeterssonSmith1990}, we might say that
Kim has made the \textit{judgement} that $a$ is of type \textit{Tree}
(in symbols, $a$ : \textit{Tree}).

% Central to type theory is the notion of judgements that an object $a$
% is of a type $T$ (in symbols $a:T$).  We see this as being
% fundamentally related to perception.

Objects can be of several types.  An object $a$ can be of type
\textit{Tree} but also of type \textit{Oak} (a subtype of
\textit{Tree}, since all objects of type \textit{Oak} are also of type
\textit{Tree}) and \textit{Physical Object} (a supertype of
\textit{Tree}, since all objects of type \textit{Tree} are of type
\textit{Physical Object}).  It might also be of an intuitively more complicated type like
\textit{Objects Perceived by Kim} which is neither a subtype nor a
supertype of \textit{Tree} since not all objects perceived by Kim are
trees and not all trees are perceived by Kim.

There is no perception without some kind of judgement
with respect to types of the perceived object.  When we say that we do
not know what an object is, this normally means that we do not have a
type for the object which is narrow enough for the purposes at hand.
I trip over something in the dark, exclaiming ``What's that?'', but my
painful physical interaction with it through my big toe tells me at
least that
it is a physical object, sufficiently hard and heavy to offer
resistance to my toe.  The act of perceiving an object is perceiving
it \textit{as} something.  You cannot perceive something without
ascribing some type to it, even if it is a very general type such as
\textit{thing} or \textit{entity}.

Recognizing something as a tree may be immediate and not involve
conscious reasoning.  Recognizing a tree as an aspen, an elm or a tree
with Dutch elm disease may involve closer inspection and some conscious
reasoning about the shape of the leaves or the state of the bark.  For
humans the relating of objects to certain types can be the result of a
long chain of reasoning involving a great deal of conscious effort.
But whether the perception is immediate and automatic or the result of
a conscious reasoning process, from a logical point of view it still
seems to involve the ascription of a type to an object.

 

The kind of types we are talking about here correspond to pretty much
any useful way of classifying things and they correspond to what might
be called properties in other theories.  For example, in the classical
approach to formal semantics developed by \cite{Montague1974} and
explicated by \cite{DowtyWallPeters1981} among many others, properties
are regarded not as types but as functions from possible worlds and
times to (the characteristic functions of) sets of entities, that is,
the property \textit{tree} would be a function from possible worlds
and times to the set of all entities which are trees at that world and
time.  Montague has types based on 
a version of Russell's \citeyearpar{Russell1903} simple theory of
types but they were ``abstract'' types like \textit{Entity} and
\textit{Truth Value} and types of functions based on these types
rather than ``contentful'' types like \textit{Tree}.  Type
theory for Montague was a way of providing basic mathematical
structure to the semantic system in a way that would allow the
generation of interpretations of infinitely many natural language
expressions in an orderly fashion that would not get into
problems with logical paradoxes.  The development of the theory of types which
we will undertake here can be regarded as an enrichment of an
``abstract'' type theory like Montague's with ``contentful'' types.
We want to do this in a way that allows the
types to account for content and relate to cognitive processing such
as perception.  We want our types to have psychological relevance and
to correspond to what \cite{Gibson1979} might call
\textit{invariants}, that is, aspects that we can perceive to be the
same when confronted with similar objects or the same object from a
different perspective.  In this respect our types are similar to
notions developed in situation theory and situation semantics
\citep{BarwisePerry1983,Barwise1989}.

Gibson's notion of attunement is adopted by Barwise and Perry.  The
idea is that certain organisms are attuned to certain invariants while
others are not.  Suppose that Kim perceives a cherry tree with flowers
and that a bee alights on one of the flowers.  One assumes that the bee's
experience of the tree is very different from Kim's.  It seems
unlikely that the bee perceives the tree as a tree in the sense that
Kim does and it is not at all obvious that the bee perceives the tree
in its totality as an object.  Different species are attuned to
different types and even within a species different individuals
may vary in the types to which they are attuned.  This means that our
perception is limited by our cognitive apparatus -- not a very
surprising fact, of course, but philosophically very important.  If
perception involves the assignment of types to objects and we are only
able to perceive in terms of those types to which we are attuned, then
as \cite{Kant1781} pointed out we are not actually able to be aware of
\textit{das Ding an sich} (``the thing itself''), that is, we are not
able to be aware of an object independently of the categories (or
types) which are available to us through our cognitive apparatus.
  

\section{Modelling type systems in terms of mathematical objects}
\label{sec:modelling}

In order to make our theory precise we are going to create
mathematical models of the systems we propose.  This
represents one  of the two main strategies that have been employed in
logic to create rigorous theories.  The other approach is to create a
formal language to describe the objects in the theory and define
rigorous rules of inference which explicate the properties of the
objects and the relations that hold between them.  At a certain level
of abstraction the two approaches are doing the same thing -- in order
to characterize a theory you need to say what objects are involved in
the theory, which important properties they have and what relations
they enter into.  However, the two approaches tend to get associated
with two different logical traditions: the \textit{model theoretic}
and \textit{proof theoretic} traditions.  

The philosophical foundation of type theory (as presented, for
example, by \citealp{Martin-Loef1984}) is normally seen as related to
intuitionism and constructive mathematics.  It is, at bottom,  a proof-theoretic
discipline rather than a model-theoretic one (despite the fact that model
theories have been provided for some type theories).  However, it seems that
many of the ideas in type theory that are important for the analysis
of natural language can be adopted into the classical set theoretic
framework familiar to linguists from the classical model-theoretic canon of formal
semantics starting from \cite{Montague1974}.  We
assume a standard underlying set theory such as ZF
(Zermelo-Fraenkel) with urelements (as formulated for example in \citealp{Suppes1960}).  This is what we take to be the
common or garden working set theory which is familiar from the core
literature on formal semantics deriving from Montague's original work.   

A theory is not very interesting if it does not
make \textit{predictions}, that is, by making certain assumptions you
can infer some conclusions.  This gives you one way to test your
theory:  see what you can conclude from premises that you know or
believe to be true and then test whether the conclusion is actually
true.  If you can show that your theory allows you to predict some
conclusion and its negation, then your theory is
\textit{inconsistent}, which means that it is not useful as a
scientific theory.  One way to discover whether a theory is consistent
or not is to formulate it very carefully and explicitly so that you
can show mathematical properties of the system and any
inconsistencies will appear. 

From the informal discussion of type theory that we have seen so far
it is clear that it should involve two kinds of entity:  the types and
the objects which are of those types.  (Here we use the word
``entity'' not in the sense that Montague did, that is, basic
individuals, but as an informal notion which includes both objects
and types.) This means that we should
characterize a type theory with two domains:
one domain for the objects of the types and another domain for the types to which
these objects belong.  Thus we see types as theoretical entities in
their own right, not, for example, as collections of the objects which
are object of the types.
Diagrammatically we can represent this as in Figure~\ref{fig:basic}
where object $a$ is of type $T_1$.
\begin{figure}[h]
%\includegraphics[width=\textwidth]{basic}
\begin{adjustbox}{max width=\textwidth}
\begin{tikzpicture}[
  type/.style={circle, inner sep=0pt, minimum size=6pt, ball color=BTypeCol},
  firsttype/.style={circle, inner sep=0pt, minimum size=6pt, ball color=FirstTypeCol},
  secondtype/.style={circle, inner sep=0pt, minimum size=6pt, ball color=SecondTypeCol},
  objects/.style={circle, inner sep=0pt, minimum size=6pt, ball color=ObjectCol},
  modalobjects/.style={circle, inner sep=0pt, minimum size=6pt, ball color=ModalCol}
  ]

  % basic types:
  \begin{scope}[
    % every node/.append style={yslant=0,xslant=1.75},
    yslant=0,xslant=1.75
    ]
    \filldraw [fill=BTypeCol, draw=BorderCol, thick, fill opacity=0.5] (0,0) rectangle (8,2);

    \foreach \x/\y in {0.5/1.3, 1.4/1.6, 1.8/1.3, 1.9/0.5, 3.3/1.8, 2.6/1.5, 4.4/0.9, 4.7/1, 5.5/0.3, 5.6/1.1, 5.5/1.7, 6.4/1.2, 6.7/1.6} {
      \node [type] at (\x,\y) {};
    }

    \node [coordinate] (btypeleft) at (0,1) {};
    \node [coordinate] (btyperight) at (8,1) {};

    \node [type, label=above:$T_1$] (t1) at (1.3,0.6) {};
    \node [type, label=above:$T_2$] (t2) at (3.1,0.5) {};
  \end{scope}    


  % objects:
  \begin{scope}[
    % every node/.append style={yslant=0,xslant=1.75},
    %yslant=0,xslant=1.75,
    yshift=-100
    ]
    \filldraw [fill=ObjectCol, opacity=0.4, draw=BorderCol, ultra thick] (5,0) ellipse (6 and 1);

    \foreach \a/\b in {5.5/0.7, 6.4/0.2, 6.7/0.6, 7/0, 7.5/0.35, 8/-0.3, 8.1/0.2, 8.7/0, 9/0.2, 10/0.1} {
      \node [objects] at (\a,\b) {};
    }
    % for T1 from BType:
    \node [modalobjects, label=above:$a$] (o1) at (0.3,-0.1) {}; 
    \node [objects] (o2) at (1,0.35) {}; 
    \node [objects] (o3) at (1.6,-0.2) {};
    \node [ellipse, fit=(o1) (o2) (o3), yscale=0.7, draw=BTypeCol, thick, fill=BTypeCol, fill opacity=0.3] (fitA) {};
    \draw [BTypeCol, thick] (t1) -- (fitA.east);
    \draw [BTypeCol, thick] (t1) -- (fitA.west);

    % for T2 from BType:
    \node [objects] (o4) at (2.6,-0.5) {};
    \node [objects] (o5) at (3.1,-0.5) {};
    \node [objects] (o6) at (3.3,-0.1) {};
    \node [ellipse, fit=(o3) (o4) (o5) (o6), yscale=0.7, draw=BTypeCol, thick, fill=BTypeCol, fill opacity=0.2] (fitB) {};
    \draw [BTypeCol, thick] (t2) -- (fitB.east);
    \draw [BTypeCol, thick] (t2) -- (fitB.west);

    % % for T2 from Type1:
     \node [objects] (o7) at (4,0.4) {};
     \node [objects] (o8) at (4.4,0) {}; 
     \node [objects] (o9) at (4.7,0.1) {};
    % \node [ellipse, fit=(o3) (o4) (o5) (o6) (o7) (o8) (o9), yscale=0.6, xscale=0.9, draw=FirstTypeCol, thick, fill=FirstTypeCol, fill opacity=0.2] (fitC) {};

    % % for T2 from Type2:
     \node [objects] (o10) at (5.5,-0.3) {};
     \node [objects] (o11) at (5.6,-0.1) {};
    % \node [ellipse, fit=(o3) (o4) (o5) (o6) (o7) (o8) (o9) (o10) (o11), yscale=0.7, xscale=0.8, draw=SecondTypeCol, thick, fill=SecondTypeCol, fill opacity=0.2] (fitD) {};
  \end{scope}


  % % modal types:
  % \begin{scope}[
  %   % every node/.append style={yslant=0,xslant=1.75},
  %   %yslant=0,xslant=1.75,
  %   yshift=-35, 
  %   xshift=220
  %   ]
  %   \filldraw [fill=ObjectCol, opacity=0.4, draw=BorderCol, ultra thick] (3.5,0) ellipse (4 and 0.75);

  %   \foreach \a/\b in {0.3/-0.1, 1.5/-0.3, 3.9/0.2, 7/0} {
  %     \node [objects] at (\a,\b) {};
  %   }
  %   \node [modalobjects, label=above:$a$] at (0.7,0) {};
  %   \node [objects] (i1) at (5.7,-0.2) {};
  %   \node [objects] (i2) at (6.1,0.3) {};
  %   \node [objects] (i3) at (5,0) {};
  %   \node [ellipse, fit=(i1) (i2) (i3), yscale=0.7, draw=BTypeCol, thick, fill=BTypeCol, fill opacity=0.2] {};

  %   \node [objects] (i4) at (1.6,0.1) {};
  %   \node [objects] (i5) at (2,0.2) {};
  %   \node [modalobjects, label=above:$b$] (i6) at (2.5,-0.3) {};
  %   \node [objects] (i7) at (2.7,0.35) {};
  %   \node [ellipse, fit=(i4) (i5) (i6) (i7), yscale=0.7, xscale=1.1, draw=BTypeCol, thick, fill=BTypeCol, fill opacity=0.2] {};
  % \end{scope}


  % % Type1:
  % \begin{scope}[
  %   % every node/.append style={yslant=0,xslant=1.75},
  %   yslant=0,xslant=1.75,
  %   xshift=-100,
  %   yshift=80
  %   ]
  %   \filldraw [fill=FirstTypeCol, draw=BorderCol, thick, fill opacity=0.3] (0,0) rectangle (8,2);
  %   \node [coordinate] (firsttypeleft) at (0,1) {};
  %   \node [coordinate] (firsttyperight) at (8,1) {};

  %   \foreach \x/\y in {0.45/1.4, 1.4/1.6, 1.9/0.5, 3.3/1.8, 2.6/1.5, 4.7/1, 5.5/0.3, 5.6/1.1,  6.7/1.6} {
  %     \node [firsttype] at (\x,\y) {};
  %   }

  %   \node [firsttype, label=above:$T_1$] (ft1) at (1.8,1.1) {};
  %   \node [firsttype, label=above:$T_2$] (ft2) at (5.8,0.7) {};
  %   \node [firsttype, label=above:$T_3$] (ft3) at (6.4,1.2) {};
  %   \node [firsttype, label=above:{\textbf{Type$^1$}}] (ft) at (4,0.4) {};

  %   \draw [FirstTypeCol, thick] (ft) -- (btypeleft);
  %   \draw [FirstTypeCol, thick] (ft) -- (btyperight);
    
  %   \draw [FirstTypeCol, thick] (ft2) -- (fitC.east);
  %   \draw [FirstTypeCol, thick] (ft2) -- (fitC.west);
  % \end{scope}    


  % % Type2:
  % \begin{scope}[
  %   % every node/.append style={yslant=0,xslant=1.75},
  %   yslant=0,xslant=1.75,
  %   xshift=-200,
  %   yshift=160
  %   ]
  %   \filldraw [fill=SecondTypeCol, draw=BorderCol, thick, fill opacity=0.1] (0,0) rectangle (8,2);
  %   \foreach \x/\y in {1.4/1.6, 1.9/0.5, 3.2/1.5, 4.7/1, 5.4/1.2, 5.8/0.3, 6/0.3,  6.2/1.6} {
  %     \node [secondtype] at (\x,\y) {};
  %   }

  %   \node [secondtype, label=above:$T_1$] (st1) at (1.2,1) {};
  %   \node [secondtype, label=above:$T_2$] (st2) at (4.8,0.7) {};
  %   \node [secondtype, label=above:$T_3$] (st3) at (2.6,1.3) {};
  %   \node [secondtype, label=above:{\textbf{Type$^2$}}] (st) at (3.4,0.5) {};

  %   \draw [SecondTypeCol, thick] (st) -- (firsttypeleft);
  %   \draw [SecondTypeCol, thick] (st) -- (firsttyperight);
    
  %   \draw [SecondTypeCol, thick] (st2) -- (fitD.east);
  %   \draw [SecondTypeCol, thick] (st2) -- (fitD.west);
  % \end{scope}    
\end{tikzpicture}
\end{adjustbox}

\caption{System of basic types}
\label{fig:basic}
\end{figure}

A system of basic types consists of a set of types which are \textit{basic} in
the sense that they are not analyzed as
\textit{complex} entities composed of other entities in the theory.
Each of these types is associated with a set of objects, that is, the
objects which are of the type, the \textit{witnesses} for the type.  Thus if $T$ is a type and $A(T)$ is the
set of witnesses for $T$, then $a$ is of type $T$ (in
symbols, $a:T$) just in case $a\in A(T)$.  We require that any object $a$
which is a witness for a basic type is not itself one of the types in
the system.  A type may be \textit{empty} in the sense that it is
associated with the empty set, that is, there is nothing of that
type. 

Notice that we are starting with the types and associating sets
of objects with them.  This means that while there can be types for
which there are no witnesses, there cannot be objects which do not
belong to a type.  This relates back to our claim in
Section~\ref{sec:perc} that we cannot perceive an object without
assigning a type to it.

Notice also that the sets of objects associated with types may have
members in common.  Thus it is possible for objects to belong to more
than one type.  This is important if we want to have basic types
\textit{Elm}, \textit{Tree} and \textit{Physical Object} and say that
a single object $a$ belongs to all three types as discussed in
Section~\ref{sec:perc}.

An extremely important property of this kind of type system is that
there is nothing which prevents two types from being associated with
exactly the same set of objects.  In standard set theory the notion of
set is \textit{extensional}, that is sets are defined by their
membership.  You cannot have two distinct sets with the same members.
The choice of defining types as entities in their own right rather
than as the sets of their witnesses, means that they can be
\textit{intensional}, that is, you can have more than one type with
the same set of witnesses.  This can be important for the analysis of
natural language words like \textit{groundhog} and \textit{woodchuck}
which (as I have learned from the literature on natural language
semantics) are the same animal. In this case one may wish to say that
you have two different words which correspond to the same type, rather
than two types with the same \textit{extension} (that is, set of
witnesses).  Such an analysis is less appealing in the case of
\textit{unicorn} and \textit{centaur}, both mythical animals
corresponding to types which have an empty extension.  If types were
extensional, there would only be one empty type (just as there is only
one empty set in set theory).  In the kind of possible world semantics
espoused by Montague the distinction between \textit{unicorn} and
\textit{centaur} was made by considering their extension not only in
the actual world (where both are empty) but also in all possible
worlds, since there will be some worlds in which the extensions are
not the same.
However, this kind of possible worlds analysis of intensionality fails
when you have types whose extensions cannot possibly be different.
Consider \textit{round square} and \textit{positive number equal to
  $2-5$}.  The possible worlds analysis cannot distinguish between
these since their extensions are both empty no matter which possible
world you look at.

Finally, notice that there may be different systems of basic types,
possibly with different types and different objects.  One way of
exploiting this would be to associate different systems with different
organisms as discussed in Section~\ref{sec:perc}.  (Later in this book we will see
different uses of this for the analysis of types which model the
cognitive system of a single
agent.) Thus properly we should say that an object $a$ is of type $T$
with respect to a basic systems of types {\bf TYPE$_B$}, in symbols,
$a:_{\mathbf{TYPE_B}}T$.  However,  we will continue
to write $a:T$ in our informal discussion when there is no danger of
confusion. 

\begin{shaded}
The definition of a system of basic types is made precise in
\nexteg{}, which is repeated in
Appendix~\ref{sec:basic}.  

\begin{ex}
A {\it system of basic types\/} is a pair:
\begin{quote}
{\bf TYPE$_B$} = $\langle${\bf Type}, $A$$\rangle$
\end{quote}
where:
\begin{enumerate} 
 
\item \textbf{Type} is a non-empty set 
 
\item $A$ is a function whose domain is \textbf{Type}

\item for any $T\in\textbf{Type}$, $A(T)$ is a set disjoint from
  \textbf{Type}

\item for any $T\in\textbf{Type}$, $a:_{\mathbf{TYPE_B}}T$ iff $a\in A(T)$
 
\end{enumerate}

\label{ex:def-basic-types}
\end{ex} 

Some readers may prefer a slightly less formal characterization which
uses the kind of format normally employed in proof theory.  This may
provide a more easily readable overview of the definitions while
suppressing some of the details which are not necessary for intuitive
understanding.  We will use $\Gamma$, normally used for contexts in
proof theory, that is sequences of judgements to refer to type systems
like those characterized in \preveg{}.  Thus in \nexteg{} $\Gamma$
corresponds to \textbf{TYPE}$_B$.  We will write
$\Gamma\vdash T\in\textbf{Type}$ ``$T\in\textbf{Type}$ follows from
$\Gamma$'' to represent that \textbf{Type} is the set of types in
$\Gamma$  as
specified in \preveg{} and that the type $T$ is a member of this set.
We will similarly write $\Gamma\vdash a\in A(T)$ to indicate that
object $a$ is in the set assigned to $T$ by the function $A$ given by $\Gamma$.
We can then write a rule as in \nexteg{}.
\begin{ex} 
For $\Gamma$ a system of basic types:

\begin{prooftree}
\hypo{\Gamma\vdash T\in \textbf{Type}} \hypo{\Gamma\vdash a\in A(T)}
\infer2{\Gamma\vdash a:T}
\end{prooftree} 
\end{ex} 
We take this to be an inductive definition of the set of consequences.
That is, we are characterizing the smallest set of judgements
$\Gamma\vdash a:T$ which obey the premises.  In this way the inference
rule \preveg{} has the force of a biconditional corresponding to
clause~4 in (\ref{ex:def-basic-types}).   
\end{shaded}

What counts as an object may vary from agent to agent
(particularly if agents are of different species).  Different agents
have what \cite{Barwise1989} would call different \textit{schemes
  of individuation}.  There appears to be a complex relationship
between the types that an agent is attuned to and the parts of the
world which the agent will perceive as an object.  We model this in
part by allowing different type systems to have different
objects.  In addition we will make extensive use in our systems of a
basic type \textit{Ind} for ``individual'' which corresponds to
Montague's notion of ``entity''.  The type \textit{Ind} might be
thought of as modelling a large part of an agent's scheme of
individuation in Barwise's sense.  However, this clearly still leaves
a great deal to be explained and we do this in the hope that exploring the nature of the type
systems involved will ultimately give us more insight into how
individuation is achieved.


\section{Situation types}
\label{sec:sittypes}

Kim continues her walk in the park.  She sees a boy playing with a dog
and notices that the boy gives the dog a hug.  In perceiving this
event she is aware that two individuals are involved and that there is
a relation holding between them, namely hugging.  She also perceives
that the boy is hugging the dog and not the other way around.  She
sees that a certain action (hugging) is being performed by an agent
(the boy) on a patient (the dog).  This perception seems more complex
than the classification of an individual object as a tree in the sense
that it involves two individual participants and a relation between
them as well as the roles those two individuals play in the relation.
While it is undoubtably more complex than the simple classification of
an object as a tree, we want to say that it is still the assignment of
a type to an object.  The object is now an event and she classifies
the event as a hugging event with the boy as agent and the dog as
patient.  We shall have complex types which can be assigned to such events.

\textit{Complex} types are constructed out of
other entities in the theory.  As we have just seen,
cognitive agents, in addition to being able to assign types to
individual objects like trees, also perceive the world in terms of states and
events where objects have properties and stand in relations to each
other -- what \cite{Davidson1967} called events and
\cite{BarwisePerry1983} called situations.  

\subsection{Types constructed from predicates (ptypes)}
\label{sec:ptypes}
We
introduce types which are constructed from predicates (like `hug') and
objects which are arguments to this predicate like $a$ and $b$.  We
will represent such a constructed type as hug($a$,$b$) and we will
call it a \textit{ptype} to indicate that it is a type whose
main constructor is a predicate.  What would an
object belonging to such a type be?  According to the type-theoretic
approach introduced by Martin-Löf it should be an object which
constitutes a proof that $a$ is hugging $b$.  For Martin-Löf, who was
considering mathematical predicates, such proof objects might be numbers
with certain properties, ordered pairs and so on.  \cite{Ranta1994}
points out that for non-mathematical predicates the objects could be
events as conceived by \cite{Davidson1967,Davidson1980}.  Thus hug($a$,$b$) can be
considered to be an event or a situation type.  In some versions of
situation theory \cite{Barwise1989,SeligmanMoss1997}, objects (called \textit{infons})
constructed from a relation and its arguments was considered to be one
kind of situation type.  Thus one view would be that 
ptypes are playing a similar role in type theory to the role that
infons play in situation theory.

What kind of entity are predicates?  \ignore{The notion is made precise in
Appendix~\ref{app:predicates}.}  One important fact about predicates
is that they come along with an \textit{arity}.  The arity of a
predicate tells you what kind of arguments the predicate takes and
what order they come in. For us the arity of a predicate will be a
sequence of types.  The predicate `hug' as discussed above we can
think of as a two-place predicate both of whose arguments must be of
type \textit{Ind}, that is, an individual.  Thus the arity of `hug'
will be $\langle$\textit{Ind}, \textit{Ind}$\rangle$.  The idea is
that if you combine a predicate with arguments of the appropriate
types in the appropriate order indicated by the arity then you will
have a type.  Thus if $a$ : \textit{Ind} and $b$ : \textit{Ind} then
hug($a$,$b$) will be a type, intuitively the type of situation where
$a$ hugs $b$.  

\begin{shaded}
We will introduce a function \textit{Arity} which is
defined on predicates and which assigns an arity to any predicate.
This function is introduced in a \textit{predicate signature} which in
addition tells you what predicates there are and what we can use to
characterize their arguments (a set of types in the way we will use
this. We define a predicate signature by the definition in \nexteg{}
(repeated in Appendix~\ref{app:predicates}).
\begin{ex} 
A \textit{predicate signature} 
is a triple
\begin{quote}
$\langle$\textbf{Pred}, \textbf{ArgIndices}, \textit{Arity}$\rangle$
\end{quote}
where:
\begin{enumerate} 
 
\item \textbf{Pred} is a set (of predicates)

\item \textbf{ArgIndices} is a set (of indices for predicate
  arguments, normally types)
 
\item \textit{Arity} is a function with domain \textbf{Pred} and range
  included in the set of finite sequences of members of \textbf{ArgIndices}. 
 
\end{enumerate}
\label{ex:pred-sig} 
\end{ex}
A simple example of a predicate signature would be given by \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item \textbf{Pred} = \{boy, dog, hug\} 
 
\item \textbf{ArgIndices} = \{\textit{Ind}\}

\item \textit{Arity} is defined by:
\begin{quote}
\textit{Arity}(boy) = $\langle\textit{Ind}\rangle$\\
\textit{Arity}(dog) = $\langle\textit{Ind}\rangle$\\
\textit{Arity}(hug) = $\langle\textit{Ind}, \textit{Ind}\rangle$
\end{quote} 
 
\end{subex} 
   
\end{ex} 
   
  

It may be desirable to allow some predicates to combine with more than
one assortment of argument types.  Thus, for example, one might wish
to say that the predicate `believe' can combine with two individuals
just like `hug' (as in \textit{Kim believes Sam}) or with an
individual and a ``proposition'' (as in \textit{Kim believes that Sam
  is telling the truth}).  Similarly the predicate `want' might be
both a two-place predicate for individuals (as in \textit{Kim wants
  the tree}) or a two-place predicate between individuals and
``properties'' (as in \textit{Kim wants to own the tree}).  We shall
have more to say about ``propositions'' and ``properties'' later.  For
now, we just note that we want to allow for the possibilities that
predicates can be \textit{polymorphic} in the sense that there may be
more than one sequence of types which characterize the arguments they
are allowed to combine with.  The sequences need not even be of the
same length (consider \textit{Kim walked} and \textit{Kim walked the
  dog}).  We thus allow for the possibility that these pairs of natural
language examples can be treated using the same polymorphic
predicate.  Another possibility, of course, is to say that the English
verbs can correspond to different (though related) predicates in the
example pairs and not allow this kind of predicate polymorphism in the
type theory. We do not take a stand on this issue but merely note that
both possibilities are available.  If predicates are to be considered
polymorphic then the arity of a predicate can be considered to be a
set of sequences of types.  In \nexteg{} we give a definition of
a polymorphic predicate signature (repeated in Appendix~\ref{app:predicates}).
\begin{ex} 
A \textit{polymorphic predicate signature} 
is a triple 
\begin{quote}
$\langle$\textbf{Pred}, \textbf{ArgIndices}, \textit{Arity}$\rangle$
\end{quote}
where:
\begin{enumerate} 
 
\item \textbf{Pred} is a set (of predicates)

\item \textbf{ArgIndices} is a set (of indices for predicate
  arguments, normally types)
 
\item \textit{Arity} is a function with domain \textbf{Pred} and range
  included in the powerset of the set of finite sequences of members
  of \textbf{ArgIndices}. 
 
\end{enumerate}
\label{ex:poly-pred-sig} 
\end{ex} 
A simple example of a polymorphic predicate signature is given in
\nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item \textbf{Pred} = \{boy, dog, hug, walk\} 
 
\item \textbf{ArgIndices} = \{\textit{Ind}\}

\item \textit{Arity} is defined by:
\begin{quote}
\textit{Arity}(boy) = $\{\langle\textit{Ind}\rangle\}$\\
\textit{Arity}(dog) = $\{\langle\textit{Ind}\rangle\}$\\
\textit{Arity}(hug) = $\{\langle\textit{Ind}, \textit{Ind}\rangle\}$\\
\textit{Arity}(walk) = $\{\langle\textit{Ind}\rangle, \langle\textit{Ind}, \textit{Ind}\rangle\}$
\end{quote} 
 
\end{subex} 
   
\end{ex}   

An alternative to our characterization of predicates is to consider them as functions from sequences of objects
matching their arity to types.  As such they would be a
\textit{dependent type}, that is, an entity which returns a type when
provided with an appropriate object or sequence of objects.  However,
we have not done this because we want all those entities we call
dependent types to be representable as $\lambda$-expressions.  We can,
however, think of them as \textit{type constructors} as will be made
clear in our discussion of systems of complex types below.

A \textit{system of complex types} \ignore{(made precise in Appendix~\ref{app:comptypes})}
adds to a system of basic types a collection of types constructed from
a set of predicates with their arities, that is, it adds all the types
which you can construct from the predicates by combining them with
objects of the types corresponding to their arities according to the
types in the rest of the system.  The system also assigns a set of
objects to all the types thus constructed from predicates.  Many of
these types will be assigned the empty set.  Intuitively, if we have a
type hug($c$,$d$) and there are no situations in which $c$ hugs $d$
then there will be nothing in the extension of hug($c$,$d$), that is,
it will be assigned the empty set in the system of complex types.
Notice that the intensionality of our type system becomes very
important here.  There may be many individuals $x$ and $y$ for which
hug($x$,$y$) is empty but still we would want to say that the types
resulting from the combination of  `hug'
with the various different individuals corresponds to
different types of situations.  The formal characterization of a
system of complex types is given in \nexteg{} (repeated in
Appendix~\ref{app:comptypes}).
\begin{ex} 
A {\it system of complex types\/} is a quadruple:
\begin{quote}
{\bf TYPE$_C$} = $\langle${\bf Type}, {\bf BType},
$\langle$\textbf{PType}, {\bf Pred}, \textbf{ArgIndices}, {\it Arity\/}$\rangle$, $\langle A,F\rangle$$\rangle$
\end{quote}
where:  
\begin{enumerate} 
 
\item $\langle$\textbf{BType}, $A$$\rangle$ is a system of basic types 
 
\item \textbf{BType}$\subseteq$\textbf{Type}

\item for any $T\in\textbf{Type}$, if $a:_{\langle\mathbf{BType},
    A\rangle}T$ then $a:_{\mathbf{TYPE_C}}T$

\item \label{cl:predtypes}$\langle${\bf Pred}, \textbf{ArgIndices},
  {\it Arity\/}$\rangle$ is a (polymorphic) predicate
  signature

\item\hspace*{-1ex}\ignore{\footnote{This clause has been modified since
    \cite{Cooper2012} where it was a conditional rather than a biconditional.}} %\sloppy  
  $P(a_1,\ldots a_n)\in\textbf{PType}$ iff $P\in\textbf{Pred}$, $T_1\in \mathbf{Type},\ldots,T_n\in
  \mathbf{Type}$, \textit{Arity}($P$)=$\langle
  T_1,\ldots,T_n\rangle$  ($\langle
  T_1,\ldots,T_n\rangle$$\in$\textit{Arity}($P$)) and $a_1:_{\mathbf{TYPE_C}}T_1,\ldots,a_n:_{\mathbf{TYPE_C}}T_n$

% If $P\in\textbf{Pred}$, $T_1\in \mathbf{Type},\ldots,T_n\in
%   \mathbf{Type}$, \textit{Arity}($P$)=$\langle
%   T_1,\ldots,T_n\rangle$  ($\langle
%   T_1,\ldots,T_n\rangle$$\in$\textit{Arity}($P$)) and $a_1:_{\mathbf{TYPE_C}}T_1,\ldots,a_n:_{\mathbf{TYPE_C}}T_n$ then
%   $P(a_1,\ldots a_n)\in\textbf{PType}$



\item \textbf{PType}$\subseteq$\textbf{Type}

\item for any $T\in\textbf{PType}$, $F(T)$ is a set disjoint from \textbf{Type}

\item for any $T\in\textbf{PType}$, $a:_{\mathbf{TYPE_C}}T$ iff $a\in F(T)$
 
\end{enumerate} 
\label{ex:comp-types}
\end{ex} 
\preveg{} perhaps looks a little forbidding for something that says
that if you have a predicate $P$ whose arity is $\langle
T_1,\ldots,T_n\rangle$ and you have objects $a_1:T_1,\ldots,a_n:T_n$
then $P(a_1,\ldots,a_n)$ is a ptype and any ptype is also a type.  In
this definition we have not made explicit exactly what set theoretic
object we are representing with $P(a_1,\ldots,a_n)$.  We will take
this up below (in Section~\ref{sec:labelled-sets}) since it is part of
a general strategy we employ for representing entities in our type
theory as sets.  
\preveg{} also gives us a function $F$ which maps ptypes to a set of
witnesses and it also makes clear that a system of complex types adds
to a system of basic types.  The set of types of the new system
consists of the basic types and the ptypes.  Perhaps the informal
proof theoretic notation in \nexteg{} is a little less forbidding.
\begin{ex}
For $\Gamma$ a system of complex types: 
\begin{subex} 
 
\item  \begin{prooftree}
\hypo{\Gamma\vdash T\in\textbf{BType}} \hypo{\Gamma\vdash a\in A(T)}
\infer2{\Gamma\vdash a:T}
\end{prooftree}
 
\item \begin{prooftree}
\hypo{\Gamma\vdash T\in \textbf{BType}} \infer1{\Gamma\vdash
  T\in\textbf{Type}}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma\vdash P\in\textbf{Pred}} \hypo{\Gamma\vdash \langle
  T_1,\ldots,T_n\rangle=\textit{Arity}(P)} \hypo{\Gamma\vdash
  a_1:T_1,\ldots,\Gamma\vdash a_n:T_n} \infer3{\Gamma\vdash
  P(a_1,\ldots,a_n)\in\textbf{PType}}
\end{prooftree}

\medskip

or alternatively if we are considering our predicates to be
polymorphic:

\medskip

\begin{prooftree}
\hypo{\Gamma\vdash P\in\textbf{Pred}} \hypo{\Gamma\vdash \langle
  T_1,\ldots,T_n\rangle\in\textit{Arity}(P)} \hypo{\Gamma\vdash
  a_1:T_1,\ldots,\Gamma\vdash a_n:T_n} \infer3{\Gamma\vdash
  P(a_1,\ldots,a_n)\in\textbf{PType}}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma\vdash T\in\textbf{PType}} \infer1{\Gamma\vdash
  T\in\textbf{Type}}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma\vdash T\in\textbf{PType}} \hypo{\Gamma\vdash s\in F(T)}
\infer2{\Gamma\vdash s:T}
\end{prooftree} 
 
\end{subex} 
   
\end{ex} 
\preveg{a} is the rule that we had for basic type systems except that
we have identified the relevant set of types as \textbf{BType} (the
basic types).  \preveg{b} tells us that \textbf{BType} is a subset of
\textbf{Type}. \preveg{c} tells us how to form ptypes from a predicate
and an appropriate sequence of objects. \preveg{d} tells us that
ptypes are types.  \preveg{e} tells us that the witnesses of ptypes
are determined by the function $F$.
  

There are thus two important functions
in a system of complex types:  one, which we call $A$, which comes from
the system of basic types embedded in the system and assigns
extensions to basic types and the other, which we call $F$, which
assigns extensions to types constructed from predicates and arguments
corresponding to the arity of the predicates.  We have chosen the
letters $A$ and $F$ because they are used very often in the
characterization of models \label{pg:models} of first order logic.  A model for first
order logic is often characterized as a pair $\langle A,F\rangle$
where $A$ is the domain and $F$ a function which assigns denotations to
the basic expressions (constants and predicates) of the logic.  In a
slight variation on classical first order logic $A$ may be a sorted
domain, that is the domain is not a single set but a set divided into
various subsets, corresponding to \textit{sorts}. For
us, $A$ characterizes assignments to basic types and thus provides
something like a sorted domain in first order model theory.  In first
order logic $F$ gives us what we need to know to determine the truth
of expressions like `hug($a$,$b$)' in first order logic.  Thus $F$ will
assign to the predicate `hug' a set of ordered pairs telling us who
hugs whom.  Our $F$ also give us the information we need in order to
tell who stands in a predicate relation.  However, it does this, not
by assigning a set of ordered $n$-tuples to each predicate, but by
assigning sets of witnesses (or ``proofs'') to each type constructed from a predicate with
appropriate arguments.  The set of ordered pairs assigned to `hug' by
the first order logic $F$ corresponds to the set of pairs of arguments
$\langle x,y\rangle$ for which the $F$ in a complex system of types
assigns a non-empty set.  For this reason we call the pair $\langle
A,F\rangle$ a \textit{model} within the type system, even though it is not
technically a model in the sense of model theory for logic.  The
correspondence becomes important later in the book, when we talk about modal type
systems.
\end{shaded}

What are the entities which are witnesses for ptypes?  The intuition is
that, for example, \nexteg{} means that $e$ is an event or situation where the individual $a$ is
running.
\begin{ex}
$e$ : run($a$)
\end{ex}
There are two competing intuitions about what $e$ could be.
One is that it is a ``part of the world'', a non-set (urelement).  That is, from
the perspective of set theory and the theory of types it is an unstructured
atom.  The other intuition we have is that it is a structured entity which
contains $a$ as a component and in which a running activity is going
on which involves smaller events such as picking feet up off the
ground, spending certain time in each step cycle with neither foot
touching the ground and so on.  We want to allow for both of these
intuitions.  That is, a witness for a ptype can be a non-set
corresponding to our notion of an event of a certain type.  Or it can
be the kind of labelled set which we call a record (see
Section~\ref{sec:rectypes}).  That is, $e$ is not only a witness for
the type `run($a$)' but also for a record type which
characterizes in more detail the structure of the event.  We will
argue that both intuitions are important and that
observers of the world shift between views where certain
ptypes are regarded as types of non-sets and views where those
ptypes are types of records.

The introduction of predicates  and ptypes raises
the question of how one-place predicates relate to basic types.  For
example, what is the relationship between a type \textit{Dog} whose
witnesses are dogs and a predicate `dog' whose arity is
$\langle\textit{Ind}\rangle$.  One way to relate the two is given in
\nexteg{}.
\begin{ex} 
$a:\textit{Dog}$ iff $\exists e\ e:\text{dog}(a)$ 
\end{ex} 
\preveg{} says that something is of type \textit{Dog} just in case
there is a situation which shows it to fall under the predicate
`dog'. In this book we will relate common nouns to predicates rather
than basic types, in part because common nouns can sometimes have
more than one argument and in part because we want to limit the number
of basic types we use.  If we need a type we can derive it from the
predicate using something like \preveg{}.

% We said above that the arity of `hug' is
% $\langle$\textit{Ind},\textit{Ind}$\rangle$.  However, when we look at
% (\ref{eg:rectype}b) where the types labelled with `x' and `y' are
% \textit{Boy} and \textit{Dog} we see that there is nothing explicit here that
% requires that the two arguments of `hug' are of type \textit{Ind}.
% One obvious way to achieve this would be to require that \textit{Boy}
% and \textit{Dog} are subtypes of \textit{Ind}, that is, that any
% object of type \textit{Boy} is also of type \textit{Ind} and similarly
% for \textit{Dog}.  However, now that we have introduced predicates
% there is nothing to stop us having two predicates `boy' and `dog' with
% arity $\langle$\textit{Ind}$\rangle$.  Thus we could have the record
% type \nexteg{}.
% \begin{ex} 
% \record{\tfield{x}{\textit{Ind}} \\
%         \tfield{c$_{\mathrm{boy}}$}{boy(x)} \\
%         \tfield{y}{\textit{Ind}} \\
%         \tfield{c$_{\mathrm{dog}}$}{dog(y)} \\
%               \tfield{c$_{\mathrm{hug}}$}{hug(x,y)}} 
% \end{ex} 
% How do we choose between a type like \preveg{} where common nouns like
% \textit{boy} and \textit{dog}
% correspond to one-place predicates and a type like
% (\ref{eg:rectype}{b}) where common nouns correspond to basic types?
% One advantage is that \preveg{} explicitly represents that the arity
% of `hug' is fulfilled.  Another advantage is that many, and on some
% analyses possibly all,
% nouns in natural languages will in more detailed treatments correspond
% to predicates of more than one argument.  Consider, for example, the
% fact that boys grow into men.  The same individual can be a boy at one
% time and a man at a later time.  One way of treating this is to say
% that  `boy' is a predicate of
% two arguments with arity
% $\langle$\textit{Ind},\textit{Time}$\rangle$.  In fact if we are going
% to deal with tense and aspect in natural language in this way we will probably
% want to add time arguments to most if not all of our predicates and
% thus allow ourselves record types like \nexteg{}.
% \begin{ex} 
% \record{\tfield{e-time}{\textit{Time}} \\
% \tfield{x}{\textit{Ind}} \\
%         \tfield{c$_{\mathrm{boy}}$}{boy(x,e-time)} \\
%         \tfield{y}{\textit{Ind}} \\
%         \tfield{c$_{\mathrm{dog}}$}{dog(y,e-time)} \\
%               \tfield{c$_{\mathrm{hug}}$}{hug(x,y,e-time)}} 
% \end{ex} 
% where `e-time' stands for ``event time''.  Here we have required that
% the times in all the predicate fields be the event time but this is
% not always the case.  Consider \nexteg{}.
% \begin{ex} 
% The minister smoked pot in his youth 
% \end{ex} 
% Here the time of the pot-smoking event most likely precedes 
% the time of the pot-smoking individual being a minister. We will thus
% use our basic types for basic ontological categories like \textit{individual}
% and \textit{time} and use predicates for words that occur in natural
% language.  Predicates can be $n$-ary whereas our types will always be
% unary.  Note that a ptype like hug($a$,$b$,$t$) is constructed from a
% ternary predicate `hug' but the type itself is a unary type of
% situations.  Thus we might have the judgement $s$ : hug($a$,$b$,$t$).

% Below we will propose an alternative to this treatment of
% time as an argument.  There is, however, another reason for allowing predicates
% corresponding to nouns to have more than one argument.  This is the existence of relational nouns such as \textit{friend}
% or \textit{daughter}.  (See \citealp{ParteeBorschev2012} for recent
% discussion.)

% In this book we will reserve basic types for two kinds of types:  (i)
% those which correspond to intuitively fundamental ontological categories
% such as individual and (ii) those types which require a recursive
% definition to characterize the set of their witnesses.  The latter is
% for a technical reason:  defining recursive types as, for instance,
% record types could lead to the types themselves being a
% non-well-founded set of ordered pairs which contain themselves.  We
% will discuss this more (????) when recursive types become relevant.

\begin{shaded}
\subsection{Representing complex entities as labelled sets}
\label{sec:labelled-sets}
When we characterized ptypes in Section~\ref{sec:ptypes}, we did not
make explicit exactly which set-theoretic entity we were representing
by the notation for a ptype `$P(a_1,\ldots,a_n)$'.  In general complex
entities in our theory will be a particular kind of set.

We introduce a notion \textit{labelled sets} to model our complex entities. We
will assume that our set theory comes equipped with a set of
\textit{urelements} (entities which are not sets but which can be
members of sets).  We will assume that among the urelements is a countably infinite
set which is designated as the set of labels.  A \textit{labelled set}
(see also Appendix~\ref{app:sets}) is a set
of ordered pairs whose first member is a label and whose second
element is either an urelement which is not a label or a set (possibly a labelled
set), such that no more than one ordered pair can contain any
particular label as its first member.  This means that a labelled set
is the traditional set theoretic construction of an extensional
function from a set of labels onto some set.  Suppose that we have a
set \nexteg{a}
and that $\ell_0,\ell_1,\ell_2,\ell_3$ are labels.  Then examples of
labelled sets which are \textit{labellings} of \nexteg{a} would be \nexteg{b
  and c}.
\begin{ex} 
\begin{subex} 
 
\item $\{a,b,c,d\}$ 
 
\item
  $\{\langle\ell_0,a\rangle,\langle\ell_1,b\rangle,\langle\ell_2,c\rangle,\langle\ell_3,d\rangle\}$

\item $\{\langle\ell_0,\{\langle\ell_0,a\rangle,\langle\ell_1,b\rangle\}\rangle,\langle\ell_2,c\rangle,\langle\ell_3,d\rangle\}$ 
 
\end{subex} 
\label{ex:labelled-sets}   
\end{ex} 

We will also sometimes have need of adding flavours to our labelled
sets when we need to model distinct objects which correspond to the
same set of ordered pairs.  We will assume that there is a finite or
countably infinite set of flavours among the urelements and that this
set is disjoint from the set of labels.  A flavoured labelled set
contains a single flavour, $\mathfrak{f}$, in addition to the ordered
pairs.  Thus the labelled sets in \nexteg{} are examples of labelled
sets with flavour $\mathfrak{f}$.

\begin{ex} 
\begin{subex} 
 
\item $\{\mathfrak{f},\langle\ell_0,a\rangle,\langle\ell_1,b\rangle,\langle\ell_2,c\rangle,\langle\ell_3,d\rangle\}$ 
 
\item $\{\mathfrak{f},\langle\ell_0,\{\langle\ell_0,a\rangle,\langle\ell_1,b\rangle\}\rangle,\langle\ell_2,c\rangle,\langle\ell_3,d\rangle\}$  
 
\end{subex} 
   
\end{ex} 
  

We will refer to the first members of the pairs in a
labelled set as \textit{labels} used in the labelled set and we will refer to
the second members of the ordered pairs as the \textit{labelled
  elements} of the labelled set.  If $X$ is a labelled set, we will
use $\mathrm{labels}(X)$ to represent the set of labels of $X$, that is,
the left projection of $X$ which means the set of objects which are
first members of the set of ordered pairs which are members of $X$.
Note that this means that if $X$ is the labelled set \preveg{c}, then
$\mathrm{labels}(X)$ is $\{\ell_0,\ell_2,\ell_3\}$, that is, the set of
those labels which occur at the topmost level of $X$, not including the set of
labels that occur within a labelled set contained in $X$, which in
this case would in addition include the label $\ell_1$.  If $X$ is a
labelled set and $\ell\in\mathrm{labels}(X)$ we will use $X.\ell$ to
represent the entity labelled by $\ell$.  Thus if $X$ is \preveg{b},
$X.\ell_0$ is $a$.  We can also define the set of \textit{paths} in
labelled sets given by the definition in \nexteg{}.
\begin{ex} 
If $X$ is a labelled set, then
\begin{enumerate} 
 
\item if $\ell\in\mathrm{labels}(X)$, then $\ell\in\mathrm{paths}(X)$ 
 
\item if $\ell\in\mathrm{labels}(X)$, $X.\ell$ is a labelled set and
  $\pi\in\mathrm{paths}(X.\ell)$, then $\ell.\pi\in\mathrm{paths}(X)$
\end{enumerate}  
\end{ex} 
By this definition the set of paths in (\ref{ex:labelled-sets}c) is
\nexteg{}.
\begin{ex} 
$\{\ell_0,\ell_2,\ell_3,\ell_0.\ell_0,\ell_0.\ell_1\}$ 
\end{ex} 
Note also that by these definitions, if $X$ is
(\ref{ex:labelled-sets}c), then $X.\ell_0.\ell_0$ is $a$, that is, we
can use the dot notation to take us down to a value on any path in the
labelled set.   

There are various ways in which labelled sets could be represented
graphically.  One way to represent the examples in (\ref{ex:labelled-sets}b and c)
would be as in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item \mbox{\Tree [.$\ell_0$ \{$a$, ]\hspace*{1em} \Tree [.$\ell_1$ $b,$ ]\hspace*{1em} \Tree
  [.$\ell_2$ $c,$ ]\hspace*{1em} \Tree [.$\ell_3$ $d$\} ]}
 
\item \mbox{\Tree [.$\ell_0$ [.$\ell_0$ \{$a$, ] [.$\ell_1$ $b$, ] ]}  \raisebox{-2.054em}{\hspace*{1em}\Tree
  [.$\ell_2$ $c,$ ]\hspace*{1em} \Tree [.$\ell_3$ $d$\} ]}


 
\end{subex} 
   
\end{ex} 
  
  
Labelled sets where we identify particular distinguished labels will
always give us enough structure to model the structured entities that
we need and define operations on them as required by our theory of types.

The entity 
represented by $P(a_1,\ldots a_n)$ is the
labelled set in \nexteg{} where `pred', `arg$_i$' are reserved labels
(that is, not used except as
required here).
\begin{ex}
$\{\langle\mathrm{pred},P\rangle,\langle\mathrm{arg}_1,a_1\rangle,\ldots,\langle\mathrm{arg}_n,a_n\rangle\}$
\end{ex}
\end{shaded}


\subsection{Record types}
\label{sec:rectypes}
Kim sees a situation where $a$ (the boy) hugs $b$ (the dog) and
perceives it to be of type `hug($a$,$b$)'.  However, there are
intuitively other types which she could assign to this situation other
than the type of situation where $a$ hugs $b$ which is represented
here.  For example, a more general type, which would be useful in
characterizing all situations where hugging is going on between any
individuals, is that of ``situation where one
individual hugs another individual''.  Another type of situation she
might use is that of ``situation where a boy hugs a dog''.  This is a
more specific type than ``situation where one
individual hugs another individual'' but still does not tie us down to
the specific individuals $a$ and $b$ as the type `hug($a$,$b$)' does.

There are at least two different ways in type theory to approach
these more general types.  One is to use \textit{$\Sigma$-types} \label{pg:sigmatypes} such
as \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item $\Sigma x$:\textit{Ind}.$\Sigma y$:\textit{Ind}.hug($x$,$y$)
 
\item $\Sigma x$:\textit{Boy}.$\Sigma y$:\textit{Dog}.hug($x$,$y$) 
 
\end{subex} 
   
\end{ex}
% \preveg{b} uses the types \textit{Boy} and \textit{Dog} but we could
% also use ptypes constructed from the predicates `boy' and `dog' as
% discussed in Section~\ref{sec:ptypes} as in \nexteg{}.
% \begin{ex} 
% $\Sigma x$:\textit{Ind}.$\Sigma s_1$:boy($x$).$\Sigma
% y$:\textit{Ind}.$\Sigma s_2$:dog($y$).hug($x$,$y$) 
% \end{ex} 
  
We will use the notation $T\dep{x_1,\ldots,x_n}$ to represent that the
type $T$ depends on $x_1,\ldots,x_n$.  For example, the types
`hug($x$,$y$)' represented within the expressions in \preveg{} depend
on $x$ and $y$.
In general $\Sigma
x$:$T_1.T_2\dep{x}$ will have as witnesses any ordered pair the first
member of which is a witness for $T_1$ and the second member of which
is a witness for $T_2\dep{x}$.  Thus this type will be non-empty
(``true'') just in case there is something $a$ of type $T_1$ such that
there is something of type $T_2\dep{a}$.  This means that $\Sigma$-types
correspond to existential quantification.  A witness for \preveg{a} would be $\langle a,
\langle b, s\rangle\rangle$ where $a$:\textit{Ind}, $b$:\textit{Ind}
and $s$:hug($a$,$b$).  If there is such a witness then some individual
hugs another individual and conversely if some individual hugs another
individual there will be a witness for this type.  $\Sigma$-types are
exploited for the semantics of natural language by \cite{Ranta1994}
among others.

Another approach to these more general types is to use \textit{record
  types} such as \nexteg{a,b} or, as we will prefer given our decision
in Section~\ref{sec:ptypes}
to use ptypes constructed from predicates rather than types
corresponding to common nouns, \nexteg{c}.
\begin{ex}
\begin{subex} 
 
\item \record{\tfield{x}{\textit{Ind}} \\
              \tfield{y}{\textit{Ind}} \\
              \tfield{e}{hug(x,y)}}
 
\item \record{\tfield{x}{\textit{Boy}} \\
              \tfield{y}{\textit{Dog}} \\
              \tfield{e}{hug(x,y)}} 

\item \record{\tfield{x}{\textit{Ind}} \\
              \tfield{c$_1$}{boy(x)} \\
              \tfield{y}{\textit{Ind}} \\
              \tfield{c$_2$}{dog(y)} \\
              \tfield{e}{hug(x,y)}}
 
\end{subex} 
\label{ex:rectype} 
\end{ex} 
\ignore{We make the notion of record type precise in
Appendix~\ref{app:rectypes}.}  In TTR, record types are labelled
sets.  A first approximation to the labelled sets represented in
\preveg{} is given in \nexteg{}.  (In Section~\ref{sec:depfields} we will introduce
a complication in connection with the dependency represented by
`hug(x,y)', `boy(x)' and `dog(y)'.)
\begin{ex} 
\begin{subex} 
 
\item \{$\langle$x, \textit{Ind}$\rangle$, $\langle$y,
  \textit{Ind}$\rangle$, $\langle$e, hug(x, y)$\rangle$\} 
 
\item \{$\langle$x, \textit{Boy}$\rangle$, $\langle$y,
  \textit{Dog}$\rangle$, $\langle$e, hug(x, y)$\rangle$\} 

\item \{$\langle$x, \textit{Ind}$\rangle$, $\langle$c$_1$,
  boy(x)$\rangle$, $\langle$y,
  \textit{Ind}$\rangle$, $\langle$c$_2$, dog(y)$\rangle$, $\langle$e, hug(x, y)$\rangle$\} 
 
\end{subex} 
   
\end{ex} 
`x', `y', `c$_1$', `c$_2$' and `e' are particular labels.  In record types, the ordered
pairs whose first member is a label are called \textit{fields}.  Thus
record types are sets of fields.  We will give a precise
characterization of which labelled sets are record types later. 

The witnesses of record types are \textit{records}.  These
are also labelled sets, consisting of ordered pairs which we will call
fields of the record.  However, in this case the fields consist of a
label and an object belonging to a type, rather than a type, as in the
fields of record types.  A record, $r$, is a witness for a record
type, $T$, just in case $r$ contains fields with the same labels as
those in $T$  and the objects in the fields in $r$ are of the type
with the corresponding label in $T$.  The record may contain
additional fields with labels not mentioned in the record type with
the restriction there can only be one field within the record with a
particular label.  Thus both \nexteg{a} and \nexteg{b} are records of
type (\ref{ex:rectype}a).
\begin{ex} 
\begin{subex} 
 
\item \begin{tabular}{lp{.6\textwidth}}\record{\field{x}{$a$} \\
              \field{y}{$b$} \\
              \field{e}{$s$} } &  where $a$:\textit{Ind},
            $b$:\textit{Ind} and $s$:hug($a$,$b$) \end{tabular}
 
\item \begin{tabular}{lp{.6\textwidth}}\record{\field{x}{$c$} \\
              \field{y}{$d$} \\
              \field{e}{$s'$} \\
              \field{z}{$a'$} \\
              \field{w}{$a''$}} &  where $c$:\textit{Ind},
            $d$:\textit{Ind}, $s'$:hug($c$,$d$) and $a'$ and $a''$ are
            objects of some type \end{tabular}
 
\end{subex} 
   
\end{ex} 
Note that in our notation for records we have `=' between the two
elements of the field whereas in record types we have `:'.  Note also
that when we have types constructed from predicates in our record
types and the arguments are represented as labels as in
(\ref{ex:rectype}a) this means that the type is \textit{dependent} on
what objects you choose for those labels in the object of the record
type.  Thus in \preveg{a} the type of the object labelled `e' is
hug($a$,$b$) whereas in \preveg{b} the type is hug($c$,$d$).
Actually, the notation we are using here for the dependent types is a
convenient simplification of what is needed as we will explain later\ignore{in
Appendix~\ref{app:rectypes}}.

Record types and $\Sigma$-types are very similar in an important
respect.  The type (\ref{ex:rectype}a) will be witnessed (``true'')
just in case there are individuals $x$ and $y$ such that $x$ hugs
$y$.  Thus both record types and $\Sigma$-types can be used to model
existential quantification.  In fact record types and $\Sigma$-types
are so similar that you would probably not want to have both kinds of
types in a single system and we will not use $\Sigma$-types.  We have
chosen to use record types for a number of reasons:

\paragraph{fields are unordered} The $\Sigma$-types in \nexteg{} are
distinct, although there is an obvious equivalence which holds between
them.
\begin{ex} 
\begin{subex} 
 
\item $\Sigma x$:\textit{Ind}.$\Sigma y$:\textit{Ind}.hug($x$,$y$) 
 
\item $\Sigma y$:\textit{Ind}.$\Sigma x$:\textit{Ind}.hug($x$,$y$) 
 
\end{subex} 
   
\end{ex} 
They are not only distinct types but they also have distinct sets of
witnesses.  The object $\langle a, \langle b, s\rangle\rangle$  will
be of type \preveg{a} just in case $\langle b, \langle a,
s\rangle\rangle$ is of type \preveg{b}.  In contrast, since we are
regarding record types (and records) as \textit{sets} of fields,
\nexteg{a,b} are variant notations for the same type.
\begin{ex} 
\begin{subex} 
 
\item \record{\tfield{x}{\textit{Ind}} \\
              \tfield{y}{\textit{Ind}} \\
              \tfield{c}{hug(x,y)}} 
 
\item \record{\tfield{y}{\textit{Ind}} \\
              \tfield{x}{\textit{Ind}} \\
              \tfield{c}{hug(x,y)}} 
 
\end{subex} 
   
\end{ex} 

\paragraph{labels} Record types (and their witnesses) include labelled
fields which can be used to access \textit{components} of what is being
modelled.  Components of a record are defined as objects which occur
in a record.  (A precise definition will be given later.)  This is useful, for example, when we want to analyze
anaphoric phenomena in language where pronouns and other words refer
back to parts of previous meanings in the discourse.  They can also be
exploited in other cases where we want to refer to components of
utterances or their meanings as in clarification questions.

\paragraph{discourse representation}  The labels in record types can
play the role of discourse referents in discourse representation
structures  \citep[DRSs,][]{KampReyle1993} and record types of the kind we are
proposing can be used to model DRSs.

\paragraph{dialogue game boards}  Record types have been exploited to
model dialogue game boards or information states \citep[see in
particular][]{Ginzburg2012}.

\paragraph{feature structures} Record types can be used to model the
kind of feature structures that linguists like to use (as, for example, in linguistic
theories like Head Driven Phrase Structure Grammar, HPSG,
\citealp{Sag:Wasow:ea:03}).  Here the labels in record types
correspond to attributes in feature structures.

\paragraph{frames}  Record types can also be used to model something
very like the kinds of frames discussed in frame semantics
\citep{Fillmore1982,Fillmore1985,RuppenhoferEllsworthPetruckJohnsonScheffczyk2006}
or in the psychological literature \citep{Barsalou1992a,Barsalou1999}.
The labels in record types correspond to roles (frame elements).

For discussion of some of the various uses to which record types can
be put see \cite{Cooper2005a}.  We will take up all of the uses named
here as we progress.

Another way of approaching more general types such as ``situation
where a boy hugs a dog'' is
to use \textit{contexts} as used in type theory.  \ignore{In \nexteg{} we take
$T \textit{true}$ to represent a judgement that $T$ is witnessed.}  If
we wish to express that an inference from ``$x$ hugs $y$'' to ``$x$
touches $y$'' we might consider doing it as in \nexteg{}
\begin{ex} 
$x$ : \textit{Ind}, $y$ : \textit{Ind}, $e$ : hug($x$,$y$) $\vdash$
$e$ : touch($x$,$y$) 
   
\end{ex} 
\preveg{} means that in a context where $x$ and $y$ are
individuals and $e$ is a witness for the type `hug($x$,$y$)' then $e$ is
also a witness for the type `touch($x$,$y$)'.  
% This notation is normally taken to mean universal
% quantification over the parameters or variables in the context (i.e. sequence of
% parametric type judgements) to the left of `$\vdash$'.  Thus they
% would mean that for any two individuals or pair of a boy and a dog,
% the first hugs the second.  However, we can also devise ways for
% thinking of existential quantification over the variables of the
% context, e.g. for some boy, $x$, and some dog, $y$, the type
% hug($x$,$y$) is non-empty. 
Contexts (as represented to the left of the turnstile (`$\vdash$') in \preveg{}) are
standardly thought of as sequences of judgements.  They are not
standardly thought of
being
objects which are witnesses for types in the type theory.  However, as
we develop our semantic theory in this book, we will want to think of
contexts as objects belonging to a certain type and to give semantic
analyses in terms of types of context.  Records and record
types will enable us to do this.  Thus, for example,
(\ref{ex:rectype}a) models the type of context represented to the left
of the turnstile in \preveg{}.
% \begin{ex} 
% $x$ : \textit{Ind}, $y$ : \textit{Ind}, $c$ : hug($x$,$y$) 
% \end{ex} 
As in the comparison with $\Sigma$-types there is a difference in that
the judgements in a standard type theory context are ordered whereas
the fields in a record type are unordered.  This means that
technically \nexteg{} is a distinct context from that in \preveg{} even though
there is an obvious equivalence between them.  
\begin{ex} 
$y$ : \textit{Ind}, $x$ : \textit{Ind}, $e$ : hug($x$,$y$) 
\end{ex} 
They correspond to the
same record type, however. % Since we will use record types to model
% type theoretic contexts and records to model instantiations of
% contexts we will not introduce a separate notion of context.

Thus we use record types to replace both the $\Sigma$-types and
contexts that one often finds in standard versions of type theory.

\subsubsection{Dependent fields in record types}
\label{sec:depfields}
Consider again the record type (\ref{ex:rectype}c) repeated as
\nexteg{}.
\begin{ex} 
\record{\tfield{x}{\textit{Ind}} \\
              \tfield{c$_1$}{boy(x)} \\
              \tfield{y}{\textit{Ind}} \\
              \tfield{c$_2$}{dog(y)} \\
              \tfield{e}{hug(x,y)}} 
\label{ex:bhd-ty}
\end{ex} 
Strictly speaking the notations `boy(x)', `dog(y)' and `hug(x,y)' do
not represent ptypes as we have defined them since `x' and `y' are
labels, not objects of type \textit{Ind} as required by the arities of
the predicates.  What we mean by this notation is that the labels are
to be replaced by whatever is in the field with that label in the
record that we are checking against the type.  Thus, for example, if
we are checking whether the record in \nexteg{a} is of the type
\preveg{} we need to check that the judgements listed in \nexteg{b}
are correct.
\begin{ex} 
\begin{subex} 
 
\item \record{\field{x}{$a$}\\
              \field{c$_1$}{$s_1$}\\
              \field{y}{$b$}\\
              \field{c$_2$}{$s_2$}\\
              \field{e}{$s_3$}}
 
\item $a$ : \textit{Ind}\\
      $s_1$ : boy($a$)\\
      $b$ : \textit{Ind}\\
      $s_2$ : dog($b$)\\
      $s_3$ : hug($a$,$b$)
 
\end{subex} 
   
\end{ex} 
The notation `boy(x)' in (\ref{ex:bhd-ty}) thus actually encodes two
pieces of information: firstly that we have what is known as a
\textit{dependent type}\label{pg:deptype}, a function which takes a certain type of
object and returns a type, and secondly that we give an address where we should look for the object in the record that we are
checking.  We will represent functions using $\lambda$-expressions
from a variant of the $\lambda$-calculus.  The relevant functions for
(\ref{ex:bhd-ty}) are given in \nexteg{}.
\begin{ex}
\begin{subex} 
 
\item $\lambda v$:\textit{Ind} . boy($v$) 
 
\item $\lambda v$:\textit{Ind} . dog($v$)

\item $\lambda v_1$:\textit{Ind} . $\lambda v_2$:\textit{Ind} . hug($v_1$,$v_2$) 
 
\end{subex} 
   
 
\end{ex} 
We shall normally use $v$, $v_1$, $v_2$, \ldots for the variables in
our functions.  In general if $\xi$ is a variable and
$\varphi\dep{\xi}$ represents an object containing the value of $\xi$, then we
use the notation $\lambda\xi$:$T$ . $\varphi\dep{\xi}$ to
represent the total function $f$ whose domain is the set of witnesses
of the type $T$ and for any $a:T$, $f(a)=\varphi\dep{a}$.  We shall
say something more precise about functions in Section~\ref{sec:funs}.

The second piece of information we need to provide is where to find
the object(s) which will serve as the arguments to these functions.
This will be a sequence of \textit{paths} in the record, providing a
path for each argument to the function.  A path is a string of labels
separated by `.' and corresponds to the general notion of paths for
labelled sets with the important exception that we exclude paths
containing the distinguished labels used in non-record structures.  We will make this notion precise in
Section~\ref{sec:recs-rectypes}.  In the case of our current example
we only need paths consisting of one label.

We will represent the dependent field as containing an ordered pair
consisting of the dependent type and the sequence of paths.  Thus
(\ref{ex:bhd-ty}) is more explicitly represented as \nexteg{}.
\begin{ex} 
\record{\tfield{x}{\textit{Ind}} \\
              \tfield{c$_1$}{$\langle\lambda v$:\textit{Ind}
                . boy($v$), $\langle$x$\rangle\rangle$} \\
              \tfield{y}{\textit{Ind}} \\
              \tfield{c$_2$}{$\langle\lambda v$:\textit{Ind}
                . dog($v$), $\langle$y$\rangle\rangle$} \\
              \tfield{e}{$\langle\lambda v_1$:\textit{Ind} . $\lambda
                v_2$:\textit{Ind} . hug($v_1$,$v_2$), $\langle$x,y$\rangle\rangle$}}  
\end{ex} 
This will
be our ``official'' notation although we will continue to use the
notation as in (\ref{ex:bhd-ty}) for the sake of readability when it
is not important to make this explicit.

The nature of dependent fields in record types as we have explained it
here means that before we can give an explicit account of record types,
we must first introduce type systems which contain
functions and ensure that those functions can return types in order to
give us the dependent types that we need.  This we will do in
Sections~\ref{sec:funs} and \ref{sec:type-Type}.



\subsubsection{Functions and function types}
\label{sec:funs} 

In \cite{Cooper2012} we left it open exactly what kind of object a
function is and assumed there was some theory of functions which would
allow us to characterize them in terms of their domain and range.  One
option commonly used in
a classical set theoretic setting is to let functions be modelled as
their \textit{graphs}, that is, a set of ordered pairs.  The graph of
a function $f$ can be characterized as the set in \nexteg{}.
\begin{ex} 
$\{\langle x,y\rangle\mid f(x)=y\}$ 
\end{ex} 
Ideally, we want a notion of function
that is more like a program or a procedure.  That is, functions can be
intensional in the sense that two distinct functions can correspond to
the same graph. However, it seems that for the purposes
at hand the standard extensional notion of function as a set of
ordered pairs is sufficient and consistent with the fact that we want
the $\lambda$-expressions we are using to represent unique functions.  For this
reason, we will model functions here as sets of ordered pairs in the
classical set-theoretic way.  Ultimately, we suspect that a more
computational and intensional notion of function should be
substituted.

\begin{shaded}
In \nexteg{} we characterize a system of complex types with function
types (repeated in Appendix~\ref{app:funtypes}).
\begin{ex} 
A system of complex types {\bf TYPE$_C$} = $\langle${\bf Type}, {\bf BType},
$\langle$\textbf{PType}, {\bf Pred}, \textbf{ArgIndices}, {\it Arity\/}$\rangle$, $\langle A,F\rangle$$\rangle$ \textit{has function types} if
\begin{enumerate} 
 
\item for any $T_1,T_2 \in \textbf{Type}$, $(T_1\rightarrow T_2) \in \textbf{Type}$ 
 
\item for any $T_1,T_2 \in \textbf{Type}$, $f:_{\mathbf{TYPE_C}}(T_1\rightarrow T_2)$ iff
  $f$ is a function whose domain is $\{a\mid
  a:_{\mathbf{TYPE_C}}T_1\}$ and whose range is included in $\{a\mid a:_{\mathbf{TYPE_C}}T_2\}$ 
 
\end{enumerate}

\label{ex:funtypes}
\end{ex} 
We specify a function type $(T_1\rightarrow T_2)$ to be the labelled
  set \nexteg{} where `dmn' (``domain'') and `rng' (``range'') are reserved labels.
\begin{ex}
$\{\langle\mathrm{dmn},T_1\rangle,\langle\mathrm{rng},T_2\rangle\}$
\end{ex}

The choice of modelling functions as sets of ordered pairs means that
$f:_{\mathbf{TYPE_C}}(T_1\rightarrow T_2)$ just in case $f\subseteq \{a\mid
  a:_{\mathbf{TYPE_C}}T_1\} \times \{a\mid a:_{\mathbf{TYPE_C}}T_2\}$
  and if $b \in \{a\mid
  a:_{\mathbf{TYPE_C}}T_1\}$ then there is exactly one $c$, such that
  $\langle b,c\rangle\in f$.  We shall say that in this case the
  result of applying the function $f$ to $b$, in symbols, $f(b)$, is
  $c$.

The informal proof theory version of (\ref{ex:funtypes}) is given in
\nexteg{}.
\begin{ex} 
For $\Gamma$, a system of complex types with function types:
\begin{subex} 
 
\item \begin{prooftree}
\hypo{\Gamma \vdash T_1\in\textbf{Type}}
\hypo{\Gamma \vdash T_2\in\textbf{Type}}
\infer2{\Gamma \vdash (T_1\rightarrow T_2)\in\textbf{Type}} 
\end{prooftree}
 
\item \begin{prooftree}
\hypo{[\Gamma\vdash a:T_1]}
\ellipsis{}{\Gamma\vdash f(a):T_2}
\hypo{[\Gamma\vdash f(a):T_2]}
\ellipsis{}{\Gamma\vdash a:T_1}
\infer2{\Gamma\vdash f:(T_1\rightarrow T_2)}
\end{prooftree} 

\item \begin{prooftree}
\hypo{\Gamma\vdash f:(T_1\rightarrow T_2)}
\hypo{\Gamma\vdash a:T_1}
\infer2{\Gamma\vdash f(a):T_2}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma\vdash f:(T_1\rightarrow T_2)}
\hypo{\Gamma\vdash f(a):T_2}
\infer2{\Gamma\vdash a:T_1}
\end{prooftree}
 
\end{subex} 
  
\end{ex} 
\preveg{a} tells us that for any two types, $T_1$ and $T_2$, we can
form the function type $(T_1\rightarrow T_2)$.  \preveg{b} tells us
that if we can prove that $f(a):T_2$ from the assumption that $a:T_1$
and we can also prove from the assumption $f(a):T_2$ that $a:T_1$,
then $f:(T_1\rightarrow T_2)$.  The first premise requires that the
function is defined on all witnesses for $T_1$ and the second premise
requires that anything on which the function is defined is a witness
for $T_1$.  Jointly they require that the domain of the function (the
set of objects on which it is defined) is the set of witnesses for
$T_1$.  \preveg{c} tells us that if we have a function of type
$(T_1\rightarrow T_2)$ and an object of type $T_1$ then the result of
applying the function to that object will be of type $T_2$.
Conversely, \preveg{d} tells us that if we have a function of type
$(T_1\rightarrow T_2)$ and the result of applying it to some object is
of type $T_2$, then that object must be of type $T_1$.  
\end{shaded}

If a function, $f$, is of type $(T_1\rightarrow T_2)$ we say that the
\textit{domain type} of $f$, $\mathrm{domtype}(f)$, is $T_1$.

We introduce a notation for functions based on the $\lambda$-calculus.
The notation is characterized in \nexteg{} where $v$ is a variable in
our notation.
\begin{ex} 
$\lambda v\!:\!T\ .\ \varphi$ is that function $f$ such that for any
$a:T$, $f(a)$ (the result of applying $f$ to $a$) is represented by
$\varphi[v\leftarrow a]$ (the result of replacing any free occurrence
of $v$ in $\varphi$ with $a$).
\label{ex:fun-notation}
\end{ex}
Note that $\mathrm{domtype}(\lambda v\!:\!T\ .\
\varphi)$ is $T$.


\begin{shaded}
In our informal proof theoretic representation this can be expressed
by \nexteg{} (where again $[v\leftarrow a]$ represents the replacement
of any free occurrence of the variable $v$ by $a$).
\begin{ex} 
\begin{subex} 
 
\item \begin{prooftree}
% \hypo{\Gamma\vdash T_1\in\textbf{Type}}
% \hypo{\Gamma\vdash T_2\in\textbf{Type}}
\hypo{[\Gamma\vdash a:T_1]}
\ellipsis{}{\Gamma\vdash\varphi[v\leftarrow a]:T_2}
\infer1{\Gamma\vdash\lambda v\!:\!T_1\ .\ \varphi :(T_1\rightarrow T_2)}
\end{prooftree} 
 
\item \begin{prooftree}
\hypo{\Gamma\vdash\lambda v\!:\!T_1\ .\ \varphi :(T_1\rightarrow T_2)}
\hypo{\Gamma\vdash a:T_1}
\infer2{\Gamma\vdash\lambda v\!:\!T_1\ .\ \varphi\ (a) =
  \varphi[v\leftarrow a] : T_2}
\end{prooftree} 
 
\end{subex} 
   
\end{ex} 

In this section we have introduced functions from objects of one type
to objects of another type.  However, it does not yet give us the
functions we need in the dependent fields of our record types since
these are functions which take objects of a type and return a
\textit{type}, that is, they are \textit{dependent types}.
\end{shaded}       

\subsubsection{The type \textit{Type}}
\label{sec:type-Type}
Up until now we have said that the witnesses of any type do not
overlap with the set of types.  We are now going to relax this
requirement in a restricted way by introducing a special type called \textit{Type}
whose witnesses are any type, that is, members of the set
\textbf{Type}.  We will call type systems that have types of types in
this way \textit{intensional} since this will be a key feature of our
treatment of natural language intensional constructions in
Chapter~\ref{ch:intensional}.\footnote{In Martin-Löf type theory,
  types of types are called \textit{universes}.  This is, however,
  potentially a confusing terminology for a theory relating to the
  kind of model theory which has been used in linguistics where
  ``universe'' has a different meaning.}  Since \textit{Type} is itself a type it will also be a
member of the set \textbf{Type} and this will mean that it has itself
as a witness, that is, \textit{Type} : \textit{Type}.  For everyday
working purposes we will assume that this is the system we have and
ignore the fact that this is bringing us into danger of introducing
Russell's paradox.  In the remainder of this subsection we will show
how the paradox can be avoided by using a technique called
stratification.  We will in future assume that our type systems are
stratified in this way without mentioning it explicitly for the most
part.  If you are not interested in the details of this you can skip
the rest of this subsection and come back to it if you feel the need.

% An intensional type system is one in which the types themselves become
% objects of a type. We introduce a distinguished type \textit{Type} to
% which all the members of the set \textbf{Type} belong.  Things are a
% little more complicated than this, though, since we want \textit{Type}
% itself to be a type and therefore it should belong to the set
% \textbf{Type}.  This would mean that \textit{Type} belongs to itself,
% i.e. \textit{Type}:\textit{Type}.  
Allowing types to belong to
themselves puts us in danger of creating a situation in which
Russell's paradox arises.  If some members of \textbf{Type} belong to
themselves then we should be able to talk of the set of types which do
not belong to themselves,
$\{T\in\mathbf{Type}\mid T\not\ : T\}$.  Suppose that some model
assigns this set to $T'$.  Then the question arises whether $T'$
belongs to itself and we can show that if $T':T'$ then $T'\not\ :T'$
and if $T'\not\ :T'$ then $T':T'$.  
In order to avoid this problem we
will \textit{stratify} (or \textit{ramify}) our type system by introducing types of
different \textit{orders}.   (For a discussion of stratification see
\citealp{Turner2005}.) A type system of order 0 will be a
system of complex types in the way we have defined it.  The
set of types, \textbf{Type}$^1$ of a type
system of order 1 based on this system will contain in addition to
everything in the original type system a type, \textit{Type}$^1$, to
which all the types of order 0, members of the set \textbf{Type}$^0$, belong.  In general for all the natural
numbers $n$, \textit{Type}$^{n+1}$ will be a type to which all the
types in \textbf{Type}$^n$ belong.

\begin{shaded}
We characterize an intensional system of complex types in \nexteg{}
(repeated in Appendix~\ref{app:int}).
\begin{ex}
An {\it intensional system of complex types\/} is a family of
quadruples indexed by the natural numbers:
\begin{display}
{\bf TYPE$_\mathit{IC}$} = $\langle${\bf Type}$^n$, {\bf BType},
$\langle$\textbf{PType}$^n$, {\bf Pred}, \textbf{ArgIndices}, {\it
  Arity\/}$\rangle$, $\langle A,F^n\rangle$$\rangle_{n\in\mathit{Nat}}$
\end{display}
where (using $\mathbf{TYPE}_{\mathit{IC}_n}$ to refer to the quadruple
indexed by $n$):
\begin{enumerate} 
 
\item for each $n$,$\langle${\bf Type}$^n$, {\bf BType},
$\langle$\textbf{PType}$^n$, {\bf Pred}, \textbf{ArgIndices}, {\it
  Arity\/}$\rangle$, $\langle A,F^n\rangle$$\rangle$ is a 
system of complex types  
 
\item for each $n$, $\mathbf{Type}^n\subseteq\mathbf{Type}^{n+1}$ and
  $\mathbf{PType}^n\subseteq\mathbf{PType}^{n+1}$

\item for each $n$, if $T\in\mathbf{PType}^n$ then $F^n(T)\subseteq F^{n+1}(T)$

\item for each $n>0$, $\mathit{Type}^n\in\mathbf{Type}^n$

\item for each $n>0$,
  $T:_{\mathbf{TYPE}_{\mathit{IC}_n}}\mathit{Type}^n$ iff $T\in\mathbf{Type}^{n-1}$
 
\end{enumerate}
\label{ex:int-type-sys}
\end{ex}

Here, but not in \cite{Cooper2012}, we make explicit that
\textit{Type} is a distinguished urelement and that \textit{Type}$^n$
represents the labelled set
$\{\langle\mathrm{ord},n\rangle,\langle\mathrm{typ},\mathit{Type}\rangle\}$
where `ord' and `typ' are reserved labels (``order'', ``type'').

In our informal proof theoretic notation we can characterize
intensional systems of complex types as in \nexteg{}.
\begin{ex} 
For $\{\Gamma^n\}_{n\in\mathit{Nat}}$ an intensional system of complex
types
\begin{subex} 
 
\item \begin{prooftree}
\hypo{\Gamma^n\vdash T\in\textbf{Type}^n}
\infer1{\Gamma^{n+1}\vdash T\in\textbf{Type}^{n+1}}
\end{prooftree} 
 
\item \begin{prooftree}
\hypo{\Gamma^n\vdash T\in\textbf{PType}^n}
\infer1{\Gamma^{n+1}\vdash T\in\textbf{PType}^{n+1}}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma^n\vdash a:T}
\infer1{\Gamma^{n+1}\vdash a:T}
\end{prooftree}

\item \begin{prooftree}
\infer0[$n>0$]{\Gamma^n\vdash\textit{Type}^n\in\textbf{Type}^n}
\end{prooftree} 

\item \begin{prooftree}
\hypo{\Gamma^n\vdash T\in\textbf{Type}^n}
\infer1{\Gamma^{n+1}\vdash T:\textit{Type}^{n+1}}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma^n\vdash T:\textit{Type}^n}
\infer1[$n>0$]{\Gamma^{n-1}\vdash T\in\textbf{Type}^{n-1}}
\end{prooftree} 
 
\end{subex} 
   
\end{ex} 

For the most part in the remainder of this book we will suppress the
$n$-superscripts.  This means that we will characterize a function
such as \nexteg{a} as being of the type \nexteg{b} whereas in fact it
is a witness for all the types characterized in \nexteg{c}.
\begin{ex} 
\begin{subex} 
 
\item $\lambda v$:\textit{Ind} . dog($v$) 
 
\item (\textit{Ind}$\rightarrow$\textit{Type})

\item \{(\textit{Ind}$\rightarrow$\textit{Type}$^n$) $\mid$ $n>0$\} 
 
\end{subex} 
   
\end{ex} 
\end{shaded}  
  

\begin{shaded}
\subsubsection{Definitions of records and record types}
\label{sec:recs-rectypes}
A record according to a set of labels $\mathcal{L}$ and a type
system $\mathbb{T}$   is a
finite labelled set 
whose labels are included in $\mathcal{L}$ and whose labelled elements
are witnesses of some type according to $\mathbb{T}$.
Records are characterized by the definition in \nexteg{}.
\begin{ex} 
$r$ is a \textit{record according to a set of labels $\mathcal{L}$ and a type
system $\mathbb{T}$} (Appendix~\ref{app:rec}) iff $r$ is a finite labelled set
(Appendix~\ref{app:sets}) whose labels are included in $\mathcal{L}$
and for any labelled element, $v$, in $r$, there is some type $T$ such
that $v:_{\mathbb{T}}T$.
\label{ex:records} 
\end{ex}
In giving our informal proof theoretic characterization of the set of
records we will use \nexteg{} to mean
that $r$ is a record according to type system $\Gamma$ and set of
labels $\mathcal{L}$.
\begin{ex} 
$\Gamma,\mathcal{L}\vdash r \text{ record}$ 
\end{ex}     
We give the characterization inductively in
\nexteg{}.
\begin{ex}
For $\Gamma$ a type system and $\mathcal{L}$ a set of labels 
\begin{subex} 
 
\item \begin{prooftree}
\infer0{\Gamma,\mathcal{L}\vdash\emptyset\text{ record}}
\end{prooftree} 
 
\item \begin{prooftree}
\hypo{\Gamma\vdash a:T}
\hypo{\Gamma,\mathcal{L}\vdash r \text{ record}}
\hypo{\ell\in\mathcal{L}-\mathrm{labels}(r)}
\infer3{\Gamma,\mathcal{L}\vdash r\cup\{\langle\ell,a\rangle\}\text{
    record}}
\end{prooftree} 
 
\end{subex} 
   
\end{ex} 
  
 
If $r$ is a record and $\langle\ell,v\rangle$
is in $r$, we call $\langle\ell,v\rangle$ a \textit{field} of $r$,
$\ell$ a {\it label\/} in $r$ and $v$ a {\it value\/} in $r$ (the
\textit{value of $\ell$ in $r$}).
We use $r.\ell$ to denote $v$.  \ignore{$r.\ell$ is called a \textit{path}
  in $r$.}

Records, as labelled sets, will have paths as defined for labelled
sets.  However, we will want in addition a more restricted notion of
path for records which excludes those paths which include the
distinguished labels used in non-record structures which may be values
in a record.
\begin{ex} 
If $X$ is a labelled set based on a set of labels, $\mathcal{L}$
including a set of distinguished labels, $\mathcal{D}$, then
\begin{enumerate} 
 
\item if $\ell\in\mathrm{labels}(X)$ and $\ell\not\in\mathcal{D}$, then $\ell\in\mathrm{paths}_{\mathcal{L}\setminus\mathcal{D}}(X)$ 
 
\item if $\ell\in\mathrm{labels}(X)$ and $\ell\not\in\mathcal{D}$, $X.\ell$ is a labelled set and
  $\pi\in\mathrm{paths}_{\mathcal{L}\setminus\mathcal{D}}(X.\ell)$, then $\ell.\pi\in\mathrm{paths}_{\mathcal{L}\setminus\mathcal{D}}(X)$
\end{enumerate}  
\end{ex}
We will sometimes use `$\mathrm{paths}$' without the subscript for this
more restricted notion when there is no risk for confusion.

We use a tabular format to
represent records.  A record as given in \nexteg{a} 
 is displayed as \nexteg{b}.
\begin{ex} 
\begin{subex} 
 
\item $\{\langle\ell_1,v_1\rangle,\ldots,\langle\ell_n,v_n\rangle\}$ 
 
\item \record{\field{$\ell_1$}{$v_1$} \\
        &\vdots& \\
        \field{$\ell_n$}{$v_n$}} 
 
\end{subex} 
   
\end{ex} 

We now move to characterizing record types.  Record types are, with
two exceptions of distinguished non-complex record types, flavoured
labelled sets using a flavour which we represent as `RT', the
record-type flavour.  We first characterize
type systems which have non-dependent record types (that is, record
types which do not have dependent fields).  Non-dependent record types
are labelled sets whose labelled elements are types.  We characterize a type
system with complex types and non-dependent record types in \nexteg{}
(repeated in Appendix~\ref{app:rectypes}).
\begin{ex} 
A system of complex types \textbf{TYPE}$_C$ = $\langle${\bf Type}, {\bf BType},
$\langle$\textbf{PType}, {\bf Pred}, \textbf{ArgIndices}, {\it
  Arity\/}$\rangle$, $\langle A,F\rangle$$\rangle$ \textit{has
  (non-dependent) record
  types based on $\langle \mathcal{L}, \mathbf{RType}\rangle$}, where $\mathcal{L}$ is a countably infinite set (of labels)
and \textbf{RType} $\subseteq$ \textbf{Type} and \textbf{RType} if
\begin{enumerate} 
 
\item $\mathit{Rec}\in\mathbf{RType}$

\item $r:_{\mathbf{TYPE}_C}\mathit{Rec}$ iff $r$ is a record according
  to $\mathcal{L}$ and \textbf{TYPE$_C$}.

\item $\mathit{ERec}\in\mathbf{RType}$

\item $r:_{\mathbf{TYPE}_C}\mathit{ERec}$ iff $r=\emptyset$

\item if $\ell\in\mathcal{L}$ and $T\in\mathbf{Type}$, then
  $\{\text{RT},\langle\ell,T\rangle\}\in\mathbf{RType}$.

\item $r:_{\mathbf{TYPE}_C}\{\text{RT},\langle\ell,T\rangle\}$ iff
  $r:_{\mathbf{TYPE}_C}\mathit{Rec}$, $\langle\ell,a\rangle\in r$ and
  $a:_{\mathbf{TYPE}_C}T$.

\item if $R\in\mathbf{RType}-\{\mathit{Rec},\mathit{ERec}\}$, $\ell\in\mathcal{L}$, $\ell$ does not occur as a
  label in $R$ (i.e. there is no field $\langle\ell',T'\rangle$ in $R$
  such that $\ell'=\ell$) and $T\in\mathbf{Type}$, then
  $R\cup\{\langle\ell,T\rangle\}\in\mathbf{RType}$.\label{cl:ndrectype-emb}

\item $r:_{\mathbf{TYPE}_C}R\cup\{\langle\ell,T\rangle\}$ iff
  $r:_{\mathbf{TYPE}_C}R$, $\langle\ell,a\rangle\in r$ and $a:_{\mathbf{TYPE}_C}T$.
 
\end{enumerate} 
\label{ex:ndrectypes}
\end{ex} 
In this definition we introduced two distinguished non-complex types:
\textit{Rec}, the type of all records (clauses 1 and 2), and
\textit{ERec}, the type of the empty record (clauses 3 and 4). In
clauses 5 and 6 we introduce records with a single field, $\langle\ell,T\rangle$, the type of
records which contain a field with label $\ell$ and an
object of type $T$.  Clauses 7 and 8 are recursion clauses that add a
single field, $\langle\ell,T\rangle$, to any record type with at least one field (that is,
those record types which are labelled sets).  A record will be a
witness for the new type if it is of the old type and it contains a
field with the label $\ell$ and an object of type $T$.

In terms of our informal proof theoretic notation this can be
expressed as \nexteg{}.
\begin{ex}
For $\Gamma$ a system of complex types which has record types based on
$\langle\mathcal{L},\text{RType}\rangle$, $\mathcal{L}$ a countably
infinite set of labels: 
\begin{subex} 
 
\item \begin{prooftree}
\infer0{\Gamma,\mathcal{L}\vdash\textit{Rec}\in\text{RType}}
\end{prooftree} 
 
\item \begin{prooftree}
\hypo{\Gamma,\mathcal{L}\vdash r\text{ record}}
\infer1{\Gamma,\mathcal{L}\vdash r:\textit{Rec}}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma,\mathcal{L}\vdash r:\textit{Rec}}
\infer1{\Gamma,\mathcal{L}\vdash r\text{ record}}
\end{prooftree}

\item \begin{prooftree}
\infer0{\Gamma,\mathcal{L}\vdash\textit{ERec}\in\text{RType}}
\end{prooftree}

\item \begin{prooftree}
\infer0{\Gamma,\mathcal{L}\vdash\emptyset:\textit{ERec}}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma,\mathcal{L}\vdash r:\textit{ERec}}
\infer1{\Gamma,\mathcal{L}\vdash r=\emptyset:\textit{ERec}}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma\vdash T\in\textbf{Type}}
\infer1{\Gamma,\mathcal{L}\vdash T\in\textbf{Type}}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma\vdash a:T}
\infer1{\Gamma,\mathcal{L}\vdash a:T}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma,\mathcal{L}\vdash T\in\text{RType}}
\infer1{\Gamma,\mathcal{L}\vdash T\in\textbf{Type}}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma,\mathcal{L}\vdash T\in\textbf{Type}}
\hypo{\ell\in\mathcal{L}}
\infer2{\Gamma,\mathcal{L}\vdash\{\text{RT},\langle\ell,T\rangle\}\in\text{RType}}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma,\mathcal{L}\vdash r:\textit{Rec}}
\hypo{\Gamma,\mathcal{L}\vdash a:T}
\hypo{\langle\ell,a\rangle\in r} 
\infer3{\Gamma,\mathcal{L}\vdash r:\{\text{RT},\langle\ell,T\rangle\}}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma,\mathcal{L}\vdash T\in\textbf{Type}}
\hypo{\Gamma,\mathcal{L}\vdash
  R\in\text{RType}-\{\textit{Rec},\textit{ERec}\}}
\hypo{\ell\in\mathcal{L}-\mathrm{labels}(R)}
\infer3{\Gamma,\mathcal{L}\vdash
  R\cup\{\langle\ell,T\rangle\}\in\text{RType}}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma,\mathcal{L}\vdash a:T}
\hypo{\Gamma,\mathcal{L}\vdash R\in\text{RType}}
\hypo{\Gamma,\mathcal{L}\vdash r:R}
\hypo{\ell\in\mathcal{L}-\mathrm{labels}(R)}
\hypo{\langle\ell,a\rangle\in r}
\infer5{\Gamma,\mathcal{L}\vdash r:R\cup\{\langle\ell,T\rangle\}}
\end{prooftree}
 
\end{subex} 
   
\end{ex} 
\preveg{a} tells us that \textit{Rec} is a distinguished record type
(corresponding to (\ref{ex:ndrectypes}), clause 1).
\preveg{b and c} tell us that $r$:\textit{Rec} just in case $r$ is a
record (corresponding to (\ref{ex:ndrectypes}), clause 2).  \preveg{d} introduces \textit{ERec} as a distinguished record
type (corresponding to (\ref{ex:ndrectypes}), clause 3) and \preveg{e and f} tells us that the empty set is the only
witness for \textit{ERec} (corresponding to (\ref{ex:ndrectypes}),
clause 4).  \preveg{g and h} tell us respectively that
anything which is a type according to the system is also a type
according to the system and the set of labels and similarly that
anything which is a witness for a type according to the system will be
a witness for that type according to the system and the set of labels.
\preveg{i} requires that any record type is also a type according to
the system (corresponding to the requirement \textbf{RType}$\subseteq$\textbf{Type}).  \preveg{j} introduces record types with one
field.$\langle\ell,T\rangle$ (corresponding to (\ref{ex:ndrectypes}),
clause 5) and
\preveg{k} tells us that a record containing a field with label $\ell$
and an object of type  $T$ will be a witness
for such a record type (corresponding to (\ref{ex:ndrectypes}), clause
6). \preveg{l and m} are inductive rules which,
respectively, tell us that you can add a new field,
$\langle\ell,T\rangle$, to a record type, $R$,
provided $\ell$ is not already a label of $R$ (corresponding to
(\ref{ex:ndrectypes}), clause 7) and that a record, $r$, is of
the new type just in case $r:R$ and it contains a field
$\langle\ell,a\rangle$ such that $a:T$ (corresponding to
(\ref{ex:ndrectypes}), clause 8).

The issue of what counts as a path in a record type is a little
complex.  As for records it is based on the definition of paths for
labelled sets but excluding the distinguished labels used in
non-record structures such as ptypes.  However, we will make one
exception to this when we introduce meet types since it will be
important to include paths into meet types.  We will discuss this when
we introduce meet types in Chapter~\ref{ch:infex}.

We can add dependent record types to systems which have non-dependent
record types.  In order to do this we need dependent types, that is,
functions which return types and for this we need the type
\textit{Type} as introduced in intensional systems of complex types
characterized in (\ref{ex:int-type-sys}).  We characterize an
intensional system of types with (non-dependent) record types in
\nexteg{}, repeated in Appendix~\ref{app:rectypes}.
\begin{ex} 
An {\it intensional system of complex types\/} {\bf TYPE$_\mathit{IC}$} = $\langle${\bf Type}$^n$, {\bf BType},
$\langle$\textbf{PType}$^n$, {\bf Pred}, \textbf{ArgIndices}, {\it
  Arity\/}$\rangle$, $\langle
A,F^n\rangle$$\rangle_{n\in\mathit{Nat}}$ \textit{has (non-dependent) record types
  based on} $\langle\mathcal{L}, \mathbf{RType}^n\rangle_{n\in\mathit{Nat}}$ if
for each $n$,  $\langle${\bf Type}$^n$, {\bf BType},
$\langle$\textbf{PType}$^n$, {\bf Pred}, \textbf{ArgIndices}, {\it
  Arity\/}$\rangle$, $\langle
A,F^n\rangle$$\rangle$ has record types based on $\langle
L,\mathbf{RType}^n\rangle$ and
\begin{enumerate} 
 
\item for each $n$, \textbf{RType}$^n$ $\subseteq$ \textbf{RType}$^{n+1}$ 
 
\item for each $n>0$, \textit{RecType}$^n$ $\in$ \textbf{Type}$^n$

\item for each $n>0$,
  $T:_{\mathbf{TYPE}_{\mathit{IC}_n}}\mathit{RecType}^n$ iff $T\in\mathbf{RType}^{n-1}$
 
\end{enumerate}  
\label{ex:int-ndrectype-sys}
\end{ex} 
The definition in \preveg{} requires that an intensional system with
record types is a family of systems with record types, indexed by the
natural numbers such that any record type in a system indexed by a
natural number $n$ will also be a record type in the system indexed by
$n+1$.  It also introduces as distinguished type \textit{RecType}$^n$
for each level $n$ above 0 whose witnesses are the record types of the
level $n-1$.  In our informal proof-theoretic notation this can be
expressed in as in \nexteg{}.
\begin{ex} 
For $\{\Gamma^n\}_{n\in\textit{Nat}}$ an intensional system of complex
types with (non-dependent) record types
\begin{subex} 
 
\item \begin{prooftree}
\hypo{\Gamma^n\vdash T\in\textbf{RType}^n}
\infer1{\Gamma^{n+1}\vdash T\in\textbf{RType}^{n+1}}
\end{prooftree} 
 
\item \begin{prooftree}
\infer0[$n>0$]{\Gamma^n\vdash\textit{RecType}^n\in\textbf{Type}^n}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma^n\vdash T\in\textbf{RType}^n}
\infer1{\Gamma^{n+1}\vdash T:\textit{RecType}^{n+1}}
\end{prooftree}

\item \begin{prooftree}
\hypo{\Gamma^n\vdash T:\textit{RecType}^n}
\infer1[$n>0$]{\Gamma^{n-1}\vdash T\in\textbf{RType}^{n-1}}
\end{prooftree}

 
 
\end{subex} 
   
\end{ex} 
\preveg{a} requires that any record type on one level will be a record
type on the next higher level (corresponding to
(\ref{ex:int-ndrectype-sys}), clause 1).  \preveg{b} introduces the
distinguished type \textit{RecType} on all levels above 0 (corresponding to
(\ref{ex:int-ndrectype-sys}), clause 2).  \preveg{c and d} requires
that the witnesses of \textit{RecType} are exactly the record types
which are in the system one level down (corresponding to
(\ref{ex:int-ndrectype-sys}), clause 3).

Now we can introduce dependent record types by adding them to
intensional type systems with record types.  The 
characterization of type systems with dependent record types is given
in \nexteg{} (repeated in Appendix~\ref{app:rectypes}).
\begin{ex} 
An {\it intensional system of complex types\/} {\bf TYPE$_\mathit{IC}$} = $\langle${\bf Type}$^n$, {\bf BType},
$\langle$\textbf{PType}$^n$, {\bf Pred}, \textbf{ArgIndices}, {\it
  Arity\/}$\rangle$, $\langle
A,F^n\rangle$$\rangle_{n\in\mathit{Nat}}$ \textit{has dependent record types
  based on} $\langle\mathcal{L}, \mathbf{RType}^n\rangle_{n\in\mathit{Nat}}$,
if it has record types based on $\langle\mathcal{L},
\mathbf{RType}^n\rangle_{n\in\mathit{Nat}}$ and for each $n>0$
\begin{enumerate} 
 
\item if $R\in\textbf{RType}^n$, $\ell\in\mathcal{L}-\mathrm{labels}(R)$, $T_1,\ldots,T_m\in\mathbf{Type}^n$, $\pi_1,\ldots,\pi_m\in\mathrm{paths}(R)$ and
    % ${\cal F}$ is a function of type $((a_1:T_1)\rightarrow\ldots\rightarrow((a_m:T_m)\rightarrow\mathit{Type}^n)\ldots)$, then $R \cup \{\langle\ell, \langle{\cal F}, \langle\pi_1,\ldots,\pi_m\rangle\rangle\rangle\}\in\mathbf{RType}^n$.
${\cal T}$ is a function of type $(T_1\rightarrow\ldots\rightarrow(T_m\rightarrow\mathit{Type}^n)\ldots)$, then $R \cup \{\langle\ell, \langle{\cal T}, \langle\pi_1,\ldots,\pi_m\rangle\rangle\rangle\}\in\mathbf{RType}^n$.    


 
\item $r :_{\mathbf{TYPE}_{\mathit{IC}_n}}R\cup\{\langle\ell, \langle{\cal T}, \langle\pi_1,\ldots,\pi_m\rangle\rangle\rangle\}$ iff $r :_{\mathbf{TYPE}_{\mathit{IC}_n}} R$, $\langle\ell, a\rangle$ is a field
in $r$,  $r.\pi_1:_{\mathbf{TYPE}_{\mathit{IC}_n}}T_1,\ldots,r.\pi_m:_{\mathbf{TYPE}_{\mathit{IC}_n}}T_m$ and  $a :_{\mathbf{TYPE}_{\mathit{IC}_n}} {\cal T}(r.\pi_1)\ldots(r.\pi_m)$.  
 
\end{enumerate}
\label{ex:int-drectype-sys} 
 
\end{ex} 
\preveg{}, clause~1 says that for any record type $R$ we can create a new record
type by adding a field
$\langle\ell,\langle\mathcal{T},\langle\pi_1,...,\pi_m\rangle\rangle\rangle$,
where $\ell$ is not a topmost label in $R$, $\mathcal{T}$ is an
$m$-place function which returns a type and $\pi_1,...,\pi_m$ are
paths in $R$.  Clause~2 says that a record $r$ is of the new type just
in case it is of type $R$, $\langle\ell,a\rangle$ is a field in $r$,
$r.\pi_1,\ldots, r.\pi_m$ are appropriate arguments to $\mathcal{T}$ and
$a$ is of the type resulting from the application of $\mathcal{T}$ to
$r.\pi_1,\ldots, r.\pi_m$. In terms of our informal proof theoretic
notation we can express this as \nexteg{}.
\begin{ex} 
For $\{\Gamma^n\}_{n\in\textit{Nat}}$ an intensional system of complex
types with dependent record types based on
$\langle\mathcal{L},\textbf{RType}^n\rangle_{n\in\textit{Nat}}$
\begin{subex} 
 
\item \begin{prooftree}
\hypo{\text{\begin{tabular}{ccc}
$\Gamma^n\vdash R\in\textbf{RType}^n$&$\Gamma^n\vdash
                                     T_1,\ldots,T_m\in\textbf{Type}^n$&$\ell\in\mathcal{L}-\mathrm{labels}(R)$\\\multicolumn{2}{c}{$\Gamma^n\vdash\mathcal{T}:(T_1\rightarrow\ldots\rightarrow(T_m\rightarrow\textit{Type}^n)\ldots)$}
&$\pi_1,...,\pi_m\in\mathrm{paths}(R)$
\end{tabular}}}
\infer1{\Gamma^n\vdash
R\cup\{\langle\ell,\langle\mathcal{T},\langle\pi_1,\ldots,\pi_m\rangle\rangle\rangle\}\in\textbf{RType}^n}
\end{prooftree}

\item \begin{prooftree}
% \hypo{\text{\begin{tabular}{ccc}
% $\Gamma^n\vdash r:R$&$\langle\ell,a\rangle\in
%                       r$&$\ell\in\mathcal{L}-\mathrm{labels}(R)$\\
% \multicolumn{2}{c}{$\Gamma^n\vdash
%               r.\pi_1:T_1,\ldots,r.\pi_m:T_m$}&$\Gamma^n\vdash
%                                                 a:\mathcal{T}(r.\pi_1)\ldots(r.\pi_m)$
% \end{tabular}}}
\hypo{\Gamma^n\vdash r:R}
\hypo{\langle\ell,a\rangle\in r}
\hypo{\ell\in\mathcal{L}-\mathrm{labels}(R)}
% \hypo{\Gamma^n\vdash r.\pi_1:T_1,\ldots,r.\pi_m:T_m}
 \hypo{\Gamma^n\vdash a:\mathcal{T}(r.\pi_1)\ldots(r.\pi_m)}
\infer4{\Gamma^n\vdash
r:R\cup\{\langle\ell,\langle\mathcal{T},\langle\pi_1,\ldots,\pi_m\rangle\rangle\rangle\}} 
\end{prooftree}
 
\end{subex} 
   
\end{ex} 
\preveg{a} corresponds to (\ref{ex:int-drectype-sys}), clause~1.  It
says that for any record type $R$ not containing $\ell$ among its
labels, any sequence of a subset of $R$'s paths, $\pi_1,\ldots,\pi_m$, and a
dependent type $\mathcal{T}$ with $m$ arguments, we can obtain a new
record type by adding the field,
$\langle\ell,\langle\mathcal{T},\langle\pi_1,\ldots,\pi_m\rangle\rangle\rangle$
to $R$.  \preveg{b} corresponds to (\ref{ex:int-drectype-sys}),
clause~2.  It says that if a record, $r$, is of type $R$ and contains
a field $\langle\ell,a\rangle$, where $\ell$ is not a label in $R$ and
$a$ is of the type obtained by applying the dependent type
$\mathcal{T}$ to $r.\pi_1,\ldots,r.\pi_m$, then $r$ is of the record
type resulting from adding the field $\langle\ell,\langle\mathcal{T},\langle\pi_1,\ldots,\pi_m\rangle\rangle\rangle$
to $R$. As usual, the force of the biconditional in
(\ref{ex:int-drectype-sys}b) is provided by the fact that \preveg{b}
is part of an inductive definition and it is the only rule which
specifies under which conditions a record is a witness for the record
type with the additional dependent field. 

Note that both records and record types may contain types in their
fields.  Minimal examples are given in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item \record{\field{$\ell$}{$T$}} 
 
\item \record{\tfield{$\ell$}{$T$}} 
 
\end{subex} 
   
\end{ex} 
The record and the type in \preveg{} are distinct objects which
nevertheless seem to correspond to the same set of ordered pairs.  We
distinguish them by modelling the record as an unflavoured labelled
set and the record type as a flavoured labelled set as given in
\nexteg{a and b} respectively.
\begin{ex} 
\begin{subex} 
 
\item $\{\langle\ell,T\rangle\}$ 
 
\item $\{\text{RT},\langle\ell,T\rangle\}$   
 
\end{subex} 
   
\end{ex} 
    


% These types play a role in the ``propositions as types'' dictum which
% comes from type theory.  If hug($a$,$b$) is the type of events where
% $a$ hugs $b$ then the sentence ``$a$ hugs $b$'' will be true just in
% case this type is non-empty, that is, just in case there is an
% event where $a$ hugs $b$.  The type can function as the theoretical
% object corresponding to the informal notion of proposition.  It is
% ``true'' just in case it is non-empty.

% Types constructed from predicates are introduced in
% Section~\ref{sec:complex}.  We also introduce there a number of other
% kinds of complex types such as meets (conjunction), joins
% (disjunction) and function types.
\end{shaded}

\subsubsection{Subtyping in record types}
An important property of record types is that they introduce a
restrictive notion of subtyping.  Intuitively $T_1$ is a subtype of
$T_2$ (in symbols $T_1\sqsubseteq T_2$) just in case for any $a$, $a:T_1$ implies $a:T_2$, \textit{no
  matter what is assigned to the basic types and ptypes}.  Consider
the types in \nexteg{}.
\begin{ex} 
\begin{subex} 
 
\item \record{\tfield{x}{\textit{Ind}} \\
              \tfield{c$_1$}{boy(x)} \\
              \tfield{y}{\textit{Ind}} \\
              \tfield{c$_2$}{dog(y)}
             }  
 
\item \record{\tfield{x}{\textit{Ind}} \\
              \tfield{c$_1$}{boy(x)} \\
              \tfield{y}{\textit{Ind}} \\
              \tfield{c$_2$}{dog(y)} \\
              \tfield{e}{hug(x,y)}}  
 
\end{subex} 
   
\end{ex} 
\preveg{a} is intuitively the type of situation in which there is a
boy and a dog.  \preveg{b} is the type of situation in which there is
a boy and a dog and the boy hugs the dog.  Clearly any situation of
type \preveg{b} must be of type \preveg{a}.  This holds independently
of what boys and dogs there are and what kind of hugging is going on.
We can tell that \preveg{b} is a subtype of \preveg{a} simply by the
fact that the set of fields of \preveg{a} is a subset of the set of
fields of \preveg{b}. We will notice other ways in which you can
recognize that one record type is a subtype of another as we progress.

\begin{shaded}
Subtyping on this view is a \textit{modal} notion.  This means that we
do not just consider one type system but a collection of type systems
which assign different objects to the basic types and ptypes.  We call
such a collection a \textit{modal type system}.  This
corresponds intuitively to a set of possibilities under
consideration.  A type, $T_1$, is a subtype of another type, $T_2$,
with respect to a modal type system just in case for each of the
systems in the modal type system any witness for $T_1$ is also a
witness for $T_2$.  We characterize a modal system of complex
types as a collection of systems of complex types in \nexteg{}, repeated in Appendix~\ref{app:modal}.  We use $M$
as a variable over pairs $\langle A,F\rangle$ where $A$ is an
assignment of witnesses to the basic types of a system of complex
types and $F$ is an
assignment to the ptypes of that system.
\begin{ex} 
A \textit{modal system of complex types based on $\mathcal{M}$} is a
family of quadruples:
\begin{quote}
{\bf TYPE$_{\mathit{MC}}$} = $\langle${\bf Type}$_M$, {\bf BType},
$\langle$\textbf{PType}$_M$, {\bf Pred}, \textbf{ArgIndices}, {\it Arity\/}$\rangle, M\rangle_{M\in\mathcal{M}}$
\end{quote}
where for each $M\in \mathcal{M}$, $\langle${\bf Type}$_M$, {\bf BType},
$\langle$\textbf{PType}$_M$, {\bf Pred}, \textbf{ArgIndices}, {\it Arity\/}$\rangle, M\rangle$ is
a system of complex types.

\label{ex:modalsys-complex}
\end{ex}
We call the individual systems of complex types in such a system the
\textit{possibilities} of the system.  The set of basic types and the
predicates and their arities are held constant across the different
possibilities whereas the set of ptypes (and therefore the set of types
in general) will vary since different assignments to the basic types
will generate different arguments to the predicates and thus different
ptypes.  We can then define the notion of subtype with respect to a
modal system of complex types as in \nexteg{}.
\begin{ex} 
$T_1$ \textit{is a subtype$_i$ of} $T_2$ \textit{in} {\bf TYPE$_{\mathit{MC}}$},
  $T_1\sqsubseteq_{\mathbf{TYPE_{\mathit{MC}}}}T_2$,  iff for all
  $M\in\mathcal{M}$, if $T_1$ and $T_2$ are members of
  \textbf{Type}$_M$, then $\{a\mid a:_{\mathbf{TYPE}_{\mathit{MC}_M}}T_1\}\subseteq\{a\mid a:_{\mathbf{TYPE}_{\mathit{MC}_M}}T_2\}$ 
\end{ex} 
We can recast this in our informal proof theoretic notation as
\nexteg{}.
\begin{ex} 
  For $\mathcal{G}$ a modal system of complex types
  \begin{subex} 
 
  \item
    \begin{prooftree}
      \hypo{[\Gamma\in\mathcal{G},\ \Gamma\vdash x:T_1,\ \Gamma\vdash
        T_2\in\textbf{Type}]}
      \ellipsis{}{\Gamma\vdash x:T_2}
      \infer1{\mathcal{G}\vdash T_1\sqsubseteq T_2}
    \end{prooftree}
    
 
  \item
    \begin{prooftree}
      \hypo{\mathcal{G}\vdash T_1\sqsubseteq T_2}
      \hypo{\Gamma\in\mathcal{G}}
      \hypo{\Gamma\vdash a:T_1}
      \hypo{\Gamma\vdash T_2\in\textbf{Type}}
      \infer4{\Gamma\vdash a:T_2}
    \end{prooftree}
    
 
\end{subex}   
\end{ex} 
A disadvantage of \preveg{a} is that it does not tell us exactly what
types would count as being in the subtype relation on the basis of the
nature of the types.  In the case of record types we can often
recognize the subtype relation on the basis of the structure of the
types. For example, a record type $T_1$ is a subtype of a record type
$T_2$ if $T_2\subseteq T_1$. (Recall that record types are sets of
fields.)  This means that we can have the informal inference rule in
\nexteg{}.
\begin{ex} 
  For $\mathcal{G}$, a modal system of complex types
  \begin{quote}
    \begin{prooftree}
      \hypo{\Gamma,\Delta\in\mathcal{G}}
      \hypo{\Gamma\vdash T_1\in\textbf{RType}}
      \hypo{\Delta\vdash T_2\in\textbf{RType}}
      \hypo{T_2\subseteq T_1}
      \infer4{\mathcal{G}\vdash T_1\sqsubseteq T_2}
    \end{prooftree}
  \end{quote}
  
    
\end{ex} 
We will introduce more such specific inference rules later.  
  
\end{shaded}



 


\section{Intensionality: propositions as types}
\label{sec:props-as-types}

Kim continues to think about the boy and the dog as she walks along.
It was fun to see them playing together.  They seemed so happy.  The
boy obviously thought that the dog was a good playmate.  Kim is not
only able to perceive events as being of certain types.  She is able
to recall and reflect on these types.  She is able to form attitudes
towards these types: it was fun that the boy and the dog were playing but
a little worrying that they were so close to the pond.  This means
that the types themselves seem to be arguments to predicates like
`fun' and `worrying'.  This seems to be an important human ability --
not only to be able to take part in or observe an event and find it
fun or worrying but to be able to reflect independently of the actual
occurrence of the event that it or in general similar events are fun
or worrying.  This is a source of great richness in human cognition in
that it enables us to consider situation types independently of their
actual instantiation.\footnote{This richness also has its downside in
  that we often become so engaged in our internal cognitive abstraction
  that it can be difficult to be fully present and conscious of our
  direct perception of the world -- for example, worrying about what
  might happen in the future rather than enjoying the present.}  This
abstraction also enables us to consider what attitudes other
individuals might have.  For example, Kim believes that the boy
thought that the dog was a good playmate.  She is able to ascribe this
belief to the boy.  Furthermore, we are able to reflect on Kim's state
of mind where she has a belief concerning the type of situation where
the boy thinks that the dog was a good playmate.  And somebody else
could consider of us that we have a certain belief about Kim
concerning her belief about the boy's belief.  There
is in principle no limit to the depth of recursion concerning our
attitudes towards types.

We propose to capture this reflective nature of human cognition by
making the type theory technically \textit{reflective} in the sense
that we
allow types themselves to be objects which can belong to other types.
In classical model theoretic semantics we think of
\textit{believe} as corresponding to a relation between individuals
and propositions.  In our type theory, however, we are subscribing to
the ``propositions as types'' view which comes to us via
\cite{Martin-Loef1984} and has its origins in intuitionistic logic
(see \citealp{Ranta1994}, Section~2.16 for discussion).  Propositions are true or false.  Types of situations such as
hug($a$,$b$) correspond to propositions in the sense that if they are
non-empty then the proposition is true. If there is nothing of this
type then it is false.  The reasoning is thus that we do not need
propositions in our system as separate semantic objects if we already
have types.  We can use the types to play the role of propositions.
To believe a type is to believe it to be non-empty.  From the point of view
of a type theory for cognition in which we connect types to our basic
perceptual ability, this provides a welcome link between our perceptual
ability and our ability to entertain propositions (that is,  to
consider whether they are
true or false).  We will develop this idea in Chapter~\ref{ch:intensional}.


\section{Summary}

In this chapter we started with a notion of perception as type
assignment: perceiving an object or a situation involves judging it to
be of a certain type.  We ended with the promise that the
kind of types used for perception will be used in the analysis of intensional constructions in
natural language which involve attitudes (such as belief or desire) to
propositions using the ``propositions as types'' dictum.  An
important point here is that while the origin of the system of types
we use lies in perception, there is no claim that all the types
which we can have attitudes to are types which have been used in
perception.  We have developed the ability to reflect on and reason
about the types themselves even types that we have not encountered any
witness for or that we know could not possibly have a witness.

In this chapter we introduced four kinds of types and a way of
modelling them mathematically:  basic types which are not structured,
ptypes which are constructed from a predicate and appropriate
arguments to the predicate, function types and record types containing labelled
fields which contain types.  Record types may contain dependent fields
where the type in the field depends on objects in other fields.  In
the remainder of the book we will add more kinds of types as we need
them.   


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "ttl"
%%% End: 
